with Ada.Assertions;
with Ada.Numerics.Generic_Elementary_Functions;

package body Maths_Functions is
   
   use Ada.Assertions;
   package R_Funcs is new Ada.Numerics.Generic_Elementary_Functions( Real );
   use R_Funcs;
   
  function Evaluate_Polynomial( a : Real_Array; x : Real ) return Real is
     -- translation of devlpl.f from 
     -- http://www3.sympatico.ca/craymer/software/fortran/dcdflib/
     sum : Real := a( a'Last );
  begin
     for i in reverse a'Last-1 .. a'First loop
        sum := a( i ) + ( sum * x );
     end loop;
     return sum;
  end Evaluate_Polynomial;
  
  function Cumulative_Normal( x : Real ) return Real is
      rtwo  : constant Real :=  1.41421356237310E+00;
      trtwo : constant Real := 2.82842712474619E+00;
      frtwo : constant Real := 5.65685424949238E+00;
      srtwo : constant Real := 8.48528137423857E+00;
     
      A1 : constant Real_Array( 0 .. 20 ) := (
          2.94268192595158E-01,
         -1.20794002859252E-01,
         -5.38155411612267E-03,
          9.61245872309754E-03,
         -1.56928442055175E-03,
         -3.13379686339925E-04,
          1.34539944432857E-04,
         -2.01886311941572E-06,
         -6.02924420904726E-06,
          7.33514212717164E-07,
          1.68200375041707E-07,
         -4.21496636122487E-08,
         -2.34089537886964E-09,
          1.54397950861409E-09,
         -3.83910453258562E-11,
         -4.18791755643448E-11,
          3.66254323806330E-12,
          8.67662501706706E-13,
         -1.38490737068408E-13,
         -1.30609215123467E-14,
         3.76420840390550E-15 );  

      A2 : constant Real_Array( 0 .. 22 ) := (
       3.93098827656776E-01,
       0.0,
      -5.72072868438617E-03,
       0.0,
       1.18630151591342E-04,
       0.0,
      -3.91103704629101E-06,
       0.0,
       1.72795234431416E-07,
       0.0,
      -9.42361518118889E-09,
       0.0,
       6.04595735693237E-10,
       0.0,
      -4.42225118426537E-11,
       0.0,
       3.60747153118711E-12,
       0.0,
      -3.22932023145379E-13,
       0.0,
       3.13323522258447E-14,
       0.0,
      -3.26302072101379E-15 );


      A3 : constant Real_Array( 0 .. 15 ) := (
       2.66657721330163E-01,
       8.94380310492471E-03,
      -1.90087646908402E-03,
       3.48555717528185E-04,
      -5.81844230476253E-05,
       9.06838380458210E-06,
      -1.33859970500872E-06,
       1.88850668170541E-07,
      -2.56245596590501E-08,
       3.35935312400552E-09,
      -4.27010392442662E-10,
       5.27726756655456E-11,
      -6.35545872359585E-12,
       7.47249710210314E-13,
      -8.59121451944801E-14,
       9.67175305486972E-15,
      -1.06741339515971E-15 );

      p    : Real;
      xx   : Real;
      z    : Real;
      tz   : Real;
      b1   : Real;
      b2   : Real;
      temp : Real;
      ans  : Real;
      xs   : Real;

      j    : Natural;

      n1 : constant := 21;
      n2 : constant := 23;
      n3 : constant := 17;
      m1 : constant := 19;
      m2 : constant := 21;
      m3 : constant := 15;

      elim : constant Real := 2.303  *( 1022.0 *0.3010299957 - 3.0 );
      --  xlim is used to test for underflow
      xlim : constant Real := -1.0 * sqrt( 2.0 * elim);
      
   begin
      Assert( x > xlim, "Underflow: x = " & Real'Image( x ) & " xlim " & Real'Image( xlim )); 
      xx := x;
      if( xx >= srtwo )then
         return 1.0;
      end if;
      if( xx > frtwo )then
         z := frtwo / xx;
         tz := z + z;
         j := n2 - 1;
         b1 := a2(j);
         b2 := 0.0;
         for i in 1 .. m2 loop
            j := j - 1;
            temp := b1;
            b1 := tz * b1 - b2 + a2(j);
            b2 := temp;
         end loop;
         ans := z*b1 - b2 + a2(0);
         p := ( Exp( -xx * xx * 0.5 ) / xx ) * ans;
         p := 1.0 - p;
         return p;
      end if;
      
      if( xx > trtwo )then
         xs := xx / rtwo;
         z  := xs - 3.0;
         tz := z + z;
         j  := n3 - 1;
         b1 := a3(j);
         b2 := 0.0;
         for i in 1 .. m3 loop
            j := j - 1;
            temp := b1;
            b1 := tz*b1 - b2 + a3(j);
            b2 := temp;
         end loop;
         ans := z*b1 - b2 + a3( 0 );
         p := Exp( -xs * xs ) * ans / xs;
         if( xx > 0.0 )then
            p := 1.0 - p;
         end if;
         return p;
      end if;
      
      if( xx >= -trtwo )then
         z := abs( xx ) / rtwo - 1.0;
         tz := z + z;
         j := n1 - 1;
         b1 := a1(j);
         b2 := 0.0;
         for i in 1 .. m1 loop
            j := j - 1;
            temp := b1;
            b1 := tz*b1 - b2 + a1(j);
            b2 := temp;
         end loop;
         p := xx * ( z*b1 - b2 + a1(0) ) + 0.5;
         return p;
      end if;
      
      if( xx <= -frtwo )then
         xx := -xx;
         z := frtwo/xx;
         tz := z + z;
         j := n2 - 1;
         b1 := a2(j);
         b2 := 0.0;
         for i in 1 .. m2 loop
            j := j - 1;
            temp := b1;
            b1 := tz*b1 - b2 + a2(j);
            b2 := temp;
         end loop;
         ans := z*b1 - b2 + a2(0);
         p := ( Exp( -xx * xx * 0.5 ) / xx ) * ans;
         return p;
      end if;
      xs := -xx / rtwo;
      z := xs - 3.0;
      tz := z + z;
      j := n3 - 1;
      b1 := a3(j);
      b2 := 0.0;
      for i in 1 .. m3 loop
         j := j - 1;
         temp := b1;
         b1 := tz*b1 - b2 + a3(j);
         b2 := temp;
      end loop;
      ans := z*b1 - b2 + a3(0);
      p := Exp(-xs*xs)*ans/xs;
      if ( xx > 0.0 )then
         p := 1.0 - p;
      end if;
      Assert( p >= 0.0 and p <= 1.0, "Cumulative_Normal: p should be in range 0.0 .. 1.0 was " & Real'Image( p ));
      return p;
   end Cumulative_Normal;
   
   function Inverse_Cumulative_Normal( p : Real ) return Real is
      -- from Delphi implementation from
      -- http://home.online.no/~pjacklam/notes/invnorm/impl/mccormick/icnorm.pas
      A : constant Real_Array( 1 .. 6 ) := (
          -3.969683028665376e+01,
           2.209460984245205e+02,
          -2.759285104469687e+02,
           1.383577518672690e+02,
          -3.066479806614716e+01,
           2.506628277459239e+00 );
           
      B : constant Real_Array( 1 .. 5 ) := (
          -5.447609879822406e+01,
           1.615858368580409e+02,
          -1.556989798598866e+02,
           6.680131188771972e+01,
          -1.328068155288572e+01 );
          
      C : constant Real_Array( 1 .. 6 ) := (
          -7.784894002430293e-03,
          -3.223964580411365e-01,
          -2.400758277161838e+00,
          -2.549732539343734e+00,
           4.374664141464968e+00,
           2.938163982698783e+00 );
   
      D : constant Real_Array( 1 .. 4 ) := (
          7.784695709041462e-03,
          3.224671290700398e-01,
          2.445134137142996e+00,
          3.754408661907416e+00 );
   
      -- Define break-points.
      P_LOW  : constant Real := 0.02425;
      P_HIGH : constant Real := 1.0 - P_LOW;

      q      : Real;
      r      : Real;
      result : Real;
   begin
      Assert( p > 0.0 and p < 1.0, "p should be in range 0.0 .. 1.0 was " & Real'Image( p ));
      -- Rational approximation for lower region.
      if p < P_LOW then
         q := Sqrt( -2.0 * Log( p ));
         result := ((((( c( 1 ) * q + c( 2 )) * q + c( 3 )) * q + c( 4 )) * q + c( 5 )) * q + c( 6 )) /
            ((((d( 1 ) * q + d( 2 )) * q + d( 3 )) * q + d( 4 )) * q + 1.0);
     -- Rational approximation for central region.
      elsif p <= P_HIGH  then
         q := p - 0.5 ;
         r := q ** 2 ;
         result := ((((( a( 1 ) * r + a( 2 )) * r + a( 3 )) * r + a( 4 )) * r + a( 5 )) * r + a( 6 )) * q /
           (((((b( 1 ) * r + b( 2 )) * r + b( 3 )) * r + b( 4 )) * r + b( 5 )) * r + 1.0) ;
      else
      -- Rational approximation for upper region.
         q := Sqrt( -2.0 * Log( 1.0 - p ));
         result := -((((( c( 1 ) * q + c( 2 )) * q + c( 3 )) * q + c( 4 )) * q + c( 5 )) * q + c( 6 )) /
             ((((d( 1 ) * q + d( 2 )) * q + d( 3 )) * q + d( 4 )) * q + 1.0)  ;
      end if;
      return result;
   end Inverse_Cumulative_Normal;

end Maths_Functions;
