
   procedure Create_Account_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.nsamt := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0304;


   procedure Create_Admin_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.ncr1 := Convert( slices, 5 );
            rec.ncr2 := Convert( slices, 6 );
            rec.ncr3 := Convert( slices, 7 );
            rec.ncr4 := Convert( slices, 8 );
            rec.ncr5 := Convert( slices, 9 );
            rec.ncr6 := Convert( slices, 10 );
            rec.ncr7 := Convert( slices, 11 );
            rec.refr01 := Convert( slices, 12 );
            rec.refr02 := Convert( slices, 13 );
            rec.refr03 := Convert( slices, 14 );
            rec.refr04 := Convert( slices, 15 );
            rec.refr05 := Convert( slices, 16 );
            rec.refr06 := Convert( slices, 17 );
            rec.refr07 := Convert( slices, 18 );
            rec.refr08 := Convert( slices, 19 );
            rec.refr09 := Convert( slices, 20 );
            rec.refr10 := Convert( slices, 21 );
            rec.refr11 := Convert( slices, 22 );
            rec.refr12 := Convert( slices, 23 );
            rec.refr13 := Convert( slices, 24 );
            rec.refr14 := Convert( slices, 25 );
            rec.refr15 := Convert( slices, 26 );
            rec.refr16 := Convert( slices, 27 );
            rec.refr17 := Convert( slices, 28 );
            rec.refr18 := Convert( slices, 29 );
            rec.tnc := Convert( slices, 30 );
            rec.version := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0304;


   procedure Create_Adult_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accssamt := Convert( slices, 13 );
            rec.accsspd := Convert( slices, 14 );
            rec.adeduc := Convert( slices, 15 );
            rec.adema := Convert( slices, 16 );
            rec.ademaamt := Convert( slices, 17 );
            rec.ademapd := Convert( slices, 18 );
            rec.age := Convert( slices, 19 );
            rec.allow1 := Convert( slices, 20 );
            rec.allow2 := Convert( slices, 21 );
            rec.allow3 := Convert( slices, 22 );
            rec.allow4 := Convert( slices, 23 );
            rec.allpay1 := Convert( slices, 24 );
            rec.allpay2 := Convert( slices, 25 );
            rec.allpay3 := Convert( slices, 26 );
            rec.allpay4 := Convert( slices, 27 );
            rec.allpd1 := Convert( slices, 28 );
            rec.allpd2 := Convert( slices, 29 );
            rec.allpd3 := Convert( slices, 30 );
            rec.allpd4 := Convert( slices, 31 );
            rec.anyacc := Convert( slices, 32 );
            rec.anyed := Convert( slices, 33 );
            rec.anymon := Convert( slices, 34 );
            rec.anypen1 := Convert( slices, 35 );
            rec.anypen2 := Convert( slices, 36 );
            rec.anypen3 := Convert( slices, 37 );
            rec.anypen4 := Convert( slices, 38 );
            rec.anypen5 := Convert( slices, 39 );
            rec.anypen6 := Convert( slices, 40 );
            rec.anypen7 := Convert( slices, 41 );
            rec.apamt := Convert( slices, 42 );
            rec.apdamt := Convert( slices, 43 );
            rec.apdir := Convert( slices, 44 );
            rec.apdpd := Convert( slices, 45 );
            rec.appd := Convert( slices, 46 );
            rec.b2qfut1 := Convert( slices, 47 );
            rec.b2qfut2 := Convert( slices, 48 );
            rec.b2qfut3 := Convert( slices, 49 );
            rec.b3qfut1 := Convert( slices, 50 );
            rec.b3qfut2 := Convert( slices, 51 );
            rec.b3qfut3 := Convert( slices, 52 );
            rec.b3qfut4 := Convert( slices, 53 );
            rec.b3qfut5 := Convert( slices, 54 );
            rec.b3qfut6 := Convert( slices, 55 );
            rec.ben1q1 := Convert( slices, 56 );
            rec.ben1q2 := Convert( slices, 57 );
            rec.ben1q3 := Convert( slices, 58 );
            rec.ben1q4 := Convert( slices, 59 );
            rec.ben1q5 := Convert( slices, 60 );
            rec.ben1q6 := Convert( slices, 61 );
            rec.ben1q7 := Convert( slices, 62 );
            rec.ben2q1 := Convert( slices, 63 );
            rec.ben2q2 := Convert( slices, 64 );
            rec.ben2q3 := Convert( slices, 65 );
            rec.ben3q1 := Convert( slices, 66 );
            rec.ben3q2 := Convert( slices, 67 );
            rec.ben3q3 := Convert( slices, 68 );
            rec.ben3q4 := Convert( slices, 69 );
            rec.ben3q5 := Convert( slices, 70 );
            rec.ben3q6 := Convert( slices, 71 );
            rec.ben4q1 := Convert( slices, 72 );
            rec.ben4q2 := Convert( slices, 73 );
            rec.ben4q3 := Convert( slices, 74 );
            rec.ben5q1 := Convert( slices, 75 );
            rec.ben5q2 := Convert( slices, 76 );
            rec.ben5q3 := Convert( slices, 77 );
            rec.ben5q4 := Convert( slices, 78 );
            rec.ben5q5 := Convert( slices, 79 );
            rec.ben5q6 := Convert( slices, 80 );
            rec.ben7q1 := Convert( slices, 81 );
            rec.ben7q2 := Convert( slices, 82 );
            rec.ben7q3 := Convert( slices, 83 );
            rec.ben7q4 := Convert( slices, 84 );
            rec.ben7q5 := Convert( slices, 85 );
            rec.ben7q6 := Convert( slices, 86 );
            rec.ben7q7 := Convert( slices, 87 );
            rec.ben7q8 := Convert( slices, 88 );
            rec.ben7q9 := Convert( slices, 89 );
            rec.btwacc := Convert( slices, 90 );
            rec.claimant := Convert( slices, 91 );
            rec.cohabit := Convert( slices, 92 );
            rec.combid := Convert( slices, 93 );
            rec.convbl := Convert( slices, 94 );
            rec.ctclum1 := Convert( slices, 95 );
            rec.ctclum2 := Convert( slices, 96 );
            rec.cupchk := Convert( slices, 97 );
            rec.cvht := Convert( slices, 98 );
            rec.cvpay := Convert( slices, 99 );
            rec.cvpd := Convert( slices, 100 );
            rec.dentist := Convert( slices, 101 );
            rec.depend := Convert( slices, 102 );
            rec.disdif1 := Convert( slices, 103 );
            rec.disdif2 := Convert( slices, 104 );
            rec.disdif3 := Convert( slices, 105 );
            rec.disdif4 := Convert( slices, 106 );
            rec.disdif5 := Convert( slices, 107 );
            rec.disdif6 := Convert( slices, 108 );
            rec.disdif7 := Convert( slices, 109 );
            rec.disdif8 := Convert( slices, 110 );
            rec.dob := Convert( slices, 111 );
            rec.dptcboth := Convert( slices, 112 );
            rec.dptclum := Convert( slices, 113 );
            rec.dvil03a := Convert( slices, 114 );
            rec.dvil04a := Convert( slices, 115 );
            rec.dvjb12ml := Convert( slices, 116 );
            rec.dvmardf := Convert( slices, 117 );
            rec.ed1amt := Convert( slices, 118 );
            rec.ed1borr := Convert( slices, 119 );
            rec.ed1int := Convert( slices, 120 );
            rec.ed1monyr := Convert( slices, 121 );
            rec.ed1pd := Convert( slices, 122 );
            rec.ed1sum := Convert( slices, 123 );
            rec.ed2amt := Convert( slices, 124 );
            rec.ed2borr := Convert( slices, 125 );
            rec.ed2int := Convert( slices, 126 );
            rec.ed2monyr := Convert( slices, 127 );
            rec.ed2pd := Convert( slices, 128 );
            rec.ed2sum := Convert( slices, 129 );
            rec.edatt := Convert( slices, 130 );
            rec.edattn1 := Convert( slices, 131 );
            rec.edattn2 := Convert( slices, 132 );
            rec.edattn3 := Convert( slices, 133 );
            rec.edhr := Convert( slices, 134 );
            rec.edtime := Convert( slices, 135 );
            rec.edtyp := Convert( slices, 136 );
            rec.eligadlt := Convert( slices, 137 );
            rec.eligchld := Convert( slices, 138 );
            rec.emppay1 := Convert( slices, 139 );
            rec.emppay2 := Convert( slices, 140 );
            rec.emppay3 := Convert( slices, 141 );
            rec.empstat := Convert( slices, 142 );
            rec.endyr := Convert( slices, 143 );
            rec.epcur := Convert( slices, 144 );
            rec.es2000 := Convert( slices, 145 );
            rec.ethgrp := Convert( slices, 146 );
            rec.everwrk := Convert( slices, 147 );
            rec.exthbct1 := Convert( slices, 148 );
            rec.exthbct2 := Convert( slices, 149 );
            rec.exthbct3 := Convert( slices, 150 );
            rec.eyetest := Convert( slices, 151 );
            rec.follow := Convert( slices, 152 );
            rec.fted := Convert( slices, 153 );
            rec.ftwk := Convert( slices, 154 );
            rec.future := Convert( slices, 155 );
            rec.govpis := Convert( slices, 156 );
            rec.govpjsa := Convert( slices, 157 );
            rec.grant := Convert( slices, 158 );
            rec.grtamt1 := Convert( slices, 159 );
            rec.grtamt2 := Convert( slices, 160 );
            rec.grtdir1 := Convert( slices, 161 );
            rec.grtdir2 := Convert( slices, 162 );
            rec.grtnum := Convert( slices, 163 );
            rec.grtsce1 := Convert( slices, 164 );
            rec.grtsce2 := Convert( slices, 165 );
            rec.grtval1 := Convert( slices, 166 );
            rec.grtval2 := Convert( slices, 167 );
            rec.gta := Convert( slices, 168 );
            rec.hbothamt := Convert( slices, 169 );
            rec.hbothbu := Convert( slices, 170 );
            rec.hbothpd := Convert( slices, 171 );
            rec.hbothwk := Convert( slices, 172 );
            rec.hbotwait := Convert( slices, 173 );
            rec.health := Convert( slices, 174 );
            rec.hholder := Convert( slices, 175 );
            rec.hosp := Convert( slices, 176 );
            rec.hprob := Convert( slices, 177 );
            rec.hrpid := Convert( slices, 178 );
            rec.incdur := Convert( slices, 179 );
            rec.injlong := Convert( slices, 180 );
            rec.injwk := Convert( slices, 181 );
            rec.invests := Convert( slices, 182 );
            rec.iout := Convert( slices, 183 );
            rec.isa1type := Convert( slices, 184 );
            rec.isa2type := Convert( slices, 185 );
            rec.isa3type := Convert( slices, 186 );
            rec.jobaway := Convert( slices, 187 );
            rec.lareg := Convert( slices, 188 );
            rec.likewk := Convert( slices, 189 );
            rec.lktime := Convert( slices, 190 );
            rec.ln1rpint := Convert( slices, 191 );
            rec.ln2rpint := Convert( slices, 192 );
            rec.loan := Convert( slices, 193 );
            rec.loannum := Convert( slices, 194 );
            rec.look := Convert( slices, 195 );
            rec.lookwk := Convert( slices, 196 );
            rec.lstwrk1 := Convert( slices, 197 );
            rec.lstwrk2 := Convert( slices, 198 );
            rec.lstyr := Convert( slices, 199 );
            rec.mntamt1 := Convert( slices, 200 );
            rec.mntamt2 := Convert( slices, 201 );
            rec.mntct := Convert( slices, 202 );
            rec.mntfor1 := Convert( slices, 203 );
            rec.mntfor2 := Convert( slices, 204 );
            rec.mntgov1 := Convert( slices, 205 );
            rec.mntgov2 := Convert( slices, 206 );
            rec.mntpay := Convert( slices, 207 );
            rec.mntpd1 := Convert( slices, 208 );
            rec.mntpd2 := Convert( slices, 209 );
            rec.mntrec := Convert( slices, 210 );
            rec.mnttota1 := Convert( slices, 211 );
            rec.mnttota2 := Convert( slices, 212 );
            rec.mntus1 := Convert( slices, 213 );
            rec.mntus2 := Convert( slices, 214 );
            rec.mntusam1 := Convert( slices, 215 );
            rec.mntusam2 := Convert( slices, 216 );
            rec.mntuspd1 := Convert( slices, 217 );
            rec.mntuspd2 := Convert( slices, 218 );
            rec.ms := Convert( slices, 219 );
            rec.natid1 := Convert( slices, 220 );
            rec.natid2 := Convert( slices, 221 );
            rec.natid3 := Convert( slices, 222 );
            rec.natid4 := Convert( slices, 223 );
            rec.natid5 := Convert( slices, 224 );
            rec.natid6 := Convert( slices, 225 );
            rec.ndeal := Convert( slices, 226 );
            rec.newdtype := Convert( slices, 227 );
            rec.nhs1 := Convert( slices, 228 );
            rec.nhs2 := Convert( slices, 229 );
            rec.nhs3 := Convert( slices, 230 );
            rec.niamt := Convert( slices, 231 );
            rec.niethgrp := Convert( slices, 232 );
            rec.niexthbb := Convert( slices, 233 );
            rec.ninatid1 := Convert( slices, 234 );
            rec.ninatid2 := Convert( slices, 235 );
            rec.ninatid3 := Convert( slices, 236 );
            rec.ninatid4 := Convert( slices, 237 );
            rec.ninatid5 := Convert( slices, 238 );
            rec.ninatid6 := Convert( slices, 239 );
            rec.ninatid7 := Convert( slices, 240 );
            rec.ninatid8 := Convert( slices, 241 );
            rec.nipd := Convert( slices, 242 );
            rec.nireg := Convert( slices, 243 );
            rec.nirel := Convert( slices, 244 );
            rec.nitrain := Convert( slices, 245 );
            rec.nlper := Convert( slices, 246 );
            rec.nolk1 := Convert( slices, 247 );
            rec.nolk2 := Convert( slices, 248 );
            rec.nolk3 := Convert( slices, 249 );
            rec.nolook := Convert( slices, 250 );
            rec.nowant := Convert( slices, 251 );
            rec.nssec := Convert( slices, 252 );
            rec.ntcapp := Convert( slices, 253 );
            rec.ntcdat := Convert( slices, 254 );
            rec.ntcinc := Convert( slices, 255 );
            rec.ntcorig1 := Convert( slices, 256 );
            rec.ntcorig2 := Convert( slices, 257 );
            rec.ntcorig3 := Convert( slices, 258 );
            rec.ntcorig4 := Convert( slices, 259 );
            rec.ntcorig5 := Convert( slices, 260 );
            rec.numjob := Convert( slices, 261 );
            rec.numjob2 := Convert( slices, 262 );
            rec.oddjob := Convert( slices, 263 );
            rec.oldstud := Convert( slices, 264 );
            rec.otabspar := Convert( slices, 265 );
            rec.otamt := Convert( slices, 266 );
            rec.otapamt := Convert( slices, 267 );
            rec.otappd := Convert( slices, 268 );
            rec.othtax := Convert( slices, 269 );
            rec.otinva := Convert( slices, 270 );
            rec.pareamt := Convert( slices, 271 );
            rec.parepd := Convert( slices, 272 );
            rec.penlump := Convert( slices, 273 );
            rec.ppnumc := Convert( slices, 274 );
            rec.prit := Convert( slices, 275 );
            rec.prscrpt := Convert( slices, 276 );
            rec.ptwk := Convert( slices, 277 );
            rec.r01 := Convert( slices, 278 );
            rec.r02 := Convert( slices, 279 );
            rec.r03 := Convert( slices, 280 );
            rec.r04 := Convert( slices, 281 );
            rec.r05 := Convert( slices, 282 );
            rec.r06 := Convert( slices, 283 );
            rec.r07 := Convert( slices, 284 );
            rec.r08 := Convert( slices, 285 );
            rec.r09 := Convert( slices, 286 );
            rec.r10 := Convert( slices, 287 );
            rec.r11 := Convert( slices, 288 );
            rec.r12 := Convert( slices, 289 );
            rec.r13 := Convert( slices, 290 );
            rec.r14 := Convert( slices, 291 );
            rec.redamt := Convert( slices, 292 );
            rec.redany := Convert( slices, 293 );
            rec.rentprof := Convert( slices, 294 );
            rec.retire := Convert( slices, 295 );
            rec.retire1 := Convert( slices, 296 );
            rec.retreas := Convert( slices, 297 );
            rec.royal1 := Convert( slices, 298 );
            rec.royal2 := Convert( slices, 299 );
            rec.royal3 := Convert( slices, 300 );
            rec.royal4 := Convert( slices, 301 );
            rec.royyr1 := Convert( slices, 302 );
            rec.royyr2 := Convert( slices, 303 );
            rec.royyr3 := Convert( slices, 304 );
            rec.royyr4 := Convert( slices, 305 );
            rec.rstrct := Convert( slices, 306 );
            rec.sex := Convert( slices, 307 );
            rec.sflntyp1 := Convert( slices, 308 );
            rec.sflntyp2 := Convert( slices, 309 );
            rec.sftype1 := Convert( slices, 310 );
            rec.sftype2 := Convert( slices, 311 );
            rec.sic := Convert( slices, 312 );
            rec.slrepamt := Convert( slices, 313 );
            rec.slrepay := Convert( slices, 314 );
            rec.slreppd := Convert( slices, 315 );
            rec.soc2000 := Convert( slices, 316 );
            rec.spcreg1 := Convert( slices, 317 );
            rec.spcreg2 := Convert( slices, 318 );
            rec.spcreg3 := Convert( slices, 319 );
            rec.specs := Convert( slices, 320 );
            rec.spout := Convert( slices, 321 );
            rec.srentamt := Convert( slices, 322 );
            rec.srentpd := Convert( slices, 323 );
            rec.start := Convert( slices, 324 );
            rec.startyr := Convert( slices, 325 );
            rec.taxcred1 := Convert( slices, 326 );
            rec.taxcred2 := Convert( slices, 327 );
            rec.taxcred3 := Convert( slices, 328 );
            rec.taxcred4 := Convert( slices, 329 );
            rec.taxcred5 := Convert( slices, 330 );
            rec.taxfut := Convert( slices, 331 );
            rec.tdaywrk := Convert( slices, 332 );
            rec.tea := Convert( slices, 333 );
            rec.topupl := Convert( slices, 334 );
            rec.totint := Convert( slices, 335 );
            rec.train := Convert( slices, 336 );
            rec.trav := Convert( slices, 337 );
            rec.tuborr := Convert( slices, 338 );
            rec.typeed := Convert( slices, 339 );
            rec.unpaid1 := Convert( slices, 340 );
            rec.unpaid2 := Convert( slices, 341 );
            rec.voucher := Convert( slices, 342 );
            rec.w1 := Convert( slices, 343 );
            rec.w2 := Convert( slices, 344 );
            rec.wait := Convert( slices, 345 );
            rec.war1 := Convert( slices, 346 );
            rec.war2 := Convert( slices, 347 );
            rec.wftcboth := Convert( slices, 348 );
            rec.wftclum := Convert( slices, 349 );
            rec.whoresp := Convert( slices, 350 );
            rec.whosectb := Convert( slices, 351 );
            rec.whyfrde1 := Convert( slices, 352 );
            rec.whyfrde2 := Convert( slices, 353 );
            rec.whyfrde3 := Convert( slices, 354 );
            rec.whyfrde4 := Convert( slices, 355 );
            rec.whyfrde5 := Convert( slices, 356 );
            rec.whyfrde6 := Convert( slices, 357 );
            rec.whyfrey1 := Convert( slices, 358 );
            rec.whyfrey2 := Convert( slices, 359 );
            rec.whyfrey3 := Convert( slices, 360 );
            rec.whyfrey4 := Convert( slices, 361 );
            rec.whyfrey5 := Convert( slices, 362 );
            rec.whyfrey6 := Convert( slices, 363 );
            rec.whyfrpr1 := Convert( slices, 364 );
            rec.whyfrpr2 := Convert( slices, 365 );
            rec.whyfrpr3 := Convert( slices, 366 );
            rec.whyfrpr4 := Convert( slices, 367 );
            rec.whyfrpr5 := Convert( slices, 368 );
            rec.whyfrpr6 := Convert( slices, 369 );
            rec.whytrav1 := Convert( slices, 370 );
            rec.whytrav2 := Convert( slices, 371 );
            rec.whytrav3 := Convert( slices, 372 );
            rec.whytrav4 := Convert( slices, 373 );
            rec.whytrav5 := Convert( slices, 374 );
            rec.whytrav6 := Convert( slices, 375 );
            rec.wintfuel := Convert( slices, 376 );
            rec.wmkit := Convert( slices, 377 );
            rec.working := Convert( slices, 378 );
            rec.wpa := Convert( slices, 379 );
            rec.wpba := Convert( slices, 380 );
            rec.wtclum1 := Convert( slices, 381 );
            rec.wtclum2 := Convert( slices, 382 );
            rec.wtclum3 := Convert( slices, 383 );
            rec.ystrtwk := Convert( slices, 384 );
            rec.month := Convert( slices, 385 );
            rec.able := Convert( slices, 386 );
            rec.actacci := Convert( slices, 387 );
            rec.addda := Convert( slices, 388 );
            rec.basacti := Convert( slices, 389 );
            rec.bntxcred := Convert( slices, 390 );
            rec.careab := Convert( slices, 391 );
            rec.careah := Convert( slices, 392 );
            rec.carecb := Convert( slices, 393 );
            rec.carech := Convert( slices, 394 );
            rec.carecl := Convert( slices, 395 );
            rec.carefl := Convert( slices, 396 );
            rec.carefr := Convert( slices, 397 );
            rec.careot := Convert( slices, 398 );
            rec.carere := Convert( slices, 399 );
            rec.curacti := Convert( slices, 400 );
            rec.empoccp := Convert( slices, 401 );
            rec.empstatb := Convert( slices, 402 );
            rec.empstatc := Convert( slices, 403 );
            rec.empstati := Convert( slices, 404 );
            rec.fsbndcti := Convert( slices, 405 );
            rec.fwmlkval := Convert( slices, 406 );
            rec.gebacti := Convert( slices, 407 );
            rec.giltcti := Convert( slices, 408 );
            rec.gross2 := Convert( slices, 409 );
            rec.gross3 := Convert( slices, 410 );
            rec.hbsupran := Convert( slices, 411 );
            rec.hdage := Convert( slices, 412 );
            rec.hdben := Convert( slices, 413 );
            rec.hdindinc := Convert( slices, 414 );
            rec.hourab := Convert( slices, 415 );
            rec.hourah := Convert( slices, 416 );
            rec.hourcare := Convert( slices, 417 );
            rec.hourcb := Convert( slices, 418 );
            rec.hourch := Convert( slices, 419 );
            rec.hourcl := Convert( slices, 420 );
            rec.hourfr := Convert( slices, 421 );
            rec.hourot := Convert( slices, 422 );
            rec.hourre := Convert( slices, 423 );
            rec.hourtot := Convert( slices, 424 );
            rec.hperson := Convert( slices, 425 );
            rec.iagegr2 := Convert( slices, 426 );
            rec.iagegrp := Convert( slices, 427 );
            rec.incseo2 := Convert( slices, 428 );
            rec.indinc := Convert( slices, 429 );
            rec.indisben := Convert( slices, 430 );
            rec.inearns := Convert( slices, 431 );
            rec.ininv := Convert( slices, 432 );
            rec.inirben := Convert( slices, 433 );
            rec.innirben := Convert( slices, 434 );
            rec.inothben := Convert( slices, 435 );
            rec.inpeninc := Convert( slices, 436 );
            rec.inrinc := Convert( slices, 437 );
            rec.inrpinc := Convert( slices, 438 );
            rec.intvlic := Convert( slices, 439 );
            rec.intxcred := Convert( slices, 440 );
            rec.isacti := Convert( slices, 441 );
            rec.marital := Convert( slices, 442 );
            rec.netocpen := Convert( slices, 443 );
            rec.nincseo2 := Convert( slices, 444 );
            rec.nindinc := Convert( slices, 445 );
            rec.ninearns := Convert( slices, 446 );
            rec.nininv := Convert( slices, 447 );
            rec.ninpenin := Convert( slices, 448 );
            rec.ninsein2 := Convert( slices, 449 );
            rec.nsbocti := Convert( slices, 450 );
            rec.occupnum := Convert( slices, 451 );
            rec.otbscti := Convert( slices, 452 );
            rec.pepscti := Convert( slices, 453 );
            rec.poaccti := Convert( slices, 454 );
            rec.prbocti := Convert( slices, 455 );
            rec.relhrp := Convert( slices, 456 );
            rec.sayecti := Convert( slices, 457 );
            rec.sclbcti := Convert( slices, 458 );
            rec.seincam2 := Convert( slices, 459 );
            rec.smpadj := Convert( slices, 460 );
            rec.sscti := Convert( slices, 461 );
            rec.sspadj := Convert( slices, 462 );
            rec.stshcti := Convert( slices, 463 );
            rec.superan := Convert( slices, 464 );
            rec.taxpayer := Convert( slices, 465 );
            rec.tesscti := Convert( slices, 466 );
            rec.totgrant := Convert( slices, 467 );
            rec.tothours := Convert( slices, 468 );
            rec.totoccp := Convert( slices, 469 );
            rec.ttwcosts := Convert( slices, 470 );
            rec.untrcti := Convert( slices, 471 );
            rec.uperson := Convert( slices, 472 );
            rec.widoccp := Convert( slices, 473 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0304;


   procedure Create_Asset_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0304;


   procedure Create_Benefit_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.notusamt := Convert( slices, 16 );
            rec.notuspd := Convert( slices, 17 );
            rec.numweeks := Convert( slices, 18 );
            rec.ordbkno := Convert( slices, 19 );
            rec.payslipb := Convert( slices, 20 );
            rec.pres := Convert( slices, 21 );
            rec.usual := Convert( slices, 22 );
            rec.var1 := Convert( slices, 23 );
            rec.var2 := Convert( slices, 24 );
            rec.var3 := Convert( slices, 25 );
            rec.whorec1 := Convert( slices, 26 );
            rec.whorec2 := Convert( slices, 27 );
            rec.whorec3 := Convert( slices, 28 );
            rec.whorec4 := Convert( slices, 29 );
            rec.whorec5 := Convert( slices, 30 );
            rec.month := Convert( slices, 31 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0304;


   procedure Create_Benunit_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.incchnge := Convert( slices, 3 );
            rec.inchilow := Convert( slices, 4 );
            rec.kidinc := Convert( slices, 5 );
            rec.nhhchild := Convert( slices, 6 );
            rec.totsav := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            rec.actaccb := Convert( slices, 9 );
            rec.adddabu := Convert( slices, 10 );
            rec.adultb := Convert( slices, 11 );
            rec.basactb := Convert( slices, 12 );
            rec.boarder := Convert( slices, 13 );
            rec.bpeninc := Convert( slices, 14 );
            rec.bseinc := Convert( slices, 15 );
            rec.buagegr2 := Convert( slices, 16 );
            rec.buagegrp := Convert( slices, 17 );
            rec.budisben := Convert( slices, 18 );
            rec.buearns := Convert( slices, 19 );
            rec.buethgr2 := Convert( slices, 20 );
            rec.buethgrp := Convert( slices, 21 );
            rec.buinc := Convert( slices, 22 );
            rec.buinv := Convert( slices, 23 );
            rec.buirben := Convert( slices, 24 );
            rec.bukids := Convert( slices, 25 );
            rec.bunirben := Convert( slices, 26 );
            rec.buothben := Convert( slices, 27 );
            rec.burent := Convert( slices, 28 );
            rec.burinc := Convert( slices, 29 );
            rec.burpinc := Convert( slices, 30 );
            rec.butvlic := Convert( slices, 31 );
            rec.butxcred := Convert( slices, 32 );
            rec.chddabu := Convert( slices, 33 );
            rec.curactb := Convert( slices, 34 );
            rec.depchldb := Convert( slices, 35 );
            rec.depdeds := Convert( slices, 36 );
            rec.disindhb := Convert( slices, 37 );
            rec.ecotypbu := Convert( slices, 38 );
            rec.ecstatbu := Convert( slices, 39 );
            rec.famthbai := Convert( slices, 40 );
            rec.famtypbs := Convert( slices, 41 );
            rec.famtypbu := Convert( slices, 42 );
            rec.famtype := Convert( slices, 43 );
            rec.fsbndctb := Convert( slices, 44 );
            rec.fsmbu := Convert( slices, 45 );
            rec.fsmlkbu := Convert( slices, 46 );
            rec.fwmlkbu := Convert( slices, 47 );
            rec.gebactb := Convert( slices, 48 );
            rec.giltctb := Convert( slices, 49 );
            rec.gross2 := Convert( slices, 50 );
            rec.gross3 := Convert( slices, 51 );
            rec.hbindbu := Convert( slices, 52 );
            rec.isactb := Convert( slices, 53 );
            rec.kid04 := Convert( slices, 54 );
            rec.kid1115 := Convert( slices, 55 );
            rec.kid1618 := Convert( slices, 56 );
            rec.kid510 := Convert( slices, 57 );
            rec.kidsbu0 := Convert( slices, 58 );
            rec.kidsbu1 := Convert( slices, 59 );
            rec.kidsbu10 := Convert( slices, 60 );
            rec.kidsbu11 := Convert( slices, 61 );
            rec.kidsbu12 := Convert( slices, 62 );
            rec.kidsbu13 := Convert( slices, 63 );
            rec.kidsbu14 := Convert( slices, 64 );
            rec.kidsbu15 := Convert( slices, 65 );
            rec.kidsbu16 := Convert( slices, 66 );
            rec.kidsbu17 := Convert( slices, 67 );
            rec.kidsbu18 := Convert( slices, 68 );
            rec.kidsbu2 := Convert( slices, 69 );
            rec.kidsbu3 := Convert( slices, 70 );
            rec.kidsbu4 := Convert( slices, 71 );
            rec.kidsbu5 := Convert( slices, 72 );
            rec.kidsbu6 := Convert( slices, 73 );
            rec.kidsbu7 := Convert( slices, 74 );
            rec.kidsbu8 := Convert( slices, 75 );
            rec.kidsbu9 := Convert( slices, 76 );
            rec.lastwork := Convert( slices, 77 );
            rec.lodger := Convert( slices, 78 );
            rec.nsboctb := Convert( slices, 79 );
            rec.otbsctb := Convert( slices, 80 );
            rec.pepsctb := Convert( slices, 81 );
            rec.poacctb := Convert( slices, 82 );
            rec.prboctb := Convert( slices, 83 );
            rec.sayectb := Convert( slices, 84 );
            rec.sclbctb := Convert( slices, 85 );
            rec.ssctb := Convert( slices, 86 );
            rec.stshctb := Convert( slices, 87 );
            rec.subltamt := Convert( slices, 88 );
            rec.tessctb := Convert( slices, 89 );
            rec.totcapbu := Convert( slices, 90 );
            rec.totsavbu := Convert( slices, 91 );
            rec.tuburent := Convert( slices, 92 );
            rec.untrctb := Convert( slices, 93 );
            rec.youngch := Convert( slices, 94 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0304;


   procedure Create_Care_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.wholoo01 := Convert( slices, 26 );
            rec.wholoo02 := Convert( slices, 27 );
            rec.wholoo03 := Convert( slices, 28 );
            rec.wholoo04 := Convert( slices, 29 );
            rec.wholoo05 := Convert( slices, 30 );
            rec.wholoo06 := Convert( slices, 31 );
            rec.wholoo07 := Convert( slices, 32 );
            rec.wholoo08 := Convert( slices, 33 );
            rec.wholoo09 := Convert( slices, 34 );
            rec.wholoo10 := Convert( slices, 35 );
            rec.wholoo11 := Convert( slices, 36 );
            rec.wholoo12 := Convert( slices, 37 );
            rec.wholoo13 := Convert( slices, 38 );
            rec.wholoo14 := Convert( slices, 39 );
            rec.wholoo15 := Convert( slices, 40 );
            rec.wholoo16 := Convert( slices, 41 );
            rec.wholoo17 := Convert( slices, 42 );
            rec.wholoo18 := Convert( slices, 43 );
            rec.wholoo19 := Convert( slices, 44 );
            rec.wholoo20 := Convert( slices, 45 );
            rec.month := Convert( slices, 46 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0304;


   procedure Create_Child_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.benccdis := Convert( slices, 6 );
            rec.care := Convert( slices, 7 );
            rec.cdisdif1 := Convert( slices, 8 );
            rec.cdisdif2 := Convert( slices, 9 );
            rec.cdisdif3 := Convert( slices, 10 );
            rec.cdisdif4 := Convert( slices, 11 );
            rec.cdisdif5 := Convert( slices, 12 );
            rec.cdisdif6 := Convert( slices, 13 );
            rec.cdisdif7 := Convert( slices, 14 );
            rec.cdisdif8 := Convert( slices, 15 );
            rec.chamt1 := Convert( slices, 16 );
            rec.chamt2 := Convert( slices, 17 );
            rec.chamt3 := Convert( slices, 18 );
            rec.chamt4 := Convert( slices, 19 );
            rec.chamtern := Convert( slices, 20 );
            rec.chamttst := Convert( slices, 21 );
            rec.chdla1 := Convert( slices, 22 );
            rec.chdla2 := Convert( slices, 23 );
            rec.chealth := Convert( slices, 24 );
            rec.chearns1 := Convert( slices, 25 );
            rec.chearns2 := Convert( slices, 26 );
            rec.chema := Convert( slices, 27 );
            rec.chemaamt := Convert( slices, 28 );
            rec.chemapd := Convert( slices, 29 );
            rec.chfar := Convert( slices, 30 );
            rec.chhr1 := Convert( slices, 31 );
            rec.chhr2 := Convert( slices, 32 );
            rec.chlook01 := Convert( slices, 33 );
            rec.chlook02 := Convert( slices, 34 );
            rec.chlook03 := Convert( slices, 35 );
            rec.chlook04 := Convert( slices, 36 );
            rec.chlook05 := Convert( slices, 37 );
            rec.chlook06 := Convert( slices, 38 );
            rec.chlook07 := Convert( slices, 39 );
            rec.chlook08 := Convert( slices, 40 );
            rec.chlook09 := Convert( slices, 41 );
            rec.chlook10 := Convert( slices, 42 );
            rec.chpay1 := Convert( slices, 43 );
            rec.chpay2 := Convert( slices, 44 );
            rec.chpay3 := Convert( slices, 45 );
            rec.chpdern := Convert( slices, 46 );
            rec.chpdtst := Convert( slices, 47 );
            rec.chprob := Convert( slices, 48 );
            rec.chsave := Convert( slices, 49 );
            rec.chwkern := Convert( slices, 50 );
            rec.chwktst := Convert( slices, 51 );
            rec.chyrern := Convert( slices, 52 );
            rec.chyrtst := Convert( slices, 53 );
            rec.clone := Convert( slices, 54 );
            rec.cohabit := Convert( slices, 55 );
            rec.convbl := Convert( slices, 56 );
            rec.cost := Convert( slices, 57 );
            rec.cvht := Convert( slices, 58 );
            rec.cvpay := Convert( slices, 59 );
            rec.cvpd := Convert( slices, 60 );
            rec.dentist := Convert( slices, 61 );
            rec.depend := Convert( slices, 62 );
            rec.dob := Convert( slices, 63 );
            rec.eligadlt := Convert( slices, 64 );
            rec.eligchld := Convert( slices, 65 );
            rec.endyr := Convert( slices, 66 );
            rec.eyetest := Convert( slices, 67 );
            rec.fted := Convert( slices, 68 );
            rec.grant := Convert( slices, 69 );
            rec.grtamt1 := Convert( slices, 70 );
            rec.grtamt2 := Convert( slices, 71 );
            rec.grtdir1 := Convert( slices, 72 );
            rec.grtdir2 := Convert( slices, 73 );
            rec.grtnum := Convert( slices, 74 );
            rec.grtsce1 := Convert( slices, 75 );
            rec.grtsce2 := Convert( slices, 76 );
            rec.grtval1 := Convert( slices, 77 );
            rec.grtval2 := Convert( slices, 78 );
            rec.hholder := Convert( slices, 79 );
            rec.hosp := Convert( slices, 80 );
            rec.lareg := Convert( slices, 81 );
            rec.legdep := Convert( slices, 82 );
            rec.ms := Convert( slices, 83 );
            rec.nhs1 := Convert( slices, 84 );
            rec.nhs2 := Convert( slices, 85 );
            rec.nhs3 := Convert( slices, 86 );
            rec.parent1 := Convert( slices, 87 );
            rec.parent2 := Convert( slices, 88 );
            rec.prit := Convert( slices, 89 );
            rec.prscrpt := Convert( slices, 90 );
            rec.r01 := Convert( slices, 91 );
            rec.r02 := Convert( slices, 92 );
            rec.r03 := Convert( slices, 93 );
            rec.r04 := Convert( slices, 94 );
            rec.r05 := Convert( slices, 95 );
            rec.r06 := Convert( slices, 96 );
            rec.r07 := Convert( slices, 97 );
            rec.r08 := Convert( slices, 98 );
            rec.r09 := Convert( slices, 99 );
            rec.r10 := Convert( slices, 100 );
            rec.r11 := Convert( slices, 101 );
            rec.r12 := Convert( slices, 102 );
            rec.r13 := Convert( slices, 103 );
            rec.r14 := Convert( slices, 104 );
            rec.registr1 := Convert( slices, 105 );
            rec.registr2 := Convert( slices, 106 );
            rec.registr3 := Convert( slices, 107 );
            rec.registr4 := Convert( slices, 108 );
            rec.registr5 := Convert( slices, 109 );
            rec.sex := Convert( slices, 110 );
            rec.smkit := Convert( slices, 111 );
            rec.smlit := Convert( slices, 112 );
            rec.spcreg1 := Convert( slices, 113 );
            rec.spcreg2 := Convert( slices, 114 );
            rec.spcreg3 := Convert( slices, 115 );
            rec.specs := Convert( slices, 116 );
            rec.spout := Convert( slices, 117 );
            rec.srentamt := Convert( slices, 118 );
            rec.srentpd := Convert( slices, 119 );
            rec.startyr := Convert( slices, 120 );
            rec.totsave := Convert( slices, 121 );
            rec.trav := Convert( slices, 122 );
            rec.typeed := Convert( slices, 123 );
            rec.voucher := Convert( slices, 124 );
            rec.whytrav1 := Convert( slices, 125 );
            rec.whytrav2 := Convert( slices, 126 );
            rec.whytrav3 := Convert( slices, 127 );
            rec.whytrav4 := Convert( slices, 128 );
            rec.whytrav5 := Convert( slices, 129 );
            rec.whytrav6 := Convert( slices, 130 );
            rec.wmkit := Convert( slices, 131 );
            rec.month := Convert( slices, 132 );
            rec.careab := Convert( slices, 133 );
            rec.careah := Convert( slices, 134 );
            rec.carecb := Convert( slices, 135 );
            rec.carech := Convert( slices, 136 );
            rec.carecl := Convert( slices, 137 );
            rec.carefl := Convert( slices, 138 );
            rec.carefr := Convert( slices, 139 );
            rec.careot := Convert( slices, 140 );
            rec.carere := Convert( slices, 141 );
            rec.chdda := Convert( slices, 142 );
            rec.chearns := Convert( slices, 143 );
            rec.chincdv := Convert( slices, 144 );
            rec.chrinc := Convert( slices, 145 );
            rec.fsmlkval := Convert( slices, 146 );
            rec.fsmval := Convert( slices, 147 );
            rec.fwmlkval := Convert( slices, 148 );
            rec.hdagech := Convert( slices, 149 );
            rec.hourab := Convert( slices, 150 );
            rec.hourah := Convert( slices, 151 );
            rec.hourcb := Convert( slices, 152 );
            rec.hourch := Convert( slices, 153 );
            rec.hourcl := Convert( slices, 154 );
            rec.hourfr := Convert( slices, 155 );
            rec.hourot := Convert( slices, 156 );
            rec.hourre := Convert( slices, 157 );
            rec.hourtot := Convert( slices, 158 );
            rec.hperson := Convert( slices, 159 );
            rec.iagegr2 := Convert( slices, 160 );
            rec.iagegrp := Convert( slices, 161 );
            rec.relhrp := Convert( slices, 162 );
            rec.totgntch := Convert( slices, 163 );
            rec.uperson := Convert( slices, 164 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0304;


   procedure Create_Endowment_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.menpolam := Convert( slices, 5 );
            rec.menpolpd := Convert( slices, 6 );
            rec.menstyr := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0304;


   procedure Create_ExtChild_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.nhhamt := Convert( slices, 4 );
            rec.nhhfee := Convert( slices, 5 );
            rec.nhhintro := Convert( slices, 6 );
            rec.nhhpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0304;


   procedure Create_GovPay_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.month := Convert( slices, 6 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0304;


   procedure Create_Hbai_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcstm := Convert( slices, 17 );
            rec.snphcsto := Convert( slices, 18 );
            rec.sphcstm := Convert( slices, 19 );
            rec.sphcsto := Convert( slices, 20 );
            rec.sernum := Convert( slices, 21 );
            rec.benunits := Convert( slices, 22 );
            rec.gvtregn := Convert( slices, 23 );
            rec.hhstat := Convert( slices, 24 );
            rec.tenure := Convert( slices, 25 );
            rec.adulth := Convert( slices, 26 );
            rec.depchldh := Convert( slices, 27 );
            rec.tentyp2 := Convert( slices, 28 );
            rec.watsewrt := Convert( slices, 29 );
            rec.sewerage := Convert( slices, 30 );
            rec.cwathh := Convert( slices, 31 );
            rec.totsthh := Convert( slices, 32 );
            rec.totstrhh := Convert( slices, 33 );
            rec.charghh := Convert( slices, 34 );
            rec.hbmort := Convert( slices, 35 );
            rec.hbxmort := Convert( slices, 36 );
            rec.hrenthh := Convert( slices, 37 );
            rec.erenthh := Convert( slices, 38 );
            rec.hbenhh := Convert( slices, 39 );
            rec.watsewhh := Convert( slices, 40 );
            rec.hhcost := Convert( slices, 41 );
            rec.ehcost := Convert( slices, 42 );
            rec.bhcdef := Convert( slices, 43 );
            rec.ahcdef := Convert( slices, 44 );
            rec.ctliab := Convert( slices, 45 );
            rec.ctrebam1 := Convert( slices, 46 );
            rec.adultb := Convert( slices, 47 );
            rec.egrincbu := Convert( slices, 48 );
            rec.entinmbu := Convert( slices, 49 );
            rec.entinobu := Convert( slices, 50 );
            rec.hgrernhh := Convert( slices, 51 );
            rec.hnternhh := Convert( slices, 52 );
            rec.hgrinvhh := Convert( slices, 53 );
            rec.hntinvhh := Convert( slices, 54 );
            rec.hgrocchh := Convert( slices, 55 );
            rec.hntocchh := Convert( slices, 56 );
            rec.hbeninhh := Convert( slices, 57 );
            rec.hpribnhh := Convert( slices, 58 );
            rec.hmiscihh := Convert( slices, 59 );
            rec.sfrpahh := Convert( slices, 60 );
            rec.hgrinchh := Convert( slices, 61 );
            rec.hntinchh := Convert( slices, 62 );
            rec.inchilhh := Convert( slices, 63 );
            rec.shtseflg := Convert( slices, 64 );
            rec.sehhflg := Convert( slices, 65 );
            rec.ethgrphh := Convert( slices, 66 );
            rec.egrernhh := Convert( slices, 67 );
            rec.enternhh := Convert( slices, 68 );
            rec.ebeninhh := Convert( slices, 69 );
            rec.epribnhh := Convert( slices, 70 );
            rec.emiscihh := Convert( slices, 71 );
            rec.eothdmhh := Convert( slices, 72 );
            rec.eothdohh := Convert( slices, 73 );
            rec.egrinchh := Convert( slices, 74 );
            rec.entinmhh := Convert( slices, 75 );
            rec.entinohh := Convert( slices, 76 );
            rec.tvlichh := Convert( slices, 77 );
            rec.g_newhh := Convert( slices, 78 );
            rec.gnewhhp := Convert( slices, 79 );
            rec.esgjobhh := Convert( slices, 80 );
            rec.esgrsehh := Convert( slices, 81 );
            rec.esginvhh := Convert( slices, 82 );
            rec.esgocchh := Convert( slices, 83 );
            rec.esmischh := Convert( slices, 84 );
            rec.espribhh := Convert( slices, 85 );
            rec.esbenihh := Convert( slices, 86 );
            rec.esothmhh := Convert( slices, 87 );
            rec.esothohh := Convert( slices, 88 );
            rec.esginchh := Convert( slices, 89 );
            rec.esninmhh := Convert( slices, 90 );
            rec.esninohh := Convert( slices, 91 );
            rec.eripmhh := Convert( slices, 92 );
            rec.eripohh := Convert( slices, 93 );
            rec.erinpmhh := Convert( slices, 94 );
            rec.erinpohh := Convert( slices, 95 );
            rec.gs_newhh := Convert( slices, 96 );
            rec.es_hcstm := Convert( slices, 97 );
            rec.es_hcsto := Convert( slices, 98 );
            rec.esahcmhh := Convert( slices, 99 );
            rec.esahcohh := Convert( slices, 100 );
            rec.eahcmhh := Convert( slices, 101 );
            rec.eahcohh := Convert( slices, 102 );
            rec.benunit := Convert( slices, 103 );
            rec.depchldb := Convert( slices, 104 );
            rec.eqmcoup := Convert( slices, 105 );
            rec.eqmbhckd := Convert( slices, 106 );
            rec.eqmahckd := Convert( slices, 107 );
            rec.eqmbhchh := Convert( slices, 108 );
            rec.eqmahchh := Convert( slices, 109 );
            rec.over14 := Convert( slices, 110 );
            rec.under14 := Convert( slices, 111 );
            rec.eqobhchh := Convert( slices, 112 );
            rec.eqoahchh := Convert( slices, 113 );
            rec.mc_bhc := Convert( slices, 114 );
            rec.oe_bhc := Convert( slices, 115 );
            rec.mc_gro := Convert( slices, 116 );
            rec.oe_gro := Convert( slices, 117 );
            rec.mc_ahc := Convert( slices, 118 );
            rec.oe_ahc := Convert( slices, 119 );
            rec.s_mc_bhc := Convert( slices, 120 );
            rec.s_oe_bhc := Convert( slices, 121 );
            rec.s_mc_gro := Convert( slices, 122 );
            rec.s_oe_gro := Convert( slices, 123 );
            rec.s_mc_ahc := Convert( slices, 124 );
            rec.s_oe_ahc := Convert( slices, 125 );
            rec.famthbai := Convert( slices, 126 );
            rec.fsmlkbu := Convert( slices, 127 );
            rec.fwmlkbu := Convert( slices, 128 );
            rec.kidsbu0 := Convert( slices, 129 );
            rec.kidsbu1 := Convert( slices, 130 );
            rec.kidsbu10 := Convert( slices, 131 );
            rec.kidsbu11 := Convert( slices, 132 );
            rec.kidsbu12 := Convert( slices, 133 );
            rec.kidsbu13 := Convert( slices, 134 );
            rec.kidsbu14 := Convert( slices, 135 );
            rec.kidsbu15 := Convert( slices, 136 );
            rec.kidsbu16 := Convert( slices, 137 );
            rec.kidsbu17 := Convert( slices, 138 );
            rec.kidsbu18 := Convert( slices, 139 );
            rec.kidsbu2 := Convert( slices, 140 );
            rec.kidsbu3 := Convert( slices, 141 );
            rec.kidsbu4 := Convert( slices, 142 );
            rec.kidsbu5 := Convert( slices, 143 );
            rec.kidsbu6 := Convert( slices, 144 );
            rec.kidsbu7 := Convert( slices, 145 );
            rec.kidsbu8 := Convert( slices, 146 );
            rec.kidsbu9 := Convert( slices, 147 );
            rec.fsmbu := Convert( slices, 148 );
            rec.hbenbu := Convert( slices, 149 );
            rec.ehbenbu := Convert( slices, 150 );
            rec.srentbu := Convert( slices, 151 );
            rec.rentbu := Convert( slices, 152 );
            rec.erentbu := Convert( slices, 153 );
            rec.insebu := Convert( slices, 154 );
            rec.ginsebu := Convert( slices, 155 );
            rec.hgrernbu := Convert( slices, 156 );
            rec.hnternbu := Convert( slices, 157 );
            rec.hgrinvbu := Convert( slices, 158 );
            rec.hntinvbu := Convert( slices, 159 );
            rec.hgroccbu := Convert( slices, 160 );
            rec.hntoccbu := Convert( slices, 161 );
            rec.hbeninbu := Convert( slices, 162 );
            rec.hpribnbu := Convert( slices, 163 );
            rec.hmiscibu := Convert( slices, 164 );
            rec.sfrpabu := Convert( slices, 165 );
            rec.hgrincbu := Convert( slices, 166 );
            rec.hntincbu := Convert( slices, 167 );
            rec.egrernbu := Convert( slices, 168 );
            rec.enternbu := Convert( slices, 169 );
            rec.ebeninbu := Convert( slices, 170 );
            rec.epribnbu := Convert( slices, 171 );
            rec.emiscibu := Convert( slices, 172 );
            rec.eothdmbu := Convert( slices, 173 );
            rec.eothdobu := Convert( slices, 174 );
            rec.winpaybu := Convert( slices, 175 );
            rec.tvlicbu := Convert( slices, 176 );
            rec.ecobu := Convert( slices, 177 );
            rec.disabflg := Convert( slices, 178 );
            rec.fambu := Convert( slices, 179 );
            rec.newfambu := Convert( slices, 180 );
            rec.kidecobu := Convert( slices, 181 );
            rec.kid0_1 := Convert( slices, 182 );
            rec.kid2_4 := Convert( slices, 183 );
            rec.kid5_7 := Convert( slices, 184 );
            rec.kid8_10 := Convert( slices, 185 );
            rec.kid11_12 := Convert( slices, 186 );
            rec.kid13_15 := Convert( slices, 187 );
            rec.kid16_18 := Convert( slices, 188 );
            rec.boys := Convert( slices, 189 );
            rec.wftcbu := Convert( slices, 190 );
            rec.dptcbu := Convert( slices, 191 );
            rec.wtcbu := Convert( slices, 192 );
            rec.ctcbu := Convert( slices, 193 );
            rec.isbu := Convert( slices, 194 );
            rec.inchilbu := Convert( slices, 195 );
            rec.g_newbu := Convert( slices, 196 );
            rec.g_newpp := Convert( slices, 197 );
            rec.g_newch := Convert( slices, 198 );
            rec.g_newad := Convert( slices, 199 );
            rec.g_newpn := Convert( slices, 200 );
            rec.g_newwa := Convert( slices, 201 );
            rec.esgjobbu := Convert( slices, 202 );
            rec.esgrsebu := Convert( slices, 203 );
            rec.esginvbu := Convert( slices, 204 );
            rec.esgoccbu := Convert( slices, 205 );
            rec.esmiscbu := Convert( slices, 206 );
            rec.espribbu := Convert( slices, 207 );
            rec.esbenibu := Convert( slices, 208 );
            rec.esothmbu := Convert( slices, 209 );
            rec.esothobu := Convert( slices, 210 );
            rec.esgincbu := Convert( slices, 211 );
            rec.esninmbu := Convert( slices, 212 );
            rec.esninobu := Convert( slices, 213 );
            rec.eripmbu := Convert( slices, 214 );
            rec.eripobu := Convert( slices, 215 );
            rec.erinpmbu := Convert( slices, 216 );
            rec.erinpobu := Convert( slices, 217 );
            rec.gs_newbu := Convert( slices, 218 );
            rec.gs_newpp := Convert( slices, 219 );
            rec.gs_newch := Convert( slices, 220 );
            rec.gs_newad := Convert( slices, 221 );
            rec.gs_newpn := Convert( slices, 222 );
            rec.gs_newwa := Convert( slices, 223 );
            rec.mbhcdec := Convert( slices, 224 );
            rec.mqinbhc := Convert( slices, 225 );
            rec.obhcdec := Convert( slices, 226 );
            rec.oqinbhc := Convert( slices, 227 );
            rec.mahcdec := Convert( slices, 228 );
            rec.mqinahc := Convert( slices, 229 );
            rec.oahcdec := Convert( slices, 230 );
            rec.oqinahc := Convert( slices, 231 );
            rec.mbhcdecx := Convert( slices, 232 );
            rec.mqinbhcx := Convert( slices, 233 );
            rec.obhcdecx := Convert( slices, 234 );
            rec.oqinbhcx := Convert( slices, 235 );
            rec.mahcdecx := Convert( slices, 236 );
            rec.mqinahcx := Convert( slices, 237 );
            rec.oahcdecx := Convert( slices, 238 );
            rec.oqinahcx := Convert( slices, 239 );
            rec.agehd := Convert( slices, 240 );
            rec.sexhd := Convert( slices, 241 );
            rec.agesp := Convert( slices, 242 );
            rec.sexsp := Convert( slices, 243 );
            rec.ptentyp2 := Convert( slices, 244 );
            rec.lowoebhc := Convert( slices, 245 );
            rec.lowoeahc := Convert( slices, 246 );
            rec.lowmcbhc := Convert( slices, 247 );
            rec.lowmcahc := Convert( slices, 248 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0304;


   procedure Create_Household_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.acorn := Convert( slices, 2 );
            rec.bedroom := Convert( slices, 3 );
            rec.benunits := Convert( slices, 4 );
            rec.billrate := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.centfuel := Convert( slices, 7 );
            rec.centheat := Convert( slices, 8 );
            rec.charge1 := Convert( slices, 9 );
            rec.charge2 := Convert( slices, 10 );
            rec.charge3 := Convert( slices, 11 );
            rec.charge4 := Convert( slices, 12 );
            rec.charge5 := Convert( slices, 13 );
            rec.charge6 := Convert( slices, 14 );
            rec.charge7 := Convert( slices, 15 );
            rec.charge8 := Convert( slices, 16 );
            rec.charge9 := Convert( slices, 17 );
            rec.chins := Convert( slices, 18 );
            rec.chrgamt1 := Convert( slices, 19 );
            rec.chrgamt2 := Convert( slices, 20 );
            rec.chrgamt3 := Convert( slices, 21 );
            rec.chrgamt4 := Convert( slices, 22 );
            rec.chrgamt5 := Convert( slices, 23 );
            rec.chrgamt6 := Convert( slices, 24 );
            rec.chrgamt7 := Convert( slices, 25 );
            rec.chrgamt8 := Convert( slices, 26 );
            rec.chrgamt9 := Convert( slices, 27 );
            rec.chrgpd1 := Convert( slices, 28 );
            rec.chrgpd2 := Convert( slices, 29 );
            rec.chrgpd3 := Convert( slices, 30 );
            rec.chrgpd4 := Convert( slices, 31 );
            rec.chrgpd5 := Convert( slices, 32 );
            rec.chrgpd6 := Convert( slices, 33 );
            rec.chrgpd7 := Convert( slices, 34 );
            rec.chrgpd8 := Convert( slices, 35 );
            rec.chrgpd9 := Convert( slices, 36 );
            rec.contv1 := Convert( slices, 37 );
            rec.contv2 := Convert( slices, 38 );
            rec.covoths := Convert( slices, 39 );
            rec.csewamt := Convert( slices, 40 );
            rec.csewamt1 := Convert( slices, 41 );
            rec.ct25d50d := Convert( slices, 42 );
            rec.ctamt := Convert( slices, 43 );
            rec.ctannual := Convert( slices, 44 );
            rec.ctband := Convert( slices, 45 );
            rec.ctbwait := Convert( slices, 46 );
            rec.ctcondoc := Convert( slices, 47 );
            rec.ctdisc := Convert( slices, 48 );
            rec.ctinstal := Convert( slices, 49 );
            rec.ctlvband := Convert( slices, 50 );
            rec.ctlvchk := Convert( slices, 51 );
            rec.ctreb := Convert( slices, 52 );
            rec.ctrebamt := Convert( slices, 53 );
            rec.ctrebpd := Convert( slices, 54 );
            rec.cttime := Convert( slices, 55 );
            rec.cwatamt := Convert( slices, 56 );
            rec.cwatamt1 := Convert( slices, 57 );
            rec.datyrago := Convert( slices, 58 );
            rec.entry1 := Convert( slices, 59 );
            rec.entry2 := Convert( slices, 60 );
            rec.entry3 := Convert( slices, 61 );
            rec.entry4 := Convert( slices, 62 );
            rec.estrtann := Convert( slices, 63 );
            rec.floor := Convert( slices, 64 );
            rec.givehelp := Convert( slices, 65 );
            rec.gor := Convert( slices, 66 );
            rec.gvtregn := Convert( slices, 67 );
            rec.hhldr01 := Convert( slices, 68 );
            rec.hhldr02 := Convert( slices, 69 );
            rec.hhldr03 := Convert( slices, 70 );
            rec.hhldr04 := Convert( slices, 71 );
            rec.hhldr05 := Convert( slices, 72 );
            rec.hhldr06 := Convert( slices, 73 );
            rec.hhldr07 := Convert( slices, 74 );
            rec.hhldr08 := Convert( slices, 75 );
            rec.hhldr09 := Convert( slices, 76 );
            rec.hhldr10 := Convert( slices, 77 );
            rec.hhldr11 := Convert( slices, 78 );
            rec.hhldr12 := Convert( slices, 79 );
            rec.hhldr13 := Convert( slices, 80 );
            rec.hhldr14 := Convert( slices, 81 );
            rec.hhldr97 := Convert( slices, 82 );
            rec.hhstat := Convert( slices, 83 );
            rec.hrpnum := Convert( slices, 84 );
            rec.intdate := Convert( slices, 85 );
            rec.lac := Convert( slices, 86 );
            rec.mainacc := Convert( slices, 87 );
            rec.mnthcode := Convert( slices, 88 );
            rec.modcon01 := Convert( slices, 89 );
            rec.modcon02 := Convert( slices, 90 );
            rec.modcon03 := Convert( slices, 91 );
            rec.modcon04 := Convert( slices, 92 );
            rec.modcon05 := Convert( slices, 93 );
            rec.modcon06 := Convert( slices, 94 );
            rec.modcon07 := Convert( slices, 95 );
            rec.modcon08 := Convert( slices, 96 );
            rec.modcon09 := Convert( slices, 97 );
            rec.modcon10 := Convert( slices, 98 );
            rec.modcon11 := Convert( slices, 99 );
            rec.modcon12 := Convert( slices, 100 );
            rec.modcon13 := Convert( slices, 101 );
            rec.modcon14 := Convert( slices, 102 );
            rec.monlive := Convert( slices, 103 );
            rec.needhelp := Convert( slices, 104 );
            rec.nicoun := Convert( slices, 105 );
            rec.ninrv := Convert( slices, 106 );
            rec.nirate := Convert( slices, 107 );
            rec.norate := Convert( slices, 108 );
            rec.onbsroom := Convert( slices, 109 );
            rec.orgsewam := Convert( slices, 110 );
            rec.orgwatam := Convert( slices, 111 );
            rec.payrate := Convert( slices, 112 );
            rec.premium := Convert( slices, 113 );
            rec.ptbsroom := Convert( slices, 114 );
            rec.rooms := Convert( slices, 115 );
            rec.roomshar := Convert( slices, 116 );
            rec.rtannual := Convert( slices, 117 );
            rec.rtcheck := Convert( slices, 118 );
            rec.rtcondoc := Convert( slices, 119 );
            rec.rtdeduc := Convert( slices, 120 );
            rec.rtinstal := Convert( slices, 121 );
            rec.rtreb := Convert( slices, 122 );
            rec.rtrebamt := Convert( slices, 123 );
            rec.rtrebpd := Convert( slices, 124 );
            rec.rttime := Convert( slices, 125 );
            rec.sampqtr := Convert( slices, 126 );
            rec.schmeal := Convert( slices, 127 );
            rec.schmilk := Convert( slices, 128 );
            rec.sewamt := Convert( slices, 129 );
            rec.sewanul := Convert( slices, 130 );
            rec.sewerpay := Convert( slices, 131 );
            rec.sewsep := Convert( slices, 132 );
            rec.sewtime := Convert( slices, 133 );
            rec.shelter := Convert( slices, 134 );
            rec.sobuy := Convert( slices, 135 );
            rec.sstrtreg := Convert( slices, 136 );
            rec.stramt1 := Convert( slices, 137 );
            rec.stramt2 := Convert( slices, 138 );
            rec.strcov := Convert( slices, 139 );
            rec.strmort := Convert( slices, 140 );
            rec.stroths := Convert( slices, 141 );
            rec.strpd1 := Convert( slices, 142 );
            rec.strpd2 := Convert( slices, 143 );
            rec.suballow := Convert( slices, 144 );
            rec.sublet := Convert( slices, 145 );
            rec.sublety := Convert( slices, 146 );
            rec.subrent := Convert( slices, 147 );
            rec.tenure := Convert( slices, 148 );
            rec.totadult := Convert( slices, 149 );
            rec.totchild := Convert( slices, 150 );
            rec.totdepdk := Convert( slices, 151 );
            rec.tvlic := Convert( slices, 152 );
            rec.typeacc := Convert( slices, 153 );
            rec.usevcl := Convert( slices, 154 );
            rec.watamt := Convert( slices, 155 );
            rec.watanul := Convert( slices, 156 );
            rec.watermet := Convert( slices, 157 );
            rec.waterpay := Convert( slices, 158 );
            rec.watrb := Convert( slices, 159 );
            rec.wattime := Convert( slices, 160 );
            rec.welfmilk := Convert( slices, 161 );
            rec.whoctb01 := Convert( slices, 162 );
            rec.whoctb02 := Convert( slices, 163 );
            rec.whoctb03 := Convert( slices, 164 );
            rec.whoctb04 := Convert( slices, 165 );
            rec.whoctb05 := Convert( slices, 166 );
            rec.whoctb06 := Convert( slices, 167 );
            rec.whoctb07 := Convert( slices, 168 );
            rec.whoctb08 := Convert( slices, 169 );
            rec.whoctb09 := Convert( slices, 170 );
            rec.whoctb10 := Convert( slices, 171 );
            rec.whoctb11 := Convert( slices, 172 );
            rec.whoctb12 := Convert( slices, 173 );
            rec.whoctb13 := Convert( slices, 174 );
            rec.whoctb14 := Convert( slices, 175 );
            rec.whoctbns := Convert( slices, 176 );
            rec.whoctbot := Convert( slices, 177 );
            rec.whorsp01 := Convert( slices, 178 );
            rec.whorsp02 := Convert( slices, 179 );
            rec.whorsp03 := Convert( slices, 180 );
            rec.whorsp04 := Convert( slices, 181 );
            rec.whorsp05 := Convert( slices, 182 );
            rec.whorsp06 := Convert( slices, 183 );
            rec.whorsp07 := Convert( slices, 184 );
            rec.whorsp08 := Convert( slices, 185 );
            rec.whorsp09 := Convert( slices, 186 );
            rec.whorsp10 := Convert( slices, 187 );
            rec.whorsp11 := Convert( slices, 188 );
            rec.whorsp12 := Convert( slices, 189 );
            rec.whorsp13 := Convert( slices, 190 );
            rec.whorsp14 := Convert( slices, 191 );
            rec.whynoct := Convert( slices, 192 );
            rec.wmintro := Convert( slices, 193 );
            rec.wsewamt := Convert( slices, 194 );
            rec.wsewanul := Convert( slices, 195 );
            rec.wsewtime := Convert( slices, 196 );
            rec.yearcode := Convert( slices, 197 );
            rec.yearlive := Convert( slices, 198 );
            rec.month := Convert( slices, 199 );
            rec.actacch := Convert( slices, 200 );
            rec.adddahh := Convert( slices, 201 );
            rec.adulth := Convert( slices, 202 );
            rec.basacth := Convert( slices, 203 );
            rec.chddahh := Convert( slices, 204 );
            rec.curacth := Convert( slices, 205 );
            rec.cwatamtd := Convert( slices, 206 );
            rec.depchldh := Convert( slices, 207 );
            rec.emp := Convert( slices, 208 );
            rec.emphrp := Convert( slices, 209 );
            rec.endowpay := Convert( slices, 210 );
            rec.equivahc := Convert( slices, 211 );
            rec.equivbhc := Convert( slices, 212 );
            rec.fsbndcth := Convert( slices, 213 );
            rec.gbhscost := Convert( slices, 214 );
            rec.gebacth := Convert( slices, 215 );
            rec.giltcth := Convert( slices, 216 );
            rec.gross2 := Convert( slices, 217 );
            rec.gross3 := Convert( slices, 218 );
            rec.grossct := Convert( slices, 219 );
            rec.hbeninc := Convert( slices, 220 );
            rec.hbindhh := Convert( slices, 221 );
            rec.hcband := Convert( slices, 222 );
            rec.hdhhinc := Convert( slices, 223 );
            rec.hdtax := Convert( slices, 224 );
            rec.hearns := Convert( slices, 225 );
            rec.hhagegr2 := Convert( slices, 226 );
            rec.hhagegrp := Convert( slices, 227 );
            rec.hhcomp := Convert( slices, 228 );
            rec.hhcomps := Convert( slices, 229 );
            rec.hhdisben := Convert( slices, 230 );
            rec.hhethgr2 := Convert( slices, 231 );
            rec.hhethgrp := Convert( slices, 232 );
            rec.hhinc := Convert( slices, 233 );
            rec.hhincbnd := Convert( slices, 234 );
            rec.hhinv := Convert( slices, 235 );
            rec.hhirben := Convert( slices, 236 );
            rec.hhkids := Convert( slices, 237 );
            rec.hhnirben := Convert( slices, 238 );
            rec.hhothben := Convert( slices, 239 );
            rec.hhrent := Convert( slices, 240 );
            rec.hhrinc := Convert( slices, 241 );
            rec.hhrpinc := Convert( slices, 242 );
            rec.hhsize := Convert( slices, 243 );
            rec.hhtvlic := Convert( slices, 244 );
            rec.hhtxcred := Convert( slices, 245 );
            rec.hothinc := Convert( slices, 246 );
            rec.hpeninc := Convert( slices, 247 );
            rec.hrband := Convert( slices, 248 );
            rec.hseinc := Convert( slices, 249 );
            rec.isacth := Convert( slices, 250 );
            rec.london := Convert( slices, 251 );
            rec.mortcost := Convert( slices, 252 );
            rec.mortint := Convert( slices, 253 );
            rec.mortpay := Convert( slices, 254 );
            rec.nddctb := Convert( slices, 255 );
            rec.nddishc := Convert( slices, 256 );
            rec.nihscost := Convert( slices, 257 );
            rec.nsbocth := Convert( slices, 258 );
            rec.otbscth := Convert( slices, 259 );
            rec.pacctype := Convert( slices, 260 );
            rec.penage := Convert( slices, 261 );
            rec.penhrp := Convert( slices, 262 );
            rec.pepscth := Convert( slices, 263 );
            rec.poaccth := Convert( slices, 264 );
            rec.prbocth := Convert( slices, 265 );
            rec.ptentyp2 := Convert( slices, 266 );
            rec.sayecth := Convert( slices, 267 );
            rec.sclbcth := Convert( slices, 268 );
            rec.servpay := Convert( slices, 269 );
            rec.sick := Convert( slices, 270 );
            rec.sickhrp := Convert( slices, 271 );
            rec.sscth := Convert( slices, 272 );
            rec.struins := Convert( slices, 273 );
            rec.stshcth := Convert( slices, 274 );
            rec.tentyp2 := Convert( slices, 275 );
            rec.tesscth := Convert( slices, 276 );
            rec.tuhhrent := Convert( slices, 277 );
            rec.tuwatsew := Convert( slices, 278 );
            rec.untrcth := Convert( slices, 279 );
            rec.watsewrt := Convert( slices, 280 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0304;


   procedure Create_Insurance_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Insurance_IO.File_Type;
      rec         : Insurance_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Insurance_IO.Create (bin_file, Insurance_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.insseq := Convert( slices, 2 );
            rec.numpols1 := Convert( slices, 3 );
            rec.numpols2 := Convert( slices, 4 );
            rec.numpols3 := Convert( slices, 5 );
            rec.numpols4 := Convert( slices, 6 );
            rec.numpols5 := Convert( slices, 7 );
            rec.numpols6 := Convert( slices, 8 );
            rec.numpols7 := Convert( slices, 9 );
            rec.numpols8 := Convert( slices, 10 );
            rec.numpols9 := Convert( slices, 11 );
            rec.polamt := Convert( slices, 12 );
            rec.polmore := Convert( slices, 13 );
            rec.polpay := Convert( slices, 14 );
            rec.polpd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( InsuranceRec ).startPos = 0 ) then
               index.pointers( InsuranceRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( InsuranceRec ).counter := index.pointers( InsuranceRec ).counter + 1;
            Put_Index( index_map, index );
            Insurance_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Insurance_IO.Close( bin_file );
   end Create_Insurance_0304;


   procedure Create_Job_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.dedoth := Convert( slices, 22 );
            rec.deduc1 := Convert( slices, 23 );
            rec.deduc2 := Convert( slices, 24 );
            rec.deduc3 := Convert( slices, 25 );
            rec.deduc4 := Convert( slices, 26 );
            rec.deduc5 := Convert( slices, 27 );
            rec.deduc6 := Convert( slices, 28 );
            rec.deduc7 := Convert( slices, 29 );
            rec.deduc8 := Convert( slices, 30 );
            rec.dirctr := Convert( slices, 31 );
            rec.dirni := Convert( slices, 32 );
            rec.dvtothru := Convert( slices, 33 );
            rec.dvushr := Convert( slices, 34 );
            rec.empany := Convert( slices, 35 );
            rec.empown := Convert( slices, 36 );
            rec.etype := Convert( slices, 37 );
            rec.everot := Convert( slices, 38 );
            rec.ftpt := Convert( slices, 39 );
            rec.grsofar := Convert( slices, 40 );
            rec.grwage := Convert( slices, 41 );
            rec.grwagpd := Convert( slices, 42 );
            rec.hha1 := Convert( slices, 43 );
            rec.hha2 := Convert( slices, 44 );
            rec.hha3 := Convert( slices, 45 );
            rec.hhc1 := Convert( slices, 46 );
            rec.hhc2 := Convert( slices, 47 );
            rec.hhc3 := Convert( slices, 48 );
            rec.hohinc := Convert( slices, 49 );
            rec.inclpay1 := Convert( slices, 50 );
            rec.inclpay2 := Convert( slices, 51 );
            rec.inclpay3 := Convert( slices, 52 );
            rec.inclpay4 := Convert( slices, 53 );
            rec.inclpay5 := Convert( slices, 54 );
            rec.inclpay6 := Convert( slices, 55 );
            rec.inkind01 := Convert( slices, 56 );
            rec.inkind02 := Convert( slices, 57 );
            rec.inkind03 := Convert( slices, 58 );
            rec.inkind04 := Convert( slices, 59 );
            rec.inkind05 := Convert( slices, 60 );
            rec.inkind06 := Convert( slices, 61 );
            rec.inkind07 := Convert( slices, 62 );
            rec.inkind08 := Convert( slices, 63 );
            rec.inkind09 := Convert( slices, 64 );
            rec.inkind10 := Convert( slices, 65 );
            rec.inkind11 := Convert( slices, 66 );
            rec.instype1 := Convert( slices, 67 );
            rec.instype2 := Convert( slices, 68 );
            rec.jobbus := Convert( slices, 69 );
            rec.likehr := Convert( slices, 70 );
            rec.mademp := Convert( slices, 71 );
            rec.matemp := Convert( slices, 72 );
            rec.matstp := Convert( slices, 73 );
            rec.mileamt := Convert( slices, 74 );
            rec.motamt := Convert( slices, 75 );
            rec.natins := Convert( slices, 76 );
            rec.nature := Convert( slices, 77 );
            rec.nidamt := Convert( slices, 78 );
            rec.nidpd := Convert( slices, 79 );
            rec.nmchc := Convert( slices, 80 );
            rec.nmper := Convert( slices, 81 );
            rec.nomor1 := Convert( slices, 82 );
            rec.nomor2 := Convert( slices, 83 );
            rec.nomor3 := Convert( slices, 84 );
            rec.numemp := Convert( slices, 85 );
            rec.othded1 := Convert( slices, 86 );
            rec.othded2 := Convert( slices, 87 );
            rec.othded3 := Convert( slices, 88 );
            rec.othded4 := Convert( slices, 89 );
            rec.othded5 := Convert( slices, 90 );
            rec.othded6 := Convert( slices, 91 );
            rec.othded7 := Convert( slices, 92 );
            rec.othded8 := Convert( slices, 93 );
            rec.othded9 := Convert( slices, 94 );
            rec.ownamt := Convert( slices, 95 );
            rec.ownotamt := Convert( slices, 96 );
            rec.ownother := Convert( slices, 97 );
            rec.ownsum := Convert( slices, 98 );
            rec.payamt := Convert( slices, 99 );
            rec.paydat := Convert( slices, 100 );
            rec.paye := Convert( slices, 101 );
            rec.paypd := Convert( slices, 102 );
            rec.payslip := Convert( slices, 103 );
            rec.payusl := Convert( slices, 104 );
            rec.pothr := Convert( slices, 105 );
            rec.prbefore := Convert( slices, 106 );
            rec.profdocs := Convert( slices, 107 );
            rec.profit1 := Convert( slices, 108 );
            rec.profit2 := Convert( slices, 109 );
            rec.profni := Convert( slices, 110 );
            rec.proftax := Convert( slices, 111 );
            rec.rspoth := Convert( slices, 112 );
            rec.se1 := Convert( slices, 113 );
            rec.se2 := Convert( slices, 114 );
            rec.seend := Convert( slices, 115 );
            rec.seincamt := Convert( slices, 116 );
            rec.seincwm := Convert( slices, 117 );
            rec.selwks := Convert( slices, 118 );
            rec.seniiamt := Convert( slices, 119 );
            rec.seniinc := Convert( slices, 120 );
            rec.senilamt := Convert( slices, 121 );
            rec.senilump := Convert( slices, 122 );
            rec.seniramt := Convert( slices, 123 );
            rec.senireg := Convert( slices, 124 );
            rec.senirpd := Convert( slices, 125 );
            rec.setax := Convert( slices, 126 );
            rec.setaxamt := Convert( slices, 127 );
            rec.smpamt := Convert( slices, 128 );
            rec.smprate := Convert( slices, 129 );
            rec.sole := Convert( slices, 130 );
            rec.sspamt := Convert( slices, 131 );
            rec.taxamt := Convert( slices, 132 );
            rec.taxdamt := Convert( slices, 133 );
            rec.taxdpd := Convert( slices, 134 );
            rec.totus1 := Convert( slices, 135 );
            rec.ubonamt := Convert( slices, 136 );
            rec.uboninc := Convert( slices, 137 );
            rec.udeduc1 := Convert( slices, 138 );
            rec.udeduc2 := Convert( slices, 139 );
            rec.udeduc3 := Convert( slices, 140 );
            rec.udeduc4 := Convert( slices, 141 );
            rec.udeduc5 := Convert( slices, 142 );
            rec.udeduc6 := Convert( slices, 143 );
            rec.udeduc7 := Convert( slices, 144 );
            rec.udeduc8 := Convert( slices, 145 );
            rec.ugross := Convert( slices, 146 );
            rec.uincpay1 := Convert( slices, 147 );
            rec.uincpay2 := Convert( slices, 148 );
            rec.uincpay3 := Convert( slices, 149 );
            rec.uincpay4 := Convert( slices, 150 );
            rec.uincpay5 := Convert( slices, 151 );
            rec.uincpay6 := Convert( slices, 152 );
            rec.umileamt := Convert( slices, 153 );
            rec.umotamt := Convert( slices, 154 );
            rec.unett := Convert( slices, 155 );
            rec.uothded1 := Convert( slices, 156 );
            rec.uothded2 := Convert( slices, 157 );
            rec.uothded3 := Convert( slices, 158 );
            rec.uothded4 := Convert( slices, 159 );
            rec.uothded5 := Convert( slices, 160 );
            rec.uothded6 := Convert( slices, 161 );
            rec.uothded7 := Convert( slices, 162 );
            rec.uothded8 := Convert( slices, 163 );
            rec.uothded9 := Convert( slices, 164 );
            rec.uothdtot := Convert( slices, 165 );
            rec.uothr := Convert( slices, 166 );
            rec.upd := Convert( slices, 167 );
            rec.usmpamt := Convert( slices, 168 );
            rec.usmprate := Convert( slices, 169 );
            rec.usspamt := Convert( slices, 170 );
            rec.usuhr := Convert( slices, 171 );
            rec.utaxamt := Convert( slices, 172 );
            rec.watdid := Convert( slices, 173 );
            rec.watprev := Convert( slices, 174 );
            rec.where := Convert( slices, 175 );
            rec.whynopro := Convert( slices, 176 );
            rec.whynou01 := Convert( slices, 177 );
            rec.whynou02 := Convert( slices, 178 );
            rec.whynou03 := Convert( slices, 179 );
            rec.whynou04 := Convert( slices, 180 );
            rec.whynou05 := Convert( slices, 181 );
            rec.whynou06 := Convert( slices, 182 );
            rec.whynou07 := Convert( slices, 183 );
            rec.whynou08 := Convert( slices, 184 );
            rec.whynou09 := Convert( slices, 185 );
            rec.whynou10 := Convert( slices, 186 );
            rec.whynou11 := Convert( slices, 187 );
            rec.workacc := Convert( slices, 188 );
            rec.workmth := Convert( slices, 189 );
            rec.workyr := Convert( slices, 190 );
            rec.month := Convert( slices, 191 );
            rec.hdqhrs := Convert( slices, 192 );
            rec.jobhours := Convert( slices, 193 );
            rec.sspsmpfg := Convert( slices, 194 );
            rec.ugrspay := Convert( slices, 195 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0304;


   procedure Create_Maint_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.m := Convert( slices, 5 );
            rec.mrage := Convert( slices, 6 );
            rec.mramt := Convert( slices, 7 );
            rec.mrchwhy1 := Convert( slices, 8 );
            rec.mrchwhy2 := Convert( slices, 9 );
            rec.mrchwhy3 := Convert( slices, 10 );
            rec.mrchwhy4 := Convert( slices, 11 );
            rec.mrchwhy5 := Convert( slices, 12 );
            rec.mrchwhy6 := Convert( slices, 13 );
            rec.mrchwhy7 := Convert( slices, 14 );
            rec.mrchwhy8 := Convert( slices, 15 );
            rec.mrchwhy9 := Convert( slices, 16 );
            rec.mrct := Convert( slices, 17 );
            rec.mrkid := Convert( slices, 18 );
            rec.mrpd := Convert( slices, 19 );
            rec.mrr := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0304;


   procedure Create_MortCont_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.outsamt := Convert( slices, 4 );
            rec.outsincl := Convert( slices, 5 );
            rec.outspay := Convert( slices, 6 );
            rec.outspd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0304;


   procedure Create_Mortgage_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.exrent := Convert( slices, 9 );
            rec.incminc1 := Convert( slices, 10 );
            rec.incminc2 := Convert( slices, 11 );
            rec.incminc3 := Convert( slices, 12 );
            rec.incmp1 := Convert( slices, 13 );
            rec.incmp2 := Convert( slices, 14 );
            rec.incmp3 := Convert( slices, 15 );
            rec.incmpam1 := Convert( slices, 16 );
            rec.incmpam2 := Convert( slices, 17 );
            rec.incmpam3 := Convert( slices, 18 );
            rec.incmppd1 := Convert( slices, 19 );
            rec.incmppd2 := Convert( slices, 20 );
            rec.incmppd3 := Convert( slices, 21 );
            rec.incmsty1 := Convert( slices, 22 );
            rec.incmsty2 := Convert( slices, 23 );
            rec.incmsty3 := Convert( slices, 24 );
            rec.intprpay := Convert( slices, 25 );
            rec.intprpd := Convert( slices, 26 );
            rec.intru := Convert( slices, 27 );
            rec.intrupd := Convert( slices, 28 );
            rec.intrus := Convert( slices, 29 );
            rec.loan2y := Convert( slices, 30 );
            rec.loanyear := Convert( slices, 31 );
            rec.menpol := Convert( slices, 32 );
            rec.morall := Convert( slices, 33 );
            rec.morflc := Convert( slices, 34 );
            rec.morinpay := Convert( slices, 35 );
            rec.morinpd := Convert( slices, 36 );
            rec.morinus := Convert( slices, 37 );
            rec.mortend := Convert( slices, 38 );
            rec.mortleft := Convert( slices, 39 );
            rec.mortprot := Convert( slices, 40 );
            rec.morttype := Convert( slices, 41 );
            rec.morupd := Convert( slices, 42 );
            rec.morus := Convert( slices, 43 );
            rec.mpcover1 := Convert( slices, 44 );
            rec.mpcover2 := Convert( slices, 45 );
            rec.mpcover3 := Convert( slices, 46 );
            rec.mpolno := Convert( slices, 47 );
            rec.outsmort := Convert( slices, 48 );
            rec.rentfrom := Convert( slices, 49 );
            rec.rmamt := Convert( slices, 50 );
            rec.rmort := Convert( slices, 51 );
            rec.rmortyr := Convert( slices, 52 );
            rec.rmpur001 := Convert( slices, 53 );
            rec.rmpur002 := Convert( slices, 54 );
            rec.rmpur003 := Convert( slices, 55 );
            rec.rmpur004 := Convert( slices, 56 );
            rec.rmpur005 := Convert( slices, 57 );
            rec.rmpur006 := Convert( slices, 58 );
            rec.rmpur007 := Convert( slices, 59 );
            rec.rmpur008 := Convert( slices, 60 );
            rec.month := Convert( slices, 61 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0304;


   procedure Create_OddJob_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.ojamt := Convert( slices, 6 );
            rec.ojnow := Convert( slices, 7 );
            rec.ojreg := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0304;


   procedure Create_Owner_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.othmort1 := Convert( slices, 3 );
            rec.othmort2 := Convert( slices, 4 );
            rec.othmort3 := Convert( slices, 5 );
            rec.othpur1 := Convert( slices, 6 );
            rec.othpur2 := Convert( slices, 7 );
            rec.othpur3 := Convert( slices, 8 );
            rec.othpur31 := Convert( slices, 9 );
            rec.othpur32 := Convert( slices, 10 );
            rec.othpur33 := Convert( slices, 11 );
            rec.othpur34 := Convert( slices, 12 );
            rec.othpur35 := Convert( slices, 13 );
            rec.othpur36 := Convert( slices, 14 );
            rec.othpur37 := Convert( slices, 15 );
            rec.othpur4 := Convert( slices, 16 );
            rec.othpur5 := Convert( slices, 17 );
            rec.othpur6 := Convert( slices, 18 );
            rec.othpur7 := Convert( slices, 19 );
            rec.purcamt := Convert( slices, 20 );
            rec.purcloan := Convert( slices, 21 );
            rec.month := Convert( slices, 22 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0304;


   procedure Create_PenAmt_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.penq := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0304;


   procedure Create_PenProv_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppay := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eplong := Convert( slices, 6 );
            rec.eptype := Convert( slices, 7 );
            rec.keeppen := Convert( slices, 8 );
            rec.opgov := Convert( slices, 9 );
            rec.penamt := Convert( slices, 10 );
            rec.penamtpd := Convert( slices, 11 );
            rec.pencon := Convert( slices, 12 );
            rec.pendat := Convert( slices, 13 );
            rec.pengov := Convert( slices, 14 );
            rec.penhelp := Convert( slices, 15 );
            rec.penmort := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0304;


   procedure Create_Pension_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.penoth := Convert( slices, 6 );
            rec.penpay := Convert( slices, 7 );
            rec.penpd := Convert( slices, 8 );
            rec.pentax := Convert( slices, 9 );
            rec.pentype := Convert( slices, 10 );
            rec.poamt := Convert( slices, 11 );
            rec.poinc := Convert( slices, 12 );
            rec.posour := Convert( slices, 13 );
            rec.ptamt := Convert( slices, 14 );
            rec.ptinc := Convert( slices, 15 );
            rec.trights := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0304;


   procedure Create_RentCont_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0304;


   procedure Create_Renter_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbweeks := Convert( slices, 28 );
            rec.landlord := Convert( slices, 29 );
            rec.niystart := Convert( slices, 30 );
            rec.othway := Convert( slices, 31 );
            rec.rebate := Convert( slices, 32 );
            rec.rent := Convert( slices, 33 );
            rec.rentdk := Convert( slices, 34 );
            rec.rentdoc := Convert( slices, 35 );
            rec.rentfull := Convert( slices, 36 );
            rec.renthol := Convert( slices, 37 );
            rec.rentpd := Convert( slices, 38 );
            rec.resll := Convert( slices, 39 );
            rec.resll2 := Convert( slices, 40 );
            rec.serinc1 := Convert( slices, 41 );
            rec.serinc2 := Convert( slices, 42 );
            rec.serinc3 := Convert( slices, 43 );
            rec.serinc4 := Convert( slices, 44 );
            rec.serinc5 := Convert( slices, 45 );
            rec.short1 := Convert( slices, 46 );
            rec.short2 := Convert( slices, 47 );
            rec.weekhol := Convert( slices, 48 );
            rec.wsinc := Convert( slices, 49 );
            rec.wsincamt := Convert( slices, 50 );
            rec.ystartr := Convert( slices, 51 );
            rec.month := Convert( slices, 52 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0304;


   procedure Create_Vehicle_0304( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Vehicle_IO.File_Type;
      rec         : Vehicle_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Vehicle_IO.Create (bin_file, Vehicle_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.vehseq := Convert( slices, 2 );
            rec.vehic := Convert( slices, 3 );
            rec.vehown := Convert( slices, 4 );
            rec.month := Convert( slices, 5 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( VehicleRec ).startPos = 0 ) then
               index.pointers( VehicleRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( VehicleRec ).counter := index.pointers( VehicleRec ).counter + 1;
            Put_Index( index_map, index );
            Vehicle_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Vehicle_IO.Close( bin_file );
   end Create_Vehicle_0304;


   procedure Create_Account_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.nsamt := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0405;


   procedure Create_Admin_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.ncr1 := Convert( slices, 5 );
            rec.ncr2 := Convert( slices, 6 );
            rec.ncr3 := Convert( slices, 7 );
            rec.ncr4 := Convert( slices, 8 );
            rec.ncr5 := Convert( slices, 9 );
            rec.ncr6 := Convert( slices, 10 );
            rec.ncr7 := Convert( slices, 11 );
            rec.refr01 := Convert( slices, 12 );
            rec.refr02 := Convert( slices, 13 );
            rec.refr03 := Convert( slices, 14 );
            rec.refr04 := Convert( slices, 15 );
            rec.refr05 := Convert( slices, 16 );
            rec.refr06 := Convert( slices, 17 );
            rec.refr07 := Convert( slices, 18 );
            rec.refr08 := Convert( slices, 19 );
            rec.refr09 := Convert( slices, 20 );
            rec.refr10 := Convert( slices, 21 );
            rec.refr11 := Convert( slices, 22 );
            rec.refr12 := Convert( slices, 23 );
            rec.refr13 := Convert( slices, 24 );
            rec.refr14 := Convert( slices, 25 );
            rec.refr15 := Convert( slices, 26 );
            rec.refr16 := Convert( slices, 27 );
            rec.refr17 := Convert( slices, 28 );
            rec.refr18 := Convert( slices, 29 );
            rec.tnc := Convert( slices, 30 );
            rec.version := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0405;


   procedure Create_Adult_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.allow1 := Convert( slices, 21 );
            rec.allow2 := Convert( slices, 22 );
            rec.allow3 := Convert( slices, 23 );
            rec.allow4 := Convert( slices, 24 );
            rec.allpay1 := Convert( slices, 25 );
            rec.allpay2 := Convert( slices, 26 );
            rec.allpay3 := Convert( slices, 27 );
            rec.allpay4 := Convert( slices, 28 );
            rec.allpd1 := Convert( slices, 29 );
            rec.allpd2 := Convert( slices, 30 );
            rec.allpd3 := Convert( slices, 31 );
            rec.allpd4 := Convert( slices, 32 );
            rec.anyacc := Convert( slices, 33 );
            rec.anyed := Convert( slices, 34 );
            rec.anymon := Convert( slices, 35 );
            rec.anypen1 := Convert( slices, 36 );
            rec.anypen2 := Convert( slices, 37 );
            rec.anypen3 := Convert( slices, 38 );
            rec.anypen4 := Convert( slices, 39 );
            rec.anypen5 := Convert( slices, 40 );
            rec.anypen6 := Convert( slices, 41 );
            rec.anypen7 := Convert( slices, 42 );
            rec.apamt := Convert( slices, 43 );
            rec.apdamt := Convert( slices, 44 );
            rec.apdir := Convert( slices, 45 );
            rec.apdpd := Convert( slices, 46 );
            rec.appd := Convert( slices, 47 );
            rec.b2qfut1 := Convert( slices, 48 );
            rec.b2qfut2 := Convert( slices, 49 );
            rec.b2qfut3 := Convert( slices, 50 );
            rec.b3qfut1 := Convert( slices, 51 );
            rec.b3qfut2 := Convert( slices, 52 );
            rec.b3qfut3 := Convert( slices, 53 );
            rec.b3qfut4 := Convert( slices, 54 );
            rec.b3qfut5 := Convert( slices, 55 );
            rec.b3qfut6 := Convert( slices, 56 );
            rec.ben1q1 := Convert( slices, 57 );
            rec.ben1q2 := Convert( slices, 58 );
            rec.ben1q3 := Convert( slices, 59 );
            rec.ben1q4 := Convert( slices, 60 );
            rec.ben1q5 := Convert( slices, 61 );
            rec.ben1q6 := Convert( slices, 62 );
            rec.ben1q7 := Convert( slices, 63 );
            rec.ben2q1 := Convert( slices, 64 );
            rec.ben2q2 := Convert( slices, 65 );
            rec.ben2q3 := Convert( slices, 66 );
            rec.ben3q1 := Convert( slices, 67 );
            rec.ben3q2 := Convert( slices, 68 );
            rec.ben3q3 := Convert( slices, 69 );
            rec.ben3q4 := Convert( slices, 70 );
            rec.ben3q5 := Convert( slices, 71 );
            rec.ben3q6 := Convert( slices, 72 );
            rec.ben4q1 := Convert( slices, 73 );
            rec.ben4q2 := Convert( slices, 74 );
            rec.ben4q3 := Convert( slices, 75 );
            rec.ben5q1 := Convert( slices, 76 );
            rec.ben5q2 := Convert( slices, 77 );
            rec.ben5q3 := Convert( slices, 78 );
            rec.ben5q4 := Convert( slices, 79 );
            rec.ben5q5 := Convert( slices, 80 );
            rec.ben5q6 := Convert( slices, 81 );
            rec.ben5q7 := Convert( slices, 82 );
            rec.ben5q8 := Convert( slices, 83 );
            rec.ben5q9 := Convert( slices, 84 );
            rec.ben7q1 := Convert( slices, 85 );
            rec.ben7q2 := Convert( slices, 86 );
            rec.ben7q3 := Convert( slices, 87 );
            rec.ben7q4 := Convert( slices, 88 );
            rec.ben7q5 := Convert( slices, 89 );
            rec.ben7q6 := Convert( slices, 90 );
            rec.ben7q7 := Convert( slices, 91 );
            rec.ben7q8 := Convert( slices, 92 );
            rec.ben7q9 := Convert( slices, 93 );
            rec.btwacc := Convert( slices, 94 );
            rec.claimant := Convert( slices, 95 );
            rec.cohabit := Convert( slices, 96 );
            rec.combid := Convert( slices, 97 );
            rec.convbl := Convert( slices, 98 );
            rec.ctclum1 := Convert( slices, 99 );
            rec.ctclum2 := Convert( slices, 100 );
            rec.cupchk := Convert( slices, 101 );
            rec.cvht := Convert( slices, 102 );
            rec.cvpay := Convert( slices, 103 );
            rec.cvpd := Convert( slices, 104 );
            rec.ddatre := Convert( slices, 105 );
            rec.depend := Convert( slices, 106 );
            rec.disdif1 := Convert( slices, 107 );
            rec.disdif2 := Convert( slices, 108 );
            rec.disdif3 := Convert( slices, 109 );
            rec.disdif4 := Convert( slices, 110 );
            rec.disdif5 := Convert( slices, 111 );
            rec.disdif6 := Convert( slices, 112 );
            rec.disdif7 := Convert( slices, 113 );
            rec.disdif8 := Convert( slices, 114 );
            rec.disdif9 := Convert( slices, 115 );
            rec.dob := Convert( slices, 116 );
            rec.dvil03a := Convert( slices, 117 );
            rec.dvil04a := Convert( slices, 118 );
            rec.dvjb12ml := Convert( slices, 119 );
            rec.dvmardf := Convert( slices, 120 );
            rec.ed1amt := Convert( slices, 121 );
            rec.ed1borr := Convert( slices, 122 );
            rec.ed1int := Convert( slices, 123 );
            rec.ed1monyr := Convert( slices, 124 );
            rec.ed1pd := Convert( slices, 125 );
            rec.ed1sum := Convert( slices, 126 );
            rec.ed2amt := Convert( slices, 127 );
            rec.ed2borr := Convert( slices, 128 );
            rec.ed2int := Convert( slices, 129 );
            rec.ed2monyr := Convert( slices, 130 );
            rec.ed2pd := Convert( slices, 131 );
            rec.ed2sum := Convert( slices, 132 );
            rec.edatt := Convert( slices, 133 );
            rec.edattn1 := Convert( slices, 134 );
            rec.edattn2 := Convert( slices, 135 );
            rec.edattn3 := Convert( slices, 136 );
            rec.edhr := Convert( slices, 137 );
            rec.edtime := Convert( slices, 138 );
            rec.edtyp := Convert( slices, 139 );
            rec.eligadlt := Convert( slices, 140 );
            rec.eligchld := Convert( slices, 141 );
            rec.emppay1 := Convert( slices, 142 );
            rec.emppay2 := Convert( slices, 143 );
            rec.emppay3 := Convert( slices, 144 );
            rec.empstat := Convert( slices, 145 );
            rec.endyr := Convert( slices, 146 );
            rec.epcur := Convert( slices, 147 );
            rec.es2000 := Convert( slices, 148 );
            rec.ethgrp := Convert( slices, 149 );
            rec.everwrk := Convert( slices, 150 );
            rec.exthbct1 := Convert( slices, 151 );
            rec.exthbct2 := Convert( slices, 152 );
            rec.exthbct3 := Convert( slices, 153 );
            rec.fare := Convert( slices, 154 );
            rec.follow := Convert( slices, 155 );
            rec.fted := Convert( slices, 156 );
            rec.ftwk := Convert( slices, 157 );
            rec.future := Convert( slices, 158 );
            rec.govpis := Convert( slices, 159 );
            rec.govpjsa := Convert( slices, 160 );
            rec.grant := Convert( slices, 161 );
            rec.grtamt1 := Convert( slices, 162 );
            rec.grtamt2 := Convert( slices, 163 );
            rec.grtdir1 := Convert( slices, 164 );
            rec.grtdir2 := Convert( slices, 165 );
            rec.grtnum := Convert( slices, 166 );
            rec.grtsce1 := Convert( slices, 167 );
            rec.grtsce2 := Convert( slices, 168 );
            rec.grtval1 := Convert( slices, 169 );
            rec.grtval2 := Convert( slices, 170 );
            rec.gta := Convert( slices, 171 );
            rec.hbothamt := Convert( slices, 172 );
            rec.hbothbu := Convert( slices, 173 );
            rec.hbothpd := Convert( slices, 174 );
            rec.hbothwk := Convert( slices, 175 );
            rec.hbotwait := Convert( slices, 176 );
            rec.health := Convert( slices, 177 );
            rec.hholder := Convert( slices, 178 );
            rec.hprob := Convert( slices, 179 );
            rec.hrpid := Convert( slices, 180 );
            rec.incdur := Convert( slices, 181 );
            rec.injlong := Convert( slices, 182 );
            rec.injwk := Convert( slices, 183 );
            rec.invests := Convert( slices, 184 );
            rec.iout := Convert( slices, 185 );
            rec.isa1type := Convert( slices, 186 );
            rec.isa2type := Convert( slices, 187 );
            rec.isa3type := Convert( slices, 188 );
            rec.jobaway := Convert( slices, 189 );
            rec.lareg := Convert( slices, 190 );
            rec.likewk := Convert( slices, 191 );
            rec.lktime := Convert( slices, 192 );
            rec.ln1rpint := Convert( slices, 193 );
            rec.ln2rpint := Convert( slices, 194 );
            rec.loan := Convert( slices, 195 );
            rec.loannum := Convert( slices, 196 );
            rec.look := Convert( slices, 197 );
            rec.lookwk := Convert( slices, 198 );
            rec.lstwrk1 := Convert( slices, 199 );
            rec.lstwrk2 := Convert( slices, 200 );
            rec.lstyr := Convert( slices, 201 );
            rec.mntamt1 := Convert( slices, 202 );
            rec.mntamt2 := Convert( slices, 203 );
            rec.mntct := Convert( slices, 204 );
            rec.mntfor1 := Convert( slices, 205 );
            rec.mntfor2 := Convert( slices, 206 );
            rec.mntgov1 := Convert( slices, 207 );
            rec.mntgov2 := Convert( slices, 208 );
            rec.mntpay := Convert( slices, 209 );
            rec.mntpd1 := Convert( slices, 210 );
            rec.mntpd2 := Convert( slices, 211 );
            rec.mntrec := Convert( slices, 212 );
            rec.mnttota1 := Convert( slices, 213 );
            rec.mnttota2 := Convert( slices, 214 );
            rec.mntus1 := Convert( slices, 215 );
            rec.mntus2 := Convert( slices, 216 );
            rec.mntusam1 := Convert( slices, 217 );
            rec.mntusam2 := Convert( slices, 218 );
            rec.mntuspd1 := Convert( slices, 219 );
            rec.mntuspd2 := Convert( slices, 220 );
            rec.ms := Convert( slices, 221 );
            rec.natid1 := Convert( slices, 222 );
            rec.natid2 := Convert( slices, 223 );
            rec.natid3 := Convert( slices, 224 );
            rec.natid4 := Convert( slices, 225 );
            rec.natid5 := Convert( slices, 226 );
            rec.natid6 := Convert( slices, 227 );
            rec.ndeal := Convert( slices, 228 );
            rec.newdtype := Convert( slices, 229 );
            rec.niamt := Convert( slices, 230 );
            rec.niethgrp := Convert( slices, 231 );
            rec.niexthbb := Convert( slices, 232 );
            rec.ninatid1 := Convert( slices, 233 );
            rec.ninatid2 := Convert( slices, 234 );
            rec.ninatid3 := Convert( slices, 235 );
            rec.ninatid4 := Convert( slices, 236 );
            rec.ninatid5 := Convert( slices, 237 );
            rec.ninatid6 := Convert( slices, 238 );
            rec.ninatid7 := Convert( slices, 239 );
            rec.ninatid8 := Convert( slices, 240 );
            rec.nipd := Convert( slices, 241 );
            rec.nireg := Convert( slices, 242 );
            rec.nirel := Convert( slices, 243 );
            rec.nitrain := Convert( slices, 244 );
            rec.nittwmod := Convert( slices, 245 );
            rec.nlper := Convert( slices, 246 );
            rec.nolk1 := Convert( slices, 247 );
            rec.nolk2 := Convert( slices, 248 );
            rec.nolk3 := Convert( slices, 249 );
            rec.nolook := Convert( slices, 250 );
            rec.nowant := Convert( slices, 251 );
            rec.nssec := Convert( slices, 252 );
            rec.ntcdat := Convert( slices, 253 );
            rec.ntcinc := Convert( slices, 254 );
            rec.numjob := Convert( slices, 255 );
            rec.numjob2 := Convert( slices, 256 );
            rec.oddjob := Convert( slices, 257 );
            rec.oldstud := Convert( slices, 258 );
            rec.oneway := Convert( slices, 259 );
            rec.otabspar := Convert( slices, 260 );
            rec.otamt := Convert( slices, 261 );
            rec.otapamt := Convert( slices, 262 );
            rec.otappd := Convert( slices, 263 );
            rec.othtax := Convert( slices, 264 );
            rec.otinva := Convert( slices, 265 );
            rec.pareamt := Convert( slices, 266 );
            rec.parepd := Convert( slices, 267 );
            rec.penlump := Convert( slices, 268 );
            rec.ppnumc := Convert( slices, 269 );
            rec.pssamt := Convert( slices, 270 );
            rec.pssdate := Convert( slices, 271 );
            rec.ptwk := Convert( slices, 272 );
            rec.r01 := Convert( slices, 273 );
            rec.r02 := Convert( slices, 274 );
            rec.r03 := Convert( slices, 275 );
            rec.r04 := Convert( slices, 276 );
            rec.r05 := Convert( slices, 277 );
            rec.r06 := Convert( slices, 278 );
            rec.r07 := Convert( slices, 279 );
            rec.r08 := Convert( slices, 280 );
            rec.r09 := Convert( slices, 281 );
            rec.r10 := Convert( slices, 282 );
            rec.r11 := Convert( slices, 283 );
            rec.r12 := Convert( slices, 284 );
            rec.r13 := Convert( slices, 285 );
            rec.r14 := Convert( slices, 286 );
            rec.redamt := Convert( slices, 287 );
            rec.redany := Convert( slices, 288 );
            rec.rentprof := Convert( slices, 289 );
            rec.retire := Convert( slices, 290 );
            rec.retire1 := Convert( slices, 291 );
            rec.retreas := Convert( slices, 292 );
            rec.royal1 := Convert( slices, 293 );
            rec.royal2 := Convert( slices, 294 );
            rec.royal3 := Convert( slices, 295 );
            rec.royal4 := Convert( slices, 296 );
            rec.royyr1 := Convert( slices, 297 );
            rec.royyr2 := Convert( slices, 298 );
            rec.royyr3 := Convert( slices, 299 );
            rec.royyr4 := Convert( slices, 300 );
            rec.rstrct := Convert( slices, 301 );
            rec.sex := Convert( slices, 302 );
            rec.sflntyp1 := Convert( slices, 303 );
            rec.sflntyp2 := Convert( slices, 304 );
            rec.sftype1 := Convert( slices, 305 );
            rec.sftype2 := Convert( slices, 306 );
            rec.sic := Convert( slices, 307 );
            rec.slrepamt := Convert( slices, 308 );
            rec.slrepay := Convert( slices, 309 );
            rec.slreppd := Convert( slices, 310 );
            rec.soc2000 := Convert( slices, 311 );
            rec.spcreg1 := Convert( slices, 312 );
            rec.spcreg2 := Convert( slices, 313 );
            rec.spcreg3 := Convert( slices, 314 );
            rec.spout := Convert( slices, 315 );
            rec.srentamt := Convert( slices, 316 );
            rec.srentpd := Convert( slices, 317 );
            rec.start := Convert( slices, 318 );
            rec.startyr := Convert( slices, 319 );
            rec.taxcred1 := Convert( slices, 320 );
            rec.taxcred2 := Convert( slices, 321 );
            rec.taxfut := Convert( slices, 322 );
            rec.tdaywrk := Convert( slices, 323 );
            rec.tea := Convert( slices, 324 );
            rec.topupl := Convert( slices, 325 );
            rec.totint := Convert( slices, 326 );
            rec.train := Convert( slices, 327 );
            rec.ttwcode1 := Convert( slices, 328 );
            rec.ttwcode2 := Convert( slices, 329 );
            rec.ttwcode3 := Convert( slices, 330 );
            rec.ttwcost := Convert( slices, 331 );
            rec.ttwfar := Convert( slices, 332 );
            rec.ttwfrq := Convert( slices, 333 );
            rec.ttwmod := Convert( slices, 334 );
            rec.ttwpay := Convert( slices, 335 );
            rec.ttwpss := Convert( slices, 336 );
            rec.ttwrec := Convert( slices, 337 );
            rec.tuborr := Convert( slices, 338 );
            rec.typeed := Convert( slices, 339 );
            rec.unpaid1 := Convert( slices, 340 );
            rec.unpaid2 := Convert( slices, 341 );
            rec.w1 := Convert( slices, 342 );
            rec.w2 := Convert( slices, 343 );
            rec.wait := Convert( slices, 344 );
            rec.war1 := Convert( slices, 345 );
            rec.war2 := Convert( slices, 346 );
            rec.whoresp := Convert( slices, 347 );
            rec.whosectb := Convert( slices, 348 );
            rec.wintfuel := Convert( slices, 349 );
            rec.wmkit := Convert( slices, 350 );
            rec.working := Convert( slices, 351 );
            rec.wpa := Convert( slices, 352 );
            rec.wpba := Convert( slices, 353 );
            rec.wtclum1 := Convert( slices, 354 );
            rec.wtclum2 := Convert( slices, 355 );
            rec.wtclum3 := Convert( slices, 356 );
            rec.ystrtwk := Convert( slices, 357 );
            rec.month := Convert( slices, 358 );
            rec.able := Convert( slices, 359 );
            rec.actacci := Convert( slices, 360 );
            rec.addda := Convert( slices, 361 );
            rec.basacti := Convert( slices, 362 );
            rec.bntxcred := Convert( slices, 363 );
            rec.careab := Convert( slices, 364 );
            rec.careah := Convert( slices, 365 );
            rec.carecb := Convert( slices, 366 );
            rec.carech := Convert( slices, 367 );
            rec.carecl := Convert( slices, 368 );
            rec.carefl := Convert( slices, 369 );
            rec.carefr := Convert( slices, 370 );
            rec.careot := Convert( slices, 371 );
            rec.carere := Convert( slices, 372 );
            rec.chbflg := Convert( slices, 373 );
            rec.crunaci := Convert( slices, 374 );
            rec.curacti := Convert( slices, 375 );
            rec.empoccp := Convert( slices, 376 );
            rec.empstatb := Convert( slices, 377 );
            rec.empstatc := Convert( slices, 378 );
            rec.empstati := Convert( slices, 379 );
            rec.enomorti := Convert( slices, 380 );
            rec.fsbndcti := Convert( slices, 381 );
            rec.fwmlkval := Convert( slices, 382 );
            rec.gebacti := Convert( slices, 383 );
            rec.giltcti := Convert( slices, 384 );
            rec.gross3 := Convert( slices, 385 );
            rec.hbsupran := Convert( slices, 386 );
            rec.hdage := Convert( slices, 387 );
            rec.hdben := Convert( slices, 388 );
            rec.hdindinc := Convert( slices, 389 );
            rec.hourab := Convert( slices, 390 );
            rec.hourah := Convert( slices, 391 );
            rec.hourcare := Convert( slices, 392 );
            rec.hourcb := Convert( slices, 393 );
            rec.hourch := Convert( slices, 394 );
            rec.hourcl := Convert( slices, 395 );
            rec.hourfr := Convert( slices, 396 );
            rec.hourot := Convert( slices, 397 );
            rec.hourre := Convert( slices, 398 );
            rec.hourtot := Convert( slices, 399 );
            rec.hperson := Convert( slices, 400 );
            rec.iagegr2 := Convert( slices, 401 );
            rec.iagegrp := Convert( slices, 402 );
            rec.incseo2 := Convert( slices, 403 );
            rec.indinc := Convert( slices, 404 );
            rec.indisben := Convert( slices, 405 );
            rec.inearns := Convert( slices, 406 );
            rec.ininv := Convert( slices, 407 );
            rec.inirben := Convert( slices, 408 );
            rec.innirben := Convert( slices, 409 );
            rec.inothben := Convert( slices, 410 );
            rec.inpeninc := Convert( slices, 411 );
            rec.inrinc := Convert( slices, 412 );
            rec.inrpinc := Convert( slices, 413 );
            rec.intvlic := Convert( slices, 414 );
            rec.intxcred := Convert( slices, 415 );
            rec.isacti := Convert( slices, 416 );
            rec.marital := Convert( slices, 417 );
            rec.netocpen := Convert( slices, 418 );
            rec.nincseo2 := Convert( slices, 419 );
            rec.nindinc := Convert( slices, 420 );
            rec.ninearns := Convert( slices, 421 );
            rec.nininv := Convert( slices, 422 );
            rec.ninpenin := Convert( slices, 423 );
            rec.ninsein2 := Convert( slices, 424 );
            rec.nsbocti := Convert( slices, 425 );
            rec.occupnum := Convert( slices, 426 );
            rec.otbscti := Convert( slices, 427 );
            rec.pepscti := Convert( slices, 428 );
            rec.poaccti := Convert( slices, 429 );
            rec.prbocti := Convert( slices, 430 );
            rec.relhrp := Convert( slices, 431 );
            rec.sapadj := Convert( slices, 432 );
            rec.sayecti := Convert( slices, 433 );
            rec.sclbcti := Convert( slices, 434 );
            rec.seincam2 := Convert( slices, 435 );
            rec.smpadj := Convert( slices, 436 );
            rec.sppadj := Convert( slices, 437 );
            rec.sscti := Convert( slices, 438 );
            rec.sspadj := Convert( slices, 439 );
            rec.stshcti := Convert( slices, 440 );
            rec.superan := Convert( slices, 441 );
            rec.taxpayer := Convert( slices, 442 );
            rec.tesscti := Convert( slices, 443 );
            rec.totgrant := Convert( slices, 444 );
            rec.tothours := Convert( slices, 445 );
            rec.totoccp := Convert( slices, 446 );
            rec.ttwcosts := Convert( slices, 447 );
            rec.ttwmode := Convert( slices, 448 );
            rec.untrcti := Convert( slices, 449 );
            rec.uperson := Convert( slices, 450 );
            rec.widoccp := Convert( slices, 451 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0405;


   procedure Create_Asset_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0405;


   procedure Create_Benefit_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.notusamt := Convert( slices, 16 );
            rec.notuspd := Convert( slices, 17 );
            rec.numweeks := Convert( slices, 18 );
            rec.ordbkno := Convert( slices, 19 );
            rec.payslipb := Convert( slices, 20 );
            rec.pres := Convert( slices, 21 );
            rec.usual := Convert( slices, 22 );
            rec.var1 := Convert( slices, 23 );
            rec.var2 := Convert( slices, 24 );
            rec.var3 := Convert( slices, 25 );
            rec.whorec1 := Convert( slices, 26 );
            rec.whorec2 := Convert( slices, 27 );
            rec.whorec3 := Convert( slices, 28 );
            rec.whorec4 := Convert( slices, 29 );
            rec.whorec5 := Convert( slices, 30 );
            rec.month := Convert( slices, 31 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0405;


   procedure Create_Benunit_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.cdelply := Convert( slices, 13 );
            rec.cdepbed := Convert( slices, 14 );
            rec.cdepcel := Convert( slices, 15 );
            rec.cdepeqp := Convert( slices, 16 );
            rec.cdephol := Convert( slices, 17 );
            rec.cdeples := Convert( slices, 18 );
            rec.cdepsum := Convert( slices, 19 );
            rec.cdeptea := Convert( slices, 20 );
            rec.cdeptrp := Convert( slices, 21 );
            rec.cplay := Convert( slices, 22 );
            rec.debt1 := Convert( slices, 23 );
            rec.debt2 := Convert( slices, 24 );
            rec.debt3 := Convert( slices, 25 );
            rec.debt4 := Convert( slices, 26 );
            rec.debt5 := Convert( slices, 27 );
            rec.debt6 := Convert( slices, 28 );
            rec.debt7 := Convert( slices, 29 );
            rec.debt8 := Convert( slices, 30 );
            rec.debt9 := Convert( slices, 31 );
            rec.houshe1 := Convert( slices, 32 );
            rec.incchnge := Convert( slices, 33 );
            rec.inchilow := Convert( slices, 34 );
            rec.incold := Convert( slices, 35 );
            rec.kidinc := Convert( slices, 36 );
            rec.nhhchild := Convert( slices, 37 );
            rec.totsav := Convert( slices, 38 );
            rec.month := Convert( slices, 39 );
            rec.actaccb := Convert( slices, 40 );
            rec.adddabu := Convert( slices, 41 );
            rec.adultb := Convert( slices, 42 );
            rec.basactb := Convert( slices, 43 );
            rec.boarder := Convert( slices, 44 );
            rec.bpeninc := Convert( slices, 45 );
            rec.bseinc := Convert( slices, 46 );
            rec.buagegr2 := Convert( slices, 47 );
            rec.buagegrp := Convert( slices, 48 );
            rec.budisben := Convert( slices, 49 );
            rec.buearns := Convert( slices, 50 );
            rec.buethgr2 := Convert( slices, 51 );
            rec.buethgrp := Convert( slices, 52 );
            rec.buinc := Convert( slices, 53 );
            rec.buinv := Convert( slices, 54 );
            rec.buirben := Convert( slices, 55 );
            rec.bukids := Convert( slices, 56 );
            rec.bunirben := Convert( slices, 57 );
            rec.buothben := Convert( slices, 58 );
            rec.burent := Convert( slices, 59 );
            rec.burinc := Convert( slices, 60 );
            rec.burpinc := Convert( slices, 61 );
            rec.butvlic := Convert( slices, 62 );
            rec.butxcred := Convert( slices, 63 );
            rec.chddabu := Convert( slices, 64 );
            rec.crunacb := Convert( slices, 65 );
            rec.curactb := Convert( slices, 66 );
            rec.depchldb := Convert( slices, 67 );
            rec.depdeds := Convert( slices, 68 );
            rec.disindhb := Convert( slices, 69 );
            rec.ecotypbu := Convert( slices, 70 );
            rec.ecstatbu := Convert( slices, 71 );
            rec.enomortb := Convert( slices, 72 );
            rec.famthbai := Convert( slices, 73 );
            rec.famtypbs := Convert( slices, 74 );
            rec.famtypbu := Convert( slices, 75 );
            rec.famtype := Convert( slices, 76 );
            rec.fsbndctb := Convert( slices, 77 );
            rec.fsmbu := Convert( slices, 78 );
            rec.fsmlkbu := Convert( slices, 79 );
            rec.fwmlkbu := Convert( slices, 80 );
            rec.gebactb := Convert( slices, 81 );
            rec.giltctb := Convert( slices, 82 );
            rec.gross3 := Convert( slices, 83 );
            rec.hbindbu := Convert( slices, 84 );
            rec.isactb := Convert( slices, 85 );
            rec.kid04 := Convert( slices, 86 );
            rec.kid1115 := Convert( slices, 87 );
            rec.kid1618 := Convert( slices, 88 );
            rec.kid510 := Convert( slices, 89 );
            rec.kidsbu0 := Convert( slices, 90 );
            rec.kidsbu1 := Convert( slices, 91 );
            rec.kidsbu10 := Convert( slices, 92 );
            rec.kidsbu11 := Convert( slices, 93 );
            rec.kidsbu12 := Convert( slices, 94 );
            rec.kidsbu13 := Convert( slices, 95 );
            rec.kidsbu14 := Convert( slices, 96 );
            rec.kidsbu15 := Convert( slices, 97 );
            rec.kidsbu16 := Convert( slices, 98 );
            rec.kidsbu17 := Convert( slices, 99 );
            rec.kidsbu18 := Convert( slices, 100 );
            rec.kidsbu2 := Convert( slices, 101 );
            rec.kidsbu3 := Convert( slices, 102 );
            rec.kidsbu4 := Convert( slices, 103 );
            rec.kidsbu5 := Convert( slices, 104 );
            rec.kidsbu6 := Convert( slices, 105 );
            rec.kidsbu7 := Convert( slices, 106 );
            rec.kidsbu8 := Convert( slices, 107 );
            rec.kidsbu9 := Convert( slices, 108 );
            rec.lastwork := Convert( slices, 109 );
            rec.lodger := Convert( slices, 110 );
            rec.nsboctb := Convert( slices, 111 );
            rec.otbsctb := Convert( slices, 112 );
            rec.pepsctb := Convert( slices, 113 );
            rec.poacctb := Convert( slices, 114 );
            rec.prboctb := Convert( slices, 115 );
            rec.sayectb := Convert( slices, 116 );
            rec.sclbctb := Convert( slices, 117 );
            rec.ssctb := Convert( slices, 118 );
            rec.stshctb := Convert( slices, 119 );
            rec.subltamt := Convert( slices, 120 );
            rec.tessctb := Convert( slices, 121 );
            rec.totcapbu := Convert( slices, 122 );
            rec.totsavbu := Convert( slices, 123 );
            rec.tuburent := Convert( slices, 124 );
            rec.untrctb := Convert( slices, 125 );
            rec.youngch := Convert( slices, 126 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0405;


   procedure Create_Care_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.wholoo01 := Convert( slices, 26 );
            rec.wholoo02 := Convert( slices, 27 );
            rec.wholoo03 := Convert( slices, 28 );
            rec.wholoo04 := Convert( slices, 29 );
            rec.wholoo05 := Convert( slices, 30 );
            rec.wholoo06 := Convert( slices, 31 );
            rec.wholoo07 := Convert( slices, 32 );
            rec.wholoo08 := Convert( slices, 33 );
            rec.wholoo09 := Convert( slices, 34 );
            rec.wholoo10 := Convert( slices, 35 );
            rec.wholoo11 := Convert( slices, 36 );
            rec.wholoo12 := Convert( slices, 37 );
            rec.wholoo13 := Convert( slices, 38 );
            rec.wholoo14 := Convert( slices, 39 );
            rec.wholoo15 := Convert( slices, 40 );
            rec.wholoo16 := Convert( slices, 41 );
            rec.wholoo17 := Convert( slices, 42 );
            rec.wholoo18 := Convert( slices, 43 );
            rec.wholoo19 := Convert( slices, 44 );
            rec.wholoo20 := Convert( slices, 45 );
            rec.month := Convert( slices, 46 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0405;


   procedure Create_Child_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.benccdis := Convert( slices, 6 );
            rec.care := Convert( slices, 7 );
            rec.cddatre := Convert( slices, 8 );
            rec.cdisdif1 := Convert( slices, 9 );
            rec.cdisdif2 := Convert( slices, 10 );
            rec.cdisdif3 := Convert( slices, 11 );
            rec.cdisdif4 := Convert( slices, 12 );
            rec.cdisdif5 := Convert( slices, 13 );
            rec.cdisdif6 := Convert( slices, 14 );
            rec.cdisdif7 := Convert( slices, 15 );
            rec.cdisdif8 := Convert( slices, 16 );
            rec.cdisdif9 := Convert( slices, 17 );
            rec.chamt1 := Convert( slices, 18 );
            rec.chamt2 := Convert( slices, 19 );
            rec.chamt3 := Convert( slices, 20 );
            rec.chamt4 := Convert( slices, 21 );
            rec.chamtern := Convert( slices, 22 );
            rec.chamttst := Convert( slices, 23 );
            rec.chdla1 := Convert( slices, 24 );
            rec.chdla2 := Convert( slices, 25 );
            rec.chealth := Convert( slices, 26 );
            rec.chearns1 := Convert( slices, 27 );
            rec.chearns2 := Convert( slices, 28 );
            rec.chema := Convert( slices, 29 );
            rec.chemaamt := Convert( slices, 30 );
            rec.chemapd := Convert( slices, 31 );
            rec.chfar := Convert( slices, 32 );
            rec.chhr1 := Convert( slices, 33 );
            rec.chhr2 := Convert( slices, 34 );
            rec.chlook01 := Convert( slices, 35 );
            rec.chlook02 := Convert( slices, 36 );
            rec.chlook03 := Convert( slices, 37 );
            rec.chlook04 := Convert( slices, 38 );
            rec.chlook05 := Convert( slices, 39 );
            rec.chlook06 := Convert( slices, 40 );
            rec.chlook07 := Convert( slices, 41 );
            rec.chlook08 := Convert( slices, 42 );
            rec.chlook09 := Convert( slices, 43 );
            rec.chlook10 := Convert( slices, 44 );
            rec.chpay1 := Convert( slices, 45 );
            rec.chpay2 := Convert( slices, 46 );
            rec.chpay3 := Convert( slices, 47 );
            rec.chpdern := Convert( slices, 48 );
            rec.chpdtst := Convert( slices, 49 );
            rec.chprob := Convert( slices, 50 );
            rec.chsave := Convert( slices, 51 );
            rec.chwkern := Convert( slices, 52 );
            rec.chwktst := Convert( slices, 53 );
            rec.chyrern := Convert( slices, 54 );
            rec.chyrtst := Convert( slices, 55 );
            rec.clone := Convert( slices, 56 );
            rec.cohabit := Convert( slices, 57 );
            rec.convbl := Convert( slices, 58 );
            rec.cost := Convert( slices, 59 );
            rec.cvht := Convert( slices, 60 );
            rec.cvpay := Convert( slices, 61 );
            rec.cvpd := Convert( slices, 62 );
            rec.depend := Convert( slices, 63 );
            rec.dob := Convert( slices, 64 );
            rec.eligadlt := Convert( slices, 65 );
            rec.eligchld := Convert( slices, 66 );
            rec.endyr := Convert( slices, 67 );
            rec.fted := Convert( slices, 68 );
            rec.grant := Convert( slices, 69 );
            rec.grtamt1 := Convert( slices, 70 );
            rec.grtamt2 := Convert( slices, 71 );
            rec.grtdir1 := Convert( slices, 72 );
            rec.grtdir2 := Convert( slices, 73 );
            rec.grtnum := Convert( slices, 74 );
            rec.grtsce1 := Convert( slices, 75 );
            rec.grtsce2 := Convert( slices, 76 );
            rec.grtval1 := Convert( slices, 77 );
            rec.grtval2 := Convert( slices, 78 );
            rec.hholder := Convert( slices, 79 );
            rec.lareg := Convert( slices, 80 );
            rec.legdep := Convert( slices, 81 );
            rec.ms := Convert( slices, 82 );
            rec.parent1 := Convert( slices, 83 );
            rec.parent2 := Convert( slices, 84 );
            rec.r01 := Convert( slices, 85 );
            rec.r02 := Convert( slices, 86 );
            rec.r03 := Convert( slices, 87 );
            rec.r04 := Convert( slices, 88 );
            rec.r05 := Convert( slices, 89 );
            rec.r06 := Convert( slices, 90 );
            rec.r07 := Convert( slices, 91 );
            rec.r08 := Convert( slices, 92 );
            rec.r09 := Convert( slices, 93 );
            rec.r10 := Convert( slices, 94 );
            rec.r11 := Convert( slices, 95 );
            rec.r12 := Convert( slices, 96 );
            rec.r13 := Convert( slices, 97 );
            rec.r14 := Convert( slices, 98 );
            rec.registr1 := Convert( slices, 99 );
            rec.registr2 := Convert( slices, 100 );
            rec.registr3 := Convert( slices, 101 );
            rec.registr4 := Convert( slices, 102 );
            rec.registr5 := Convert( slices, 103 );
            rec.sex := Convert( slices, 104 );
            rec.smkit := Convert( slices, 105 );
            rec.smlit := Convert( slices, 106 );
            rec.spcreg1 := Convert( slices, 107 );
            rec.spcreg2 := Convert( slices, 108 );
            rec.spcreg3 := Convert( slices, 109 );
            rec.spout := Convert( slices, 110 );
            rec.srentamt := Convert( slices, 111 );
            rec.srentpd := Convert( slices, 112 );
            rec.startyr := Convert( slices, 113 );
            rec.totsave := Convert( slices, 114 );
            rec.typeed := Convert( slices, 115 );
            rec.wmkit := Convert( slices, 116 );
            rec.month := Convert( slices, 117 );
            rec.careab := Convert( slices, 118 );
            rec.careah := Convert( slices, 119 );
            rec.carecb := Convert( slices, 120 );
            rec.carech := Convert( slices, 121 );
            rec.carecl := Convert( slices, 122 );
            rec.carefl := Convert( slices, 123 );
            rec.carefr := Convert( slices, 124 );
            rec.careot := Convert( slices, 125 );
            rec.carere := Convert( slices, 126 );
            rec.chdda := Convert( slices, 127 );
            rec.chearns := Convert( slices, 128 );
            rec.chincdv := Convert( slices, 129 );
            rec.chrinc := Convert( slices, 130 );
            rec.fsmlkval := Convert( slices, 131 );
            rec.fsmval := Convert( slices, 132 );
            rec.fwmlkval := Convert( slices, 133 );
            rec.hdagech := Convert( slices, 134 );
            rec.hourab := Convert( slices, 135 );
            rec.hourah := Convert( slices, 136 );
            rec.hourcb := Convert( slices, 137 );
            rec.hourch := Convert( slices, 138 );
            rec.hourcl := Convert( slices, 139 );
            rec.hourfr := Convert( slices, 140 );
            rec.hourot := Convert( slices, 141 );
            rec.hourre := Convert( slices, 142 );
            rec.hourtot := Convert( slices, 143 );
            rec.hperson := Convert( slices, 144 );
            rec.iagegr2 := Convert( slices, 145 );
            rec.iagegrp := Convert( slices, 146 );
            rec.relhrp := Convert( slices, 147 );
            rec.totgntch := Convert( slices, 148 );
            rec.uperson := Convert( slices, 149 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0405;


   procedure Create_Endowment_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.menpolam := Convert( slices, 5 );
            rec.menpolpd := Convert( slices, 6 );
            rec.menstyr := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0405;


   procedure Create_ExtChild_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.nhhamt := Convert( slices, 4 );
            rec.nhhfee := Convert( slices, 5 );
            rec.nhhintro := Convert( slices, 6 );
            rec.nhhpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0405;


   procedure Create_GovPay_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.month := Convert( slices, 6 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0405;


   procedure Create_Hbai_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcstm := Convert( slices, 17 );
            rec.snphcsto := Convert( slices, 18 );
            rec.sphcstm := Convert( slices, 19 );
            rec.sphcsto := Convert( slices, 20 );
            rec.sernum := Convert( slices, 21 );
            rec.benunits := Convert( slices, 22 );
            rec.gvtregn := Convert( slices, 23 );
            rec.hhstat := Convert( slices, 24 );
            rec.tenure := Convert( slices, 25 );
            rec.adulth := Convert( slices, 26 );
            rec.depchldh := Convert( slices, 27 );
            rec.tentyp2 := Convert( slices, 28 );
            rec.watsewrt := Convert( slices, 29 );
            rec.sewerage := Convert( slices, 30 );
            rec.cwathh := Convert( slices, 31 );
            rec.totsthh := Convert( slices, 32 );
            rec.totstrhh := Convert( slices, 33 );
            rec.charghh := Convert( slices, 34 );
            rec.hbmort := Convert( slices, 35 );
            rec.hbxmort := Convert( slices, 36 );
            rec.hrenthh := Convert( slices, 37 );
            rec.erenthh := Convert( slices, 38 );
            rec.hbenhh := Convert( slices, 39 );
            rec.watsewhh := Convert( slices, 40 );
            rec.hhcost := Convert( slices, 41 );
            rec.ehcost := Convert( slices, 42 );
            rec.bhcdef := Convert( slices, 43 );
            rec.ahcdef := Convert( slices, 44 );
            rec.ctliab := Convert( slices, 45 );
            rec.ctrebam1 := Convert( slices, 46 );
            rec.adultb := Convert( slices, 47 );
            rec.egrincbu := Convert( slices, 48 );
            rec.entinmbu := Convert( slices, 49 );
            rec.entinobu := Convert( slices, 50 );
            rec.hgrernhh := Convert( slices, 51 );
            rec.hnternhh := Convert( slices, 52 );
            rec.hgrinvhh := Convert( slices, 53 );
            rec.hntinvhh := Convert( slices, 54 );
            rec.hgrocchh := Convert( slices, 55 );
            rec.hntocchh := Convert( slices, 56 );
            rec.hbeninhh := Convert( slices, 57 );
            rec.hpribnhh := Convert( slices, 58 );
            rec.hmiscihh := Convert( slices, 59 );
            rec.sfrpahh := Convert( slices, 60 );
            rec.hgrinchh := Convert( slices, 61 );
            rec.hntinchh := Convert( slices, 62 );
            rec.inchilhh := Convert( slices, 63 );
            rec.shtseflg := Convert( slices, 64 );
            rec.sehhflg := Convert( slices, 65 );
            rec.ethgrphh := Convert( slices, 66 );
            rec.egrernhh := Convert( slices, 67 );
            rec.enternhh := Convert( slices, 68 );
            rec.ebeninhh := Convert( slices, 69 );
            rec.epribnhh := Convert( slices, 70 );
            rec.emiscihh := Convert( slices, 71 );
            rec.eothdmhh := Convert( slices, 72 );
            rec.eothdohh := Convert( slices, 73 );
            rec.egrinchh := Convert( slices, 74 );
            rec.entinmhh := Convert( slices, 75 );
            rec.entinohh := Convert( slices, 76 );
            rec.tvlichh := Convert( slices, 77 );
            rec.g_newhh := Convert( slices, 78 );
            rec.gnewhhp := Convert( slices, 79 );
            rec.esgjobhh := Convert( slices, 80 );
            rec.esgrsehh := Convert( slices, 81 );
            rec.esginvhh := Convert( slices, 82 );
            rec.esgocchh := Convert( slices, 83 );
            rec.esmischh := Convert( slices, 84 );
            rec.espribhh := Convert( slices, 85 );
            rec.esbenihh := Convert( slices, 86 );
            rec.esothmhh := Convert( slices, 87 );
            rec.esothohh := Convert( slices, 88 );
            rec.esginchh := Convert( slices, 89 );
            rec.esninmhh := Convert( slices, 90 );
            rec.esninohh := Convert( slices, 91 );
            rec.eripmhh := Convert( slices, 92 );
            rec.eripohh := Convert( slices, 93 );
            rec.erinpmhh := Convert( slices, 94 );
            rec.erinpohh := Convert( slices, 95 );
            rec.gs_newhh := Convert( slices, 96 );
            rec.es_hcstm := Convert( slices, 97 );
            rec.es_hcsto := Convert( slices, 98 );
            rec.esahcmhh := Convert( slices, 99 );
            rec.esahcohh := Convert( slices, 100 );
            rec.eahcmhh := Convert( slices, 101 );
            rec.eahcohh := Convert( slices, 102 );
            rec.benunit := Convert( slices, 103 );
            rec.depchldb := Convert( slices, 104 );
            rec.eqmcoup := Convert( slices, 105 );
            rec.eqmbhckd := Convert( slices, 106 );
            rec.eqmahckd := Convert( slices, 107 );
            rec.eqmbhchh := Convert( slices, 108 );
            rec.eqmahchh := Convert( slices, 109 );
            rec.over14 := Convert( slices, 110 );
            rec.under14 := Convert( slices, 111 );
            rec.eqobhchh := Convert( slices, 112 );
            rec.eqoahchh := Convert( slices, 113 );
            rec.mc_bhc := Convert( slices, 114 );
            rec.oe_bhc := Convert( slices, 115 );
            rec.mc_gro := Convert( slices, 116 );
            rec.oe_gro := Convert( slices, 117 );
            rec.mc_ahc := Convert( slices, 118 );
            rec.oe_ahc := Convert( slices, 119 );
            rec.s_mc_bhc := Convert( slices, 120 );
            rec.s_oe_bhc := Convert( slices, 121 );
            rec.s_mc_gro := Convert( slices, 122 );
            rec.s_oe_gro := Convert( slices, 123 );
            rec.s_mc_ahc := Convert( slices, 124 );
            rec.s_oe_ahc := Convert( slices, 125 );
            rec.famthbai := Convert( slices, 126 );
            rec.fsmbu := Convert( slices, 127 );
            rec.fsmlkbu := Convert( slices, 128 );
            rec.fwmlkbu := Convert( slices, 129 );
            rec.kidsbu0 := Convert( slices, 130 );
            rec.kidsbu1 := Convert( slices, 131 );
            rec.kidsbu10 := Convert( slices, 132 );
            rec.kidsbu11 := Convert( slices, 133 );
            rec.kidsbu12 := Convert( slices, 134 );
            rec.kidsbu13 := Convert( slices, 135 );
            rec.kidsbu14 := Convert( slices, 136 );
            rec.kidsbu15 := Convert( slices, 137 );
            rec.kidsbu16 := Convert( slices, 138 );
            rec.kidsbu17 := Convert( slices, 139 );
            rec.kidsbu18 := Convert( slices, 140 );
            rec.kidsbu2 := Convert( slices, 141 );
            rec.kidsbu3 := Convert( slices, 142 );
            rec.kidsbu4 := Convert( slices, 143 );
            rec.kidsbu5 := Convert( slices, 144 );
            rec.kidsbu6 := Convert( slices, 145 );
            rec.kidsbu7 := Convert( slices, 146 );
            rec.kidsbu8 := Convert( slices, 147 );
            rec.kidsbu9 := Convert( slices, 148 );
            rec.hbenbu := Convert( slices, 149 );
            rec.ehbenbu := Convert( slices, 150 );
            rec.srentbu := Convert( slices, 151 );
            rec.rentbu := Convert( slices, 152 );
            rec.erentbu := Convert( slices, 153 );
            rec.insebu := Convert( slices, 154 );
            rec.ginsebu := Convert( slices, 155 );
            rec.hgrernbu := Convert( slices, 156 );
            rec.hnternbu := Convert( slices, 157 );
            rec.hgrinvbu := Convert( slices, 158 );
            rec.hntinvbu := Convert( slices, 159 );
            rec.hgroccbu := Convert( slices, 160 );
            rec.hntoccbu := Convert( slices, 161 );
            rec.hbeninbu := Convert( slices, 162 );
            rec.hpribnbu := Convert( slices, 163 );
            rec.hmiscibu := Convert( slices, 164 );
            rec.sfrpabu := Convert( slices, 165 );
            rec.hgrincbu := Convert( slices, 166 );
            rec.hntincbu := Convert( slices, 167 );
            rec.egrernbu := Convert( slices, 168 );
            rec.enternbu := Convert( slices, 169 );
            rec.ebeninbu := Convert( slices, 170 );
            rec.epribnbu := Convert( slices, 171 );
            rec.emiscibu := Convert( slices, 172 );
            rec.eothdmbu := Convert( slices, 173 );
            rec.eothdobu := Convert( slices, 174 );
            rec.winpaybu := Convert( slices, 175 );
            rec.tvlicbu := Convert( slices, 176 );
            rec.ecobu := Convert( slices, 177 );
            rec.disabflg := Convert( slices, 178 );
            rec.fambu := Convert( slices, 179 );
            rec.newfambu := Convert( slices, 180 );
            rec.kidecobu := Convert( slices, 181 );
            rec.kid0_1 := Convert( slices, 182 );
            rec.kid2_4 := Convert( slices, 183 );
            rec.kid5_7 := Convert( slices, 184 );
            rec.kid8_10 := Convert( slices, 185 );
            rec.kid11_12 := Convert( slices, 186 );
            rec.kid13_15 := Convert( slices, 187 );
            rec.kid16_18 := Convert( slices, 188 );
            rec.boys := Convert( slices, 189 );
            rec.wtcbu := Convert( slices, 190 );
            rec.ctcbu := Convert( slices, 191 );
            rec.isbu := Convert( slices, 192 );
            rec.inchilbu := Convert( slices, 193 );
            rec.g_newbu := Convert( slices, 194 );
            rec.g_newpp := Convert( slices, 195 );
            rec.g_newch := Convert( slices, 196 );
            rec.g_newad := Convert( slices, 197 );
            rec.g_newpn := Convert( slices, 198 );
            rec.g_newwa := Convert( slices, 199 );
            rec.esgjobbu := Convert( slices, 200 );
            rec.esgrsebu := Convert( slices, 201 );
            rec.esginvbu := Convert( slices, 202 );
            rec.esgoccbu := Convert( slices, 203 );
            rec.esmiscbu := Convert( slices, 204 );
            rec.espribbu := Convert( slices, 205 );
            rec.esbenibu := Convert( slices, 206 );
            rec.esothmbu := Convert( slices, 207 );
            rec.esothobu := Convert( slices, 208 );
            rec.esgincbu := Convert( slices, 209 );
            rec.esninmbu := Convert( slices, 210 );
            rec.esninobu := Convert( slices, 211 );
            rec.eripmbu := Convert( slices, 212 );
            rec.eripobu := Convert( slices, 213 );
            rec.erinpmbu := Convert( slices, 214 );
            rec.erinpobu := Convert( slices, 215 );
            rec.gs_newbu := Convert( slices, 216 );
            rec.gs_newpp := Convert( slices, 217 );
            rec.gs_newch := Convert( slices, 218 );
            rec.gs_newad := Convert( slices, 219 );
            rec.gs_newpn := Convert( slices, 220 );
            rec.gs_newwa := Convert( slices, 221 );
            rec.mbhcdec := Convert( slices, 222 );
            rec.mqinbhc := Convert( slices, 223 );
            rec.obhcdec := Convert( slices, 224 );
            rec.oqinbhc := Convert( slices, 225 );
            rec.mahcdec := Convert( slices, 226 );
            rec.mqinahc := Convert( slices, 227 );
            rec.oahcdec := Convert( slices, 228 );
            rec.oqinahc := Convert( slices, 229 );
            rec.mbhcdecx := Convert( slices, 230 );
            rec.mqinbhcx := Convert( slices, 231 );
            rec.obhcdecx := Convert( slices, 232 );
            rec.oqinbhcx := Convert( slices, 233 );
            rec.mahcdecx := Convert( slices, 234 );
            rec.mqinahcx := Convert( slices, 235 );
            rec.oahcdecx := Convert( slices, 236 );
            rec.oqinahcx := Convert( slices, 237 );
            rec.agehd := Convert( slices, 238 );
            rec.sexhd := Convert( slices, 239 );
            rec.agesp := Convert( slices, 240 );
            rec.sexsp := Convert( slices, 241 );
            rec.ptentyp2 := Convert( slices, 242 );
            rec.totincm1 := Convert( slices, 243 );
            rec.totincm2 := Convert( slices, 244 );
            rec.netincm1 := Convert( slices, 245 );
            rec.netincm2 := Convert( slices, 246 );
            rec.totincw1 := Convert( slices, 247 );
            rec.totincw2 := Convert( slices, 248 );
            rec.netincw1 := Convert( slices, 249 );
            rec.netincw2 := Convert( slices, 250 );
            rec.lowoebhc := Convert( slices, 251 );
            rec.lowoeahc := Convert( slices, 252 );
            rec.lowmcbhc := Convert( slices, 253 );
            rec.lowmcahc := Convert( slices, 254 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0405;


   procedure Create_Household_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.acorn := Convert( slices, 2 );
            rec.acornew := Convert( slices, 3 );
            rec.bedroom := Convert( slices, 4 );
            rec.benunits := Convert( slices, 5 );
            rec.billrate := Convert( slices, 6 );
            rec.busroom := Convert( slices, 7 );
            rec.charge1 := Convert( slices, 8 );
            rec.charge2 := Convert( slices, 9 );
            rec.charge3 := Convert( slices, 10 );
            rec.charge4 := Convert( slices, 11 );
            rec.charge5 := Convert( slices, 12 );
            rec.charge6 := Convert( slices, 13 );
            rec.charge7 := Convert( slices, 14 );
            rec.charge8 := Convert( slices, 15 );
            rec.charge9 := Convert( slices, 16 );
            rec.chins := Convert( slices, 17 );
            rec.chrgamt1 := Convert( slices, 18 );
            rec.chrgamt2 := Convert( slices, 19 );
            rec.chrgamt3 := Convert( slices, 20 );
            rec.chrgamt4 := Convert( slices, 21 );
            rec.chrgamt5 := Convert( slices, 22 );
            rec.chrgamt6 := Convert( slices, 23 );
            rec.chrgamt7 := Convert( slices, 24 );
            rec.chrgamt8 := Convert( slices, 25 );
            rec.chrgamt9 := Convert( slices, 26 );
            rec.chrgpd1 := Convert( slices, 27 );
            rec.chrgpd2 := Convert( slices, 28 );
            rec.chrgpd3 := Convert( slices, 29 );
            rec.chrgpd4 := Convert( slices, 30 );
            rec.chrgpd5 := Convert( slices, 31 );
            rec.chrgpd6 := Convert( slices, 32 );
            rec.chrgpd7 := Convert( slices, 33 );
            rec.chrgpd8 := Convert( slices, 34 );
            rec.chrgpd9 := Convert( slices, 35 );
            rec.contv1 := Convert( slices, 36 );
            rec.contv2 := Convert( slices, 37 );
            rec.covoths := Convert( slices, 38 );
            rec.csewamt := Convert( slices, 39 );
            rec.csewamt1 := Convert( slices, 40 );
            rec.ct25d50d := Convert( slices, 41 );
            rec.ctamt := Convert( slices, 42 );
            rec.ctannual := Convert( slices, 43 );
            rec.ctband := Convert( slices, 44 );
            rec.ctbwait := Convert( slices, 45 );
            rec.ctcondoc := Convert( slices, 46 );
            rec.ctdisc := Convert( slices, 47 );
            rec.ctinstal := Convert( slices, 48 );
            rec.ctlvband := Convert( slices, 49 );
            rec.ctlvchk := Convert( slices, 50 );
            rec.ctreb := Convert( slices, 51 );
            rec.ctrebamt := Convert( slices, 52 );
            rec.ctrebpd := Convert( slices, 53 );
            rec.cttime := Convert( slices, 54 );
            rec.cwatamt := Convert( slices, 55 );
            rec.cwatamt1 := Convert( slices, 56 );
            rec.datyrago := Convert( slices, 57 );
            rec.entry1 := Convert( slices, 58 );
            rec.entry2 := Convert( slices, 59 );
            rec.entry3 := Convert( slices, 60 );
            rec.entry4 := Convert( slices, 61 );
            rec.estrtann := Convert( slices, 62 );
            rec.floor := Convert( slices, 63 );
            rec.givehelp := Convert( slices, 64 );
            rec.gvtregn := Convert( slices, 65 );
            rec.hhldr01 := Convert( slices, 66 );
            rec.hhldr02 := Convert( slices, 67 );
            rec.hhldr03 := Convert( slices, 68 );
            rec.hhldr04 := Convert( slices, 69 );
            rec.hhldr05 := Convert( slices, 70 );
            rec.hhldr06 := Convert( slices, 71 );
            rec.hhldr07 := Convert( slices, 72 );
            rec.hhldr08 := Convert( slices, 73 );
            rec.hhldr09 := Convert( slices, 74 );
            rec.hhldr10 := Convert( slices, 75 );
            rec.hhldr11 := Convert( slices, 76 );
            rec.hhldr12 := Convert( slices, 77 );
            rec.hhldr13 := Convert( slices, 78 );
            rec.hhldr14 := Convert( slices, 79 );
            rec.hhldr97 := Convert( slices, 80 );
            rec.hhstat := Convert( slices, 81 );
            rec.hrpnum := Convert( slices, 82 );
            rec.intdate := Convert( slices, 83 );
            rec.lac := Convert( slices, 84 );
            rec.mainacc := Convert( slices, 85 );
            rec.mnthcode := Convert( slices, 86 );
            rec.monlive := Convert( slices, 87 );
            rec.needhelp := Convert( slices, 88 );
            rec.nicoun := Convert( slices, 89 );
            rec.ninrv := Convert( slices, 90 );
            rec.nirate := Convert( slices, 91 );
            rec.norate := Convert( slices, 92 );
            rec.onbsroom := Convert( slices, 93 );
            rec.orgsewam := Convert( slices, 94 );
            rec.orgwatam := Convert( slices, 95 );
            rec.payrate := Convert( slices, 96 );
            rec.premium := Convert( slices, 97 );
            rec.ptbsroom := Convert( slices, 98 );
            rec.rooms := Convert( slices, 99 );
            rec.roomshar := Convert( slices, 100 );
            rec.rtannual := Convert( slices, 101 );
            rec.rtcheck := Convert( slices, 102 );
            rec.rtcondoc := Convert( slices, 103 );
            rec.rtdeduc := Convert( slices, 104 );
            rec.rtinstal := Convert( slices, 105 );
            rec.rtreb := Convert( slices, 106 );
            rec.rtrebamt := Convert( slices, 107 );
            rec.rtrebpd := Convert( slices, 108 );
            rec.rttime := Convert( slices, 109 );
            rec.sampqtr := Convert( slices, 110 );
            rec.schmeal := Convert( slices, 111 );
            rec.schmilk := Convert( slices, 112 );
            rec.sewamt := Convert( slices, 113 );
            rec.sewanul := Convert( slices, 114 );
            rec.sewerpay := Convert( slices, 115 );
            rec.sewsep := Convert( slices, 116 );
            rec.sewtime := Convert( slices, 117 );
            rec.shelter := Convert( slices, 118 );
            rec.sobuy := Convert( slices, 119 );
            rec.sstrtreg := Convert( slices, 120 );
            rec.stramt1 := Convert( slices, 121 );
            rec.stramt2 := Convert( slices, 122 );
            rec.strcov := Convert( slices, 123 );
            rec.strmort := Convert( slices, 124 );
            rec.stroths := Convert( slices, 125 );
            rec.strpd1 := Convert( slices, 126 );
            rec.strpd2 := Convert( slices, 127 );
            rec.suballow := Convert( slices, 128 );
            rec.sublet := Convert( slices, 129 );
            rec.sublety := Convert( slices, 130 );
            rec.subrent := Convert( slices, 131 );
            rec.tenure := Convert( slices, 132 );
            rec.totadult := Convert( slices, 133 );
            rec.totchild := Convert( slices, 134 );
            rec.totdepdk := Convert( slices, 135 );
            rec.tvlic := Convert( slices, 136 );
            rec.typeacc := Convert( slices, 137 );
            rec.watamt := Convert( slices, 138 );
            rec.watanul := Convert( slices, 139 );
            rec.watermet := Convert( slices, 140 );
            rec.waterpay := Convert( slices, 141 );
            rec.watrb := Convert( slices, 142 );
            rec.wattime := Convert( slices, 143 );
            rec.welfmilk := Convert( slices, 144 );
            rec.whoctb01 := Convert( slices, 145 );
            rec.whoctb02 := Convert( slices, 146 );
            rec.whoctb03 := Convert( slices, 147 );
            rec.whoctb04 := Convert( slices, 148 );
            rec.whoctb05 := Convert( slices, 149 );
            rec.whoctb06 := Convert( slices, 150 );
            rec.whoctb07 := Convert( slices, 151 );
            rec.whoctb08 := Convert( slices, 152 );
            rec.whoctb09 := Convert( slices, 153 );
            rec.whoctb10 := Convert( slices, 154 );
            rec.whoctb11 := Convert( slices, 155 );
            rec.whoctb12 := Convert( slices, 156 );
            rec.whoctb13 := Convert( slices, 157 );
            rec.whoctb14 := Convert( slices, 158 );
            rec.whoctbns := Convert( slices, 159 );
            rec.whoctbot := Convert( slices, 160 );
            rec.whorsp01 := Convert( slices, 161 );
            rec.whorsp02 := Convert( slices, 162 );
            rec.whorsp03 := Convert( slices, 163 );
            rec.whorsp04 := Convert( slices, 164 );
            rec.whorsp05 := Convert( slices, 165 );
            rec.whorsp06 := Convert( slices, 166 );
            rec.whorsp07 := Convert( slices, 167 );
            rec.whorsp08 := Convert( slices, 168 );
            rec.whorsp09 := Convert( slices, 169 );
            rec.whorsp10 := Convert( slices, 170 );
            rec.whorsp11 := Convert( slices, 171 );
            rec.whorsp12 := Convert( slices, 172 );
            rec.whorsp13 := Convert( slices, 173 );
            rec.whorsp14 := Convert( slices, 174 );
            rec.whynoct := Convert( slices, 175 );
            rec.wmintro := Convert( slices, 176 );
            rec.wsewamt := Convert( slices, 177 );
            rec.wsewanul := Convert( slices, 178 );
            rec.wsewtime := Convert( slices, 179 );
            rec.yearcode := Convert( slices, 180 );
            rec.yearlive := Convert( slices, 181 );
            rec.month := Convert( slices, 182 );
            rec.actacch := Convert( slices, 183 );
            rec.adddahh := Convert( slices, 184 );
            rec.adulth := Convert( slices, 185 );
            rec.basacth := Convert( slices, 186 );
            rec.chddahh := Convert( slices, 187 );
            rec.crunach := Convert( slices, 188 );
            rec.curacth := Convert( slices, 189 );
            rec.cwatamtd := Convert( slices, 190 );
            rec.depchldh := Convert( slices, 191 );
            rec.emp := Convert( slices, 192 );
            rec.emphrp := Convert( slices, 193 );
            rec.endowpay := Convert( slices, 194 );
            rec.enomorth := Convert( slices, 195 );
            rec.equivahc := Convert( slices, 196 );
            rec.equivbhc := Convert( slices, 197 );
            rec.fsbndcth := Convert( slices, 198 );
            rec.gbhscost := Convert( slices, 199 );
            rec.gebacth := Convert( slices, 200 );
            rec.giltcth := Convert( slices, 201 );
            rec.gross3 := Convert( slices, 202 );
            rec.grossct := Convert( slices, 203 );
            rec.hbeninc := Convert( slices, 204 );
            rec.hbindhh := Convert( slices, 205 );
            rec.hcband := Convert( slices, 206 );
            rec.hdhhinc := Convert( slices, 207 );
            rec.hdtax := Convert( slices, 208 );
            rec.hearns := Convert( slices, 209 );
            rec.hhagegr2 := Convert( slices, 210 );
            rec.hhagegrp := Convert( slices, 211 );
            rec.hhcomp := Convert( slices, 212 );
            rec.hhcomps := Convert( slices, 213 );
            rec.hhdisben := Convert( slices, 214 );
            rec.hhethgr2 := Convert( slices, 215 );
            rec.hhethgrp := Convert( slices, 216 );
            rec.hhinc := Convert( slices, 217 );
            rec.hhincbnd := Convert( slices, 218 );
            rec.hhinv := Convert( slices, 219 );
            rec.hhirben := Convert( slices, 220 );
            rec.hhkids := Convert( slices, 221 );
            rec.hhnirben := Convert( slices, 222 );
            rec.hhothben := Convert( slices, 223 );
            rec.hhrent := Convert( slices, 224 );
            rec.hhrinc := Convert( slices, 225 );
            rec.hhrpinc := Convert( slices, 226 );
            rec.hhsize := Convert( slices, 227 );
            rec.hhtvlic := Convert( slices, 228 );
            rec.hhtxcred := Convert( slices, 229 );
            rec.hothinc := Convert( slices, 230 );
            rec.hpeninc := Convert( slices, 231 );
            rec.hrband := Convert( slices, 232 );
            rec.hseinc := Convert( slices, 233 );
            rec.isacth := Convert( slices, 234 );
            rec.london := Convert( slices, 235 );
            rec.mortcost := Convert( slices, 236 );
            rec.mortint := Convert( slices, 237 );
            rec.mortpay := Convert( slices, 238 );
            rec.nddctb := Convert( slices, 239 );
            rec.nddishc := Convert( slices, 240 );
            rec.nihscost := Convert( slices, 241 );
            rec.nsbocth := Convert( slices, 242 );
            rec.otbscth := Convert( slices, 243 );
            rec.pacctype := Convert( slices, 244 );
            rec.penage := Convert( slices, 245 );
            rec.penhrp := Convert( slices, 246 );
            rec.pepscth := Convert( slices, 247 );
            rec.poaccth := Convert( slices, 248 );
            rec.prbocth := Convert( slices, 249 );
            rec.ptentyp2 := Convert( slices, 250 );
            rec.sayecth := Convert( slices, 251 );
            rec.sclbcth := Convert( slices, 252 );
            rec.servpay := Convert( slices, 253 );
            rec.sick := Convert( slices, 254 );
            rec.sickhrp := Convert( slices, 255 );
            rec.sscth := Convert( slices, 256 );
            rec.struins := Convert( slices, 257 );
            rec.stshcth := Convert( slices, 258 );
            rec.tentyp2 := Convert( slices, 259 );
            rec.tesscth := Convert( slices, 260 );
            rec.tuhhrent := Convert( slices, 261 );
            rec.tuwatsew := Convert( slices, 262 );
            rec.untrcth := Convert( slices, 263 );
            rec.watsewrt := Convert( slices, 264 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0405;


   procedure Create_Insurance_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Insurance_IO.File_Type;
      rec         : Insurance_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Insurance_IO.Create (bin_file, Insurance_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.insseq := Convert( slices, 2 );
            rec.numpols1 := Convert( slices, 3 );
            rec.numpols2 := Convert( slices, 4 );
            rec.numpols3 := Convert( slices, 5 );
            rec.numpols4 := Convert( slices, 6 );
            rec.numpols5 := Convert( slices, 7 );
            rec.numpols6 := Convert( slices, 8 );
            rec.numpols7 := Convert( slices, 9 );
            rec.numpols8 := Convert( slices, 10 );
            rec.numpols9 := Convert( slices, 11 );
            rec.polamt := Convert( slices, 12 );
            rec.polmore := Convert( slices, 13 );
            rec.polpay := Convert( slices, 14 );
            rec.polpd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( InsuranceRec ).startPos = 0 ) then
               index.pointers( InsuranceRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( InsuranceRec ).counter := index.pointers( InsuranceRec ).counter + 1;
            Put_Index( index_map, index );
            Insurance_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Insurance_IO.Close( bin_file );
   end Create_Insurance_0405;


   procedure Create_Job_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.dedoth := Convert( slices, 22 );
            rec.deduc1 := Convert( slices, 23 );
            rec.deduc2 := Convert( slices, 24 );
            rec.deduc3 := Convert( slices, 25 );
            rec.deduc4 := Convert( slices, 26 );
            rec.deduc5 := Convert( slices, 27 );
            rec.deduc6 := Convert( slices, 28 );
            rec.deduc7 := Convert( slices, 29 );
            rec.deduc8 := Convert( slices, 30 );
            rec.dirctr := Convert( slices, 31 );
            rec.dirni := Convert( slices, 32 );
            rec.dvtothru := Convert( slices, 33 );
            rec.dvushr := Convert( slices, 34 );
            rec.empany := Convert( slices, 35 );
            rec.empown := Convert( slices, 36 );
            rec.etype := Convert( slices, 37 );
            rec.everot := Convert( slices, 38 );
            rec.ftpt := Convert( slices, 39 );
            rec.grsofar := Convert( slices, 40 );
            rec.grwage := Convert( slices, 41 );
            rec.grwagpd := Convert( slices, 42 );
            rec.hha1 := Convert( slices, 43 );
            rec.hha2 := Convert( slices, 44 );
            rec.hha3 := Convert( slices, 45 );
            rec.hhc1 := Convert( slices, 46 );
            rec.hhc2 := Convert( slices, 47 );
            rec.hhc3 := Convert( slices, 48 );
            rec.hohinc := Convert( slices, 49 );
            rec.inclpay1 := Convert( slices, 50 );
            rec.inclpay2 := Convert( slices, 51 );
            rec.inclpay3 := Convert( slices, 52 );
            rec.inclpay4 := Convert( slices, 53 );
            rec.inclpay5 := Convert( slices, 54 );
            rec.inclpay6 := Convert( slices, 55 );
            rec.inclpay7 := Convert( slices, 56 );
            rec.inclpay8 := Convert( slices, 57 );
            rec.inkind01 := Convert( slices, 58 );
            rec.inkind02 := Convert( slices, 59 );
            rec.inkind03 := Convert( slices, 60 );
            rec.inkind04 := Convert( slices, 61 );
            rec.inkind05 := Convert( slices, 62 );
            rec.inkind06 := Convert( slices, 63 );
            rec.inkind07 := Convert( slices, 64 );
            rec.inkind08 := Convert( slices, 65 );
            rec.inkind09 := Convert( slices, 66 );
            rec.inkind10 := Convert( slices, 67 );
            rec.inkind11 := Convert( slices, 68 );
            rec.instype1 := Convert( slices, 69 );
            rec.instype2 := Convert( slices, 70 );
            rec.jobbus := Convert( slices, 71 );
            rec.likehr := Convert( slices, 72 );
            rec.mademp := Convert( slices, 73 );
            rec.matemp := Convert( slices, 74 );
            rec.matstp := Convert( slices, 75 );
            rec.mileamt := Convert( slices, 76 );
            rec.motamt := Convert( slices, 77 );
            rec.natins := Convert( slices, 78 );
            rec.nature := Convert( slices, 79 );
            rec.nidamt := Convert( slices, 80 );
            rec.nidpd := Convert( slices, 81 );
            rec.nmchc := Convert( slices, 82 );
            rec.nmper := Convert( slices, 83 );
            rec.nomor1 := Convert( slices, 84 );
            rec.nomor2 := Convert( slices, 85 );
            rec.nomor3 := Convert( slices, 86 );
            rec.numemp := Convert( slices, 87 );
            rec.othded1 := Convert( slices, 88 );
            rec.othded2 := Convert( slices, 89 );
            rec.othded3 := Convert( slices, 90 );
            rec.othded4 := Convert( slices, 91 );
            rec.othded5 := Convert( slices, 92 );
            rec.othded6 := Convert( slices, 93 );
            rec.othded7 := Convert( slices, 94 );
            rec.othded8 := Convert( slices, 95 );
            rec.othded9 := Convert( slices, 96 );
            rec.ownamt := Convert( slices, 97 );
            rec.ownotamt := Convert( slices, 98 );
            rec.ownother := Convert( slices, 99 );
            rec.ownsum := Convert( slices, 100 );
            rec.paperiod := Convert( slices, 101 );
            rec.payamt := Convert( slices, 102 );
            rec.paydat := Convert( slices, 103 );
            rec.paye := Convert( slices, 104 );
            rec.paypd := Convert( slices, 105 );
            rec.payslip := Convert( slices, 106 );
            rec.payusl := Convert( slices, 107 );
            rec.pothr := Convert( slices, 108 );
            rec.ppperiod := Convert( slices, 109 );
            rec.prbefore := Convert( slices, 110 );
            rec.profdocs := Convert( slices, 111 );
            rec.profit1 := Convert( slices, 112 );
            rec.profit2 := Convert( slices, 113 );
            rec.profni := Convert( slices, 114 );
            rec.proftax := Convert( slices, 115 );
            rec.rspoth := Convert( slices, 116 );
            rec.sapamt := Convert( slices, 117 );
            rec.se1 := Convert( slices, 118 );
            rec.se2 := Convert( slices, 119 );
            rec.seend := Convert( slices, 120 );
            rec.seincamt := Convert( slices, 121 );
            rec.seincwm := Convert( slices, 122 );
            rec.selwks := Convert( slices, 123 );
            rec.seniiamt := Convert( slices, 124 );
            rec.seniinc := Convert( slices, 125 );
            rec.senilamt := Convert( slices, 126 );
            rec.senilump := Convert( slices, 127 );
            rec.seniramt := Convert( slices, 128 );
            rec.senireg := Convert( slices, 129 );
            rec.senirpd := Convert( slices, 130 );
            rec.setax := Convert( slices, 131 );
            rec.setaxamt := Convert( slices, 132 );
            rec.smpamt := Convert( slices, 133 );
            rec.smprate := Convert( slices, 134 );
            rec.sole := Convert( slices, 135 );
            rec.sppamt := Convert( slices, 136 );
            rec.sspamt := Convert( slices, 137 );
            rec.taxamt := Convert( slices, 138 );
            rec.taxdamt := Convert( slices, 139 );
            rec.taxdpd := Convert( slices, 140 );
            rec.totus1 := Convert( slices, 141 );
            rec.ubonamt := Convert( slices, 142 );
            rec.uboninc := Convert( slices, 143 );
            rec.udeduc1 := Convert( slices, 144 );
            rec.udeduc2 := Convert( slices, 145 );
            rec.udeduc3 := Convert( slices, 146 );
            rec.udeduc4 := Convert( slices, 147 );
            rec.udeduc5 := Convert( slices, 148 );
            rec.udeduc6 := Convert( slices, 149 );
            rec.udeduc7 := Convert( slices, 150 );
            rec.udeduc8 := Convert( slices, 151 );
            rec.ugross := Convert( slices, 152 );
            rec.uincpay1 := Convert( slices, 153 );
            rec.uincpay2 := Convert( slices, 154 );
            rec.uincpay3 := Convert( slices, 155 );
            rec.uincpay4 := Convert( slices, 156 );
            rec.uincpay5 := Convert( slices, 157 );
            rec.uincpay6 := Convert( slices, 158 );
            rec.uincpay7 := Convert( slices, 159 );
            rec.uincpay8 := Convert( slices, 160 );
            rec.umileamt := Convert( slices, 161 );
            rec.umotamt := Convert( slices, 162 );
            rec.unett := Convert( slices, 163 );
            rec.uothded1 := Convert( slices, 164 );
            rec.uothded2 := Convert( slices, 165 );
            rec.uothded3 := Convert( slices, 166 );
            rec.uothded4 := Convert( slices, 167 );
            rec.uothded5 := Convert( slices, 168 );
            rec.uothded6 := Convert( slices, 169 );
            rec.uothded7 := Convert( slices, 170 );
            rec.uothded8 := Convert( slices, 171 );
            rec.uothded9 := Convert( slices, 172 );
            rec.uothdtot := Convert( slices, 173 );
            rec.uothr := Convert( slices, 174 );
            rec.upd := Convert( slices, 175 );
            rec.usapamt := Convert( slices, 176 );
            rec.usmpamt := Convert( slices, 177 );
            rec.usmprate := Convert( slices, 178 );
            rec.usppamt := Convert( slices, 179 );
            rec.usspamt := Convert( slices, 180 );
            rec.usuhr := Convert( slices, 181 );
            rec.utaxamt := Convert( slices, 182 );
            rec.watdid := Convert( slices, 183 );
            rec.watprev := Convert( slices, 184 );
            rec.where := Convert( slices, 185 );
            rec.whynopro := Convert( slices, 186 );
            rec.whynou01 := Convert( slices, 187 );
            rec.whynou02 := Convert( slices, 188 );
            rec.whynou03 := Convert( slices, 189 );
            rec.whynou04 := Convert( slices, 190 );
            rec.whynou05 := Convert( slices, 191 );
            rec.whynou06 := Convert( slices, 192 );
            rec.whynou07 := Convert( slices, 193 );
            rec.whynou08 := Convert( slices, 194 );
            rec.whynou09 := Convert( slices, 195 );
            rec.whynou10 := Convert( slices, 196 );
            rec.whynou11 := Convert( slices, 197 );
            rec.workacc := Convert( slices, 198 );
            rec.workmth := Convert( slices, 199 );
            rec.workyr := Convert( slices, 200 );
            rec.month := Convert( slices, 201 );
            rec.hdqhrs := Convert( slices, 202 );
            rec.jobhours := Convert( slices, 203 );
            rec.sspsmpfg := Convert( slices, 204 );
            rec.ugrspay := Convert( slices, 205 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0405;


   procedure Create_Maint_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.m := Convert( slices, 5 );
            rec.mrage := Convert( slices, 6 );
            rec.mramt := Convert( slices, 7 );
            rec.mrchwhy1 := Convert( slices, 8 );
            rec.mrchwhy2 := Convert( slices, 9 );
            rec.mrchwhy3 := Convert( slices, 10 );
            rec.mrchwhy4 := Convert( slices, 11 );
            rec.mrchwhy5 := Convert( slices, 12 );
            rec.mrchwhy6 := Convert( slices, 13 );
            rec.mrchwhy7 := Convert( slices, 14 );
            rec.mrchwhy8 := Convert( slices, 15 );
            rec.mrchwhy9 := Convert( slices, 16 );
            rec.mrct := Convert( slices, 17 );
            rec.mrkid := Convert( slices, 18 );
            rec.mrpd := Convert( slices, 19 );
            rec.mrr := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0405;


   procedure Create_MortCont_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.outsamt := Convert( slices, 4 );
            rec.outsincl := Convert( slices, 5 );
            rec.outspay := Convert( slices, 6 );
            rec.outspd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0405;


   procedure Create_Mortgage_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.loan2y := Convert( slices, 31 );
            rec.loanyear := Convert( slices, 32 );
            rec.menpol := Convert( slices, 33 );
            rec.morall := Convert( slices, 34 );
            rec.morflc := Convert( slices, 35 );
            rec.morinpay := Convert( slices, 36 );
            rec.morinpd := Convert( slices, 37 );
            rec.morinus := Convert( slices, 38 );
            rec.mortend := Convert( slices, 39 );
            rec.mortleft := Convert( slices, 40 );
            rec.mortprot := Convert( slices, 41 );
            rec.morttype := Convert( slices, 42 );
            rec.morupd := Convert( slices, 43 );
            rec.morus := Convert( slices, 44 );
            rec.mpcover1 := Convert( slices, 45 );
            rec.mpcover2 := Convert( slices, 46 );
            rec.mpcover3 := Convert( slices, 47 );
            rec.mpolno := Convert( slices, 48 );
            rec.outsmort := Convert( slices, 49 );
            rec.rentfrom := Convert( slices, 50 );
            rec.rmamt := Convert( slices, 51 );
            rec.rmort := Convert( slices, 52 );
            rec.rmortyr := Convert( slices, 53 );
            rec.rmpur001 := Convert( slices, 54 );
            rec.rmpur002 := Convert( slices, 55 );
            rec.rmpur003 := Convert( slices, 56 );
            rec.rmpur004 := Convert( slices, 57 );
            rec.rmpur005 := Convert( slices, 58 );
            rec.rmpur006 := Convert( slices, 59 );
            rec.rmpur007 := Convert( slices, 60 );
            rec.rmpur008 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0405;


   procedure Create_OddJob_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.ojamt := Convert( slices, 6 );
            rec.ojnow := Convert( slices, 7 );
            rec.ojreg := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0405;


   procedure Create_Owner_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.othmort1 := Convert( slices, 3 );
            rec.othmort2 := Convert( slices, 4 );
            rec.othmort3 := Convert( slices, 5 );
            rec.othpur1 := Convert( slices, 6 );
            rec.othpur2 := Convert( slices, 7 );
            rec.othpur3 := Convert( slices, 8 );
            rec.othpur31 := Convert( slices, 9 );
            rec.othpur32 := Convert( slices, 10 );
            rec.othpur33 := Convert( slices, 11 );
            rec.othpur34 := Convert( slices, 12 );
            rec.othpur35 := Convert( slices, 13 );
            rec.othpur36 := Convert( slices, 14 );
            rec.othpur37 := Convert( slices, 15 );
            rec.othpur4 := Convert( slices, 16 );
            rec.othpur5 := Convert( slices, 17 );
            rec.othpur6 := Convert( slices, 18 );
            rec.othpur7 := Convert( slices, 19 );
            rec.purcamt := Convert( slices, 20 );
            rec.purcloan := Convert( slices, 21 );
            rec.month := Convert( slices, 22 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0405;


   procedure Create_PenAmt_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.penq := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0405;


   procedure Create_PenProv_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppay := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eplong := Convert( slices, 6 );
            rec.eptype := Convert( slices, 7 );
            rec.keeppen := Convert( slices, 8 );
            rec.opgov := Convert( slices, 9 );
            rec.penamt := Convert( slices, 10 );
            rec.penamtpd := Convert( slices, 11 );
            rec.pencon := Convert( slices, 12 );
            rec.pendat := Convert( slices, 13 );
            rec.pengov := Convert( slices, 14 );
            rec.penhelp := Convert( slices, 15 );
            rec.penmort := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0405;


   procedure Create_Pension_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.penoth := Convert( slices, 6 );
            rec.penpay := Convert( slices, 7 );
            rec.penpd := Convert( slices, 8 );
            rec.pentax := Convert( slices, 9 );
            rec.pentype := Convert( slices, 10 );
            rec.poamt := Convert( slices, 11 );
            rec.poinc := Convert( slices, 12 );
            rec.posour := Convert( slices, 13 );
            rec.ptamt := Convert( slices, 14 );
            rec.ptinc := Convert( slices, 15 );
            rec.trights := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0405;


   procedure Create_RentCont_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0405;


   procedure Create_Renter_0405( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbweeks := Convert( slices, 28 );
            rec.hbyears := Convert( slices, 29 );
            rec.landlord := Convert( slices, 30 );
            rec.lowshort := Convert( slices, 31 );
            rec.niystart := Convert( slices, 32 );
            rec.othtype := Convert( slices, 33 );
            rec.rebate := Convert( slices, 34 );
            rec.rent := Convert( slices, 35 );
            rec.rentdk := Convert( slices, 36 );
            rec.rentdoc := Convert( slices, 37 );
            rec.rentfull := Convert( slices, 38 );
            rec.renthol := Convert( slices, 39 );
            rec.rentpd := Convert( slices, 40 );
            rec.resll := Convert( slices, 41 );
            rec.resll2 := Convert( slices, 42 );
            rec.serinc1 := Convert( slices, 43 );
            rec.serinc2 := Convert( slices, 44 );
            rec.serinc3 := Convert( slices, 45 );
            rec.serinc4 := Convert( slices, 46 );
            rec.serinc5 := Convert( slices, 47 );
            rec.tentype := Convert( slices, 48 );
            rec.weekhol := Convert( slices, 49 );
            rec.wsinc := Convert( slices, 50 );
            rec.wsincamt := Convert( slices, 51 );
            rec.ystartr := Convert( slices, 52 );
            rec.month := Convert( slices, 53 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0405;


   procedure Create_Account_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.nsamt := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0506;


   procedure Create_Admin_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.ncr1 := Convert( slices, 5 );
            rec.ncr2 := Convert( slices, 6 );
            rec.ncr3 := Convert( slices, 7 );
            rec.ncr4 := Convert( slices, 8 );
            rec.ncr5 := Convert( slices, 9 );
            rec.ncr6 := Convert( slices, 10 );
            rec.ncr7 := Convert( slices, 11 );
            rec.refr01 := Convert( slices, 12 );
            rec.refr02 := Convert( slices, 13 );
            rec.refr03 := Convert( slices, 14 );
            rec.refr04 := Convert( slices, 15 );
            rec.refr05 := Convert( slices, 16 );
            rec.refr06 := Convert( slices, 17 );
            rec.refr07 := Convert( slices, 18 );
            rec.refr08 := Convert( slices, 19 );
            rec.refr09 := Convert( slices, 20 );
            rec.refr10 := Convert( slices, 21 );
            rec.refr11 := Convert( slices, 22 );
            rec.refr12 := Convert( slices, 23 );
            rec.refr13 := Convert( slices, 24 );
            rec.refr14 := Convert( slices, 25 );
            rec.refr15 := Convert( slices, 26 );
            rec.refr16 := Convert( slices, 27 );
            rec.refr17 := Convert( slices, 28 );
            rec.refr18 := Convert( slices, 29 );
            rec.tnc := Convert( slices, 30 );
            rec.version := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0506;


   procedure Create_Adult_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.allow1 := Convert( slices, 21 );
            rec.allow2 := Convert( slices, 22 );
            rec.allow3 := Convert( slices, 23 );
            rec.allow4 := Convert( slices, 24 );
            rec.allpay1 := Convert( slices, 25 );
            rec.allpay2 := Convert( slices, 26 );
            rec.allpay3 := Convert( slices, 27 );
            rec.allpay4 := Convert( slices, 28 );
            rec.allpd1 := Convert( slices, 29 );
            rec.allpd2 := Convert( slices, 30 );
            rec.allpd3 := Convert( slices, 31 );
            rec.allpd4 := Convert( slices, 32 );
            rec.anyacc := Convert( slices, 33 );
            rec.anyed := Convert( slices, 34 );
            rec.anymon := Convert( slices, 35 );
            rec.anypen1 := Convert( slices, 36 );
            rec.anypen2 := Convert( slices, 37 );
            rec.anypen3 := Convert( slices, 38 );
            rec.anypen4 := Convert( slices, 39 );
            rec.anypen5 := Convert( slices, 40 );
            rec.anypen6 := Convert( slices, 41 );
            rec.anypen7 := Convert( slices, 42 );
            rec.apamt := Convert( slices, 43 );
            rec.apdamt := Convert( slices, 44 );
            rec.apdir := Convert( slices, 45 );
            rec.apdpd := Convert( slices, 46 );
            rec.appd := Convert( slices, 47 );
            rec.b2qfut1 := Convert( slices, 48 );
            rec.b2qfut2 := Convert( slices, 49 );
            rec.b2qfut3 := Convert( slices, 50 );
            rec.b3qfut1 := Convert( slices, 51 );
            rec.b3qfut2 := Convert( slices, 52 );
            rec.b3qfut3 := Convert( slices, 53 );
            rec.b3qfut4 := Convert( slices, 54 );
            rec.b3qfut5 := Convert( slices, 55 );
            rec.b3qfut6 := Convert( slices, 56 );
            rec.ben1q1 := Convert( slices, 57 );
            rec.ben1q2 := Convert( slices, 58 );
            rec.ben1q3 := Convert( slices, 59 );
            rec.ben1q4 := Convert( slices, 60 );
            rec.ben1q5 := Convert( slices, 61 );
            rec.ben1q6 := Convert( slices, 62 );
            rec.ben1q7 := Convert( slices, 63 );
            rec.ben2q1 := Convert( slices, 64 );
            rec.ben2q2 := Convert( slices, 65 );
            rec.ben2q3 := Convert( slices, 66 );
            rec.ben3q1 := Convert( slices, 67 );
            rec.ben3q2 := Convert( slices, 68 );
            rec.ben3q3 := Convert( slices, 69 );
            rec.ben3q4 := Convert( slices, 70 );
            rec.ben3q5 := Convert( slices, 71 );
            rec.ben3q6 := Convert( slices, 72 );
            rec.ben4q1 := Convert( slices, 73 );
            rec.ben4q2 := Convert( slices, 74 );
            rec.ben4q3 := Convert( slices, 75 );
            rec.ben5q1 := Convert( slices, 76 );
            rec.ben5q2 := Convert( slices, 77 );
            rec.ben5q3 := Convert( slices, 78 );
            rec.ben5q4 := Convert( slices, 79 );
            rec.ben5q5 := Convert( slices, 80 );
            rec.ben5q6 := Convert( slices, 81 );
            rec.ben5q7 := Convert( slices, 82 );
            rec.ben5q8 := Convert( slices, 83 );
            rec.ben5q9 := Convert( slices, 84 );
            rec.ben7q1 := Convert( slices, 85 );
            rec.ben7q2 := Convert( slices, 86 );
            rec.ben7q3 := Convert( slices, 87 );
            rec.ben7q4 := Convert( slices, 88 );
            rec.ben7q5 := Convert( slices, 89 );
            rec.ben7q6 := Convert( slices, 90 );
            rec.ben7q7 := Convert( slices, 91 );
            rec.ben7q8 := Convert( slices, 92 );
            rec.ben7q9 := Convert( slices, 93 );
            rec.btwacc := Convert( slices, 94 );
            rec.claimant := Convert( slices, 95 );
            rec.cohabit := Convert( slices, 96 );
            rec.combid := Convert( slices, 97 );
            rec.convbl := Convert( slices, 98 );
            rec.ctclum1 := Convert( slices, 99 );
            rec.ctclum2 := Convert( slices, 100 );
            rec.cupchk := Convert( slices, 101 );
            rec.cvht := Convert( slices, 102 );
            rec.cvpay := Convert( slices, 103 );
            rec.cvpd := Convert( slices, 104 );
            rec.ddatre := Convert( slices, 105 );
            rec.ddatrep := Convert( slices, 106 );
            rec.defrpen := Convert( slices, 107 );
            rec.dentist := Convert( slices, 108 );
            rec.depend := Convert( slices, 109 );
            rec.disdif1 := Convert( slices, 110 );
            rec.disdif2 := Convert( slices, 111 );
            rec.disdif3 := Convert( slices, 112 );
            rec.disdif4 := Convert( slices, 113 );
            rec.disdif5 := Convert( slices, 114 );
            rec.disdif6 := Convert( slices, 115 );
            rec.disdif7 := Convert( slices, 116 );
            rec.disdif8 := Convert( slices, 117 );
            rec.disdif9 := Convert( slices, 118 );
            rec.disdifp := Convert( slices, 119 );
            rec.dob := Convert( slices, 120 );
            rec.dvil03a := Convert( slices, 121 );
            rec.dvil04a := Convert( slices, 122 );
            rec.dvjb12ml := Convert( slices, 123 );
            rec.dvmardf := Convert( slices, 124 );
            rec.ed1amt := Convert( slices, 125 );
            rec.ed1borr := Convert( slices, 126 );
            rec.ed1int := Convert( slices, 127 );
            rec.ed1monyr := Convert( slices, 128 );
            rec.ed1pd := Convert( slices, 129 );
            rec.ed1sum := Convert( slices, 130 );
            rec.ed2amt := Convert( slices, 131 );
            rec.ed2borr := Convert( slices, 132 );
            rec.ed2int := Convert( slices, 133 );
            rec.ed2monyr := Convert( slices, 134 );
            rec.ed2pd := Convert( slices, 135 );
            rec.ed2sum := Convert( slices, 136 );
            rec.edatt := Convert( slices, 137 );
            rec.edattn1 := Convert( slices, 138 );
            rec.edattn2 := Convert( slices, 139 );
            rec.edattn3 := Convert( slices, 140 );
            rec.edhr := Convert( slices, 141 );
            rec.edtime := Convert( slices, 142 );
            rec.edtyp := Convert( slices, 143 );
            rec.eligadlt := Convert( slices, 144 );
            rec.eligchld := Convert( slices, 145 );
            rec.emppay1 := Convert( slices, 146 );
            rec.emppay2 := Convert( slices, 147 );
            rec.emppay3 := Convert( slices, 148 );
            rec.empstat := Convert( slices, 149 );
            rec.endyr := Convert( slices, 150 );
            rec.epcur := Convert( slices, 151 );
            rec.es2000 := Convert( slices, 152 );
            rec.ethgrp := Convert( slices, 153 );
            rec.everwrk := Convert( slices, 154 );
            rec.exthbct1 := Convert( slices, 155 );
            rec.exthbct2 := Convert( slices, 156 );
            rec.exthbct3 := Convert( slices, 157 );
            rec.eyetest := Convert( slices, 158 );
            rec.followup := Convert( slices, 159 );
            rec.fted := Convert( slices, 160 );
            rec.ftwk := Convert( slices, 161 );
            rec.govpis := Convert( slices, 162 );
            rec.govpjsa := Convert( slices, 163 );
            rec.grant := Convert( slices, 164 );
            rec.grtamt1 := Convert( slices, 165 );
            rec.grtamt2 := Convert( slices, 166 );
            rec.grtdir1 := Convert( slices, 167 );
            rec.grtdir2 := Convert( slices, 168 );
            rec.grtnum := Convert( slices, 169 );
            rec.grtsce1 := Convert( slices, 170 );
            rec.grtsce2 := Convert( slices, 171 );
            rec.grtval1 := Convert( slices, 172 );
            rec.grtval2 := Convert( slices, 173 );
            rec.gta := Convert( slices, 174 );
            rec.hbothamt := Convert( slices, 175 );
            rec.hbothbu := Convert( slices, 176 );
            rec.hbothpd := Convert( slices, 177 );
            rec.hbothwk := Convert( slices, 178 );
            rec.hbotwait := Convert( slices, 179 );
            rec.health := Convert( slices, 180 );
            rec.hholder := Convert( slices, 181 );
            rec.hosp := Convert( slices, 182 );
            rec.hprob := Convert( slices, 183 );
            rec.hrpid := Convert( slices, 184 );
            rec.incdur := Convert( slices, 185 );
            rec.injlong := Convert( slices, 186 );
            rec.injwk := Convert( slices, 187 );
            rec.invests := Convert( slices, 188 );
            rec.iout := Convert( slices, 189 );
            rec.isa1type := Convert( slices, 190 );
            rec.isa2type := Convert( slices, 191 );
            rec.jobaway := Convert( slices, 192 );
            rec.lareg := Convert( slices, 193 );
            rec.likewk := Convert( slices, 194 );
            rec.lktime := Convert( slices, 195 );
            rec.ln1rpint := Convert( slices, 196 );
            rec.ln2rpint := Convert( slices, 197 );
            rec.loan := Convert( slices, 198 );
            rec.loannum := Convert( slices, 199 );
            rec.look := Convert( slices, 200 );
            rec.lookwk := Convert( slices, 201 );
            rec.lstwrk1 := Convert( slices, 202 );
            rec.lstwrk2 := Convert( slices, 203 );
            rec.lstyr := Convert( slices, 204 );
            rec.mntamt1 := Convert( slices, 205 );
            rec.mntamt2 := Convert( slices, 206 );
            rec.mntct := Convert( slices, 207 );
            rec.mntfor1 := Convert( slices, 208 );
            rec.mntfor2 := Convert( slices, 209 );
            rec.mntgov1 := Convert( slices, 210 );
            rec.mntgov2 := Convert( slices, 211 );
            rec.mntpay := Convert( slices, 212 );
            rec.mntpd1 := Convert( slices, 213 );
            rec.mntpd2 := Convert( slices, 214 );
            rec.mntrec := Convert( slices, 215 );
            rec.mnttota1 := Convert( slices, 216 );
            rec.mnttota2 := Convert( slices, 217 );
            rec.mntus1 := Convert( slices, 218 );
            rec.mntus2 := Convert( slices, 219 );
            rec.mntusam1 := Convert( slices, 220 );
            rec.mntusam2 := Convert( slices, 221 );
            rec.mntuspd1 := Convert( slices, 222 );
            rec.mntuspd2 := Convert( slices, 223 );
            rec.ms := Convert( slices, 224 );
            rec.natid1 := Convert( slices, 225 );
            rec.natid2 := Convert( slices, 226 );
            rec.natid3 := Convert( slices, 227 );
            rec.natid4 := Convert( slices, 228 );
            rec.natid5 := Convert( slices, 229 );
            rec.natid6 := Convert( slices, 230 );
            rec.ndeal := Convert( slices, 231 );
            rec.newdtype := Convert( slices, 232 );
            rec.nhs1 := Convert( slices, 233 );
            rec.nhs2 := Convert( slices, 234 );
            rec.nhs3 := Convert( slices, 235 );
            rec.niamt := Convert( slices, 236 );
            rec.niethgrp := Convert( slices, 237 );
            rec.niexthbb := Convert( slices, 238 );
            rec.ninatid1 := Convert( slices, 239 );
            rec.ninatid2 := Convert( slices, 240 );
            rec.ninatid3 := Convert( slices, 241 );
            rec.ninatid4 := Convert( slices, 242 );
            rec.ninatid5 := Convert( slices, 243 );
            rec.ninatid6 := Convert( slices, 244 );
            rec.ninatid7 := Convert( slices, 245 );
            rec.ninatid8 := Convert( slices, 246 );
            rec.nipd := Convert( slices, 247 );
            rec.nireg := Convert( slices, 248 );
            rec.nirel := Convert( slices, 249 );
            rec.nitrain := Convert( slices, 250 );
            rec.nlper := Convert( slices, 251 );
            rec.nolk1 := Convert( slices, 252 );
            rec.nolk2 := Convert( slices, 253 );
            rec.nolk3 := Convert( slices, 254 );
            rec.nolook := Convert( slices, 255 );
            rec.nowant := Convert( slices, 256 );
            rec.nssec := Convert( slices, 257 );
            rec.ntcdat := Convert( slices, 258 );
            rec.ntcinc := Convert( slices, 259 );
            rec.numjob := Convert( slices, 260 );
            rec.numjob2 := Convert( slices, 261 );
            rec.oddjob := Convert( slices, 262 );
            rec.oldstud := Convert( slices, 263 );
            rec.otabspar := Convert( slices, 264 );
            rec.otamt := Convert( slices, 265 );
            rec.otapamt := Convert( slices, 266 );
            rec.otappd := Convert( slices, 267 );
            rec.othtax := Convert( slices, 268 );
            rec.otinva := Convert( slices, 269 );
            rec.pareamt := Convert( slices, 270 );
            rec.parepd := Convert( slices, 271 );
            rec.penlump := Convert( slices, 272 );
            rec.ppnumc := Convert( slices, 273 );
            rec.practice := Convert( slices, 274 );
            rec.prit := Convert( slices, 275 );
            rec.prscrpt := Convert( slices, 276 );
            rec.ptwk := Convert( slices, 277 );
            rec.r01 := Convert( slices, 278 );
            rec.r02 := Convert( slices, 279 );
            rec.r03 := Convert( slices, 280 );
            rec.r04 := Convert( slices, 281 );
            rec.r05 := Convert( slices, 282 );
            rec.r06 := Convert( slices, 283 );
            rec.r07 := Convert( slices, 284 );
            rec.r08 := Convert( slices, 285 );
            rec.r09 := Convert( slices, 286 );
            rec.r10 := Convert( slices, 287 );
            rec.r11 := Convert( slices, 288 );
            rec.r12 := Convert( slices, 289 );
            rec.r13 := Convert( slices, 290 );
            rec.r14 := Convert( slices, 291 );
            rec.redamt := Convert( slices, 292 );
            rec.redany := Convert( slices, 293 );
            rec.rentprof := Convert( slices, 294 );
            rec.retire := Convert( slices, 295 );
            rec.retire1 := Convert( slices, 296 );
            rec.retreas := Convert( slices, 297 );
            rec.royal1 := Convert( slices, 298 );
            rec.royal2 := Convert( slices, 299 );
            rec.royal3 := Convert( slices, 300 );
            rec.royal4 := Convert( slices, 301 );
            rec.royyr1 := Convert( slices, 302 );
            rec.royyr2 := Convert( slices, 303 );
            rec.royyr3 := Convert( slices, 304 );
            rec.royyr4 := Convert( slices, 305 );
            rec.rstrct := Convert( slices, 306 );
            rec.sex := Convert( slices, 307 );
            rec.sflntyp1 := Convert( slices, 308 );
            rec.sflntyp2 := Convert( slices, 309 );
            rec.sfrpis := Convert( slices, 310 );
            rec.sfrpjsa := Convert( slices, 311 );
            rec.sftype1 := Convert( slices, 312 );
            rec.sftype2 := Convert( slices, 313 );
            rec.sic := Convert( slices, 314 );
            rec.slrepamt := Convert( slices, 315 );
            rec.slrepay := Convert( slices, 316 );
            rec.slreppd := Convert( slices, 317 );
            rec.soc2000 := Convert( slices, 318 );
            rec.spcreg1 := Convert( slices, 319 );
            rec.spcreg2 := Convert( slices, 320 );
            rec.spcreg3 := Convert( slices, 321 );
            rec.specs := Convert( slices, 322 );
            rec.spout := Convert( slices, 323 );
            rec.srentamt := Convert( slices, 324 );
            rec.srentpd := Convert( slices, 325 );
            rec.start := Convert( slices, 326 );
            rec.startyr := Convert( slices, 327 );
            rec.taxcred1 := Convert( slices, 328 );
            rec.taxcred2 := Convert( slices, 329 );
            rec.taxfut := Convert( slices, 330 );
            rec.tdaywrk := Convert( slices, 331 );
            rec.tea := Convert( slices, 332 );
            rec.topupl := Convert( slices, 333 );
            rec.totint := Convert( slices, 334 );
            rec.train := Convert( slices, 335 );
            rec.trav := Convert( slices, 336 );
            rec.tuborr := Convert( slices, 337 );
            rec.typeed := Convert( slices, 338 );
            rec.unpaid1 := Convert( slices, 339 );
            rec.unpaid2 := Convert( slices, 340 );
            rec.voucher := Convert( slices, 341 );
            rec.w1 := Convert( slices, 342 );
            rec.w2 := Convert( slices, 343 );
            rec.wait := Convert( slices, 344 );
            rec.war1 := Convert( slices, 345 );
            rec.war2 := Convert( slices, 346 );
            rec.whoresp := Convert( slices, 347 );
            rec.whosectb := Convert( slices, 348 );
            rec.whyfrde1 := Convert( slices, 349 );
            rec.whyfrde2 := Convert( slices, 350 );
            rec.whyfrde3 := Convert( slices, 351 );
            rec.whyfrde4 := Convert( slices, 352 );
            rec.whyfrde5 := Convert( slices, 353 );
            rec.whyfrde6 := Convert( slices, 354 );
            rec.whyfrey1 := Convert( slices, 355 );
            rec.whyfrey2 := Convert( slices, 356 );
            rec.whyfrey3 := Convert( slices, 357 );
            rec.whyfrey4 := Convert( slices, 358 );
            rec.whyfrey5 := Convert( slices, 359 );
            rec.whyfrey6 := Convert( slices, 360 );
            rec.whyfrpr1 := Convert( slices, 361 );
            rec.whyfrpr2 := Convert( slices, 362 );
            rec.whyfrpr3 := Convert( slices, 363 );
            rec.whyfrpr4 := Convert( slices, 364 );
            rec.whyfrpr5 := Convert( slices, 365 );
            rec.whyfrpr6 := Convert( slices, 366 );
            rec.whytrav1 := Convert( slices, 367 );
            rec.whytrav2 := Convert( slices, 368 );
            rec.whytrav3 := Convert( slices, 369 );
            rec.whytrav4 := Convert( slices, 370 );
            rec.whytrav5 := Convert( slices, 371 );
            rec.whytrav6 := Convert( slices, 372 );
            rec.wintfuel := Convert( slices, 373 );
            rec.wmkit := Convert( slices, 374 );
            rec.working := Convert( slices, 375 );
            rec.wpa := Convert( slices, 376 );
            rec.wpba := Convert( slices, 377 );
            rec.wtclum1 := Convert( slices, 378 );
            rec.wtclum2 := Convert( slices, 379 );
            rec.wtclum3 := Convert( slices, 380 );
            rec.ystrtwk := Convert( slices, 381 );
            rec.month := Convert( slices, 382 );
            rec.able := Convert( slices, 383 );
            rec.actacci := Convert( slices, 384 );
            rec.addda := Convert( slices, 385 );
            rec.age80 := Convert( slices, 386 );
            rec.basacti := Convert( slices, 387 );
            rec.bntxcred := Convert( slices, 388 );
            rec.careab := Convert( slices, 389 );
            rec.careah := Convert( slices, 390 );
            rec.carecb := Convert( slices, 391 );
            rec.carech := Convert( slices, 392 );
            rec.carecl := Convert( slices, 393 );
            rec.carefl := Convert( slices, 394 );
            rec.carefr := Convert( slices, 395 );
            rec.careot := Convert( slices, 396 );
            rec.carere := Convert( slices, 397 );
            rec.chbflg := Convert( slices, 398 );
            rec.crunaci := Convert( slices, 399 );
            rec.curacti := Convert( slices, 400 );
            rec.empoccp := Convert( slices, 401 );
            rec.empstatb := Convert( slices, 402 );
            rec.empstatc := Convert( slices, 403 );
            rec.empstati := Convert( slices, 404 );
            rec.enomorti := Convert( slices, 405 );
            rec.ethgr2 := Convert( slices, 406 );
            rec.fsbndcti := Convert( slices, 407 );
            rec.fwmlkval := Convert( slices, 408 );
            rec.gebacti := Convert( slices, 409 );
            rec.giltcti := Convert( slices, 410 );
            rec.gross3 := Convert( slices, 411 );
            rec.hdage := Convert( slices, 412 );
            rec.hdben := Convert( slices, 413 );
            rec.hdindinc := Convert( slices, 414 );
            rec.hourab := Convert( slices, 415 );
            rec.hourah := Convert( slices, 416 );
            rec.hourcare := Convert( slices, 417 );
            rec.hourcb := Convert( slices, 418 );
            rec.hourch := Convert( slices, 419 );
            rec.hourcl := Convert( slices, 420 );
            rec.hourfr := Convert( slices, 421 );
            rec.hourot := Convert( slices, 422 );
            rec.hourre := Convert( slices, 423 );
            rec.hourtot := Convert( slices, 424 );
            rec.hperson := Convert( slices, 425 );
            rec.iagegr2 := Convert( slices, 426 );
            rec.iagegrp := Convert( slices, 427 );
            rec.incseo2 := Convert( slices, 428 );
            rec.indinc := Convert( slices, 429 );
            rec.indisben := Convert( slices, 430 );
            rec.inearns := Convert( slices, 431 );
            rec.ininv := Convert( slices, 432 );
            rec.inirben := Convert( slices, 433 );
            rec.innirben := Convert( slices, 434 );
            rec.inothben := Convert( slices, 435 );
            rec.inpeninc := Convert( slices, 436 );
            rec.inrinc := Convert( slices, 437 );
            rec.inrpinc := Convert( slices, 438 );
            rec.intvlic := Convert( slices, 439 );
            rec.intxcred := Convert( slices, 440 );
            rec.isacti := Convert( slices, 441 );
            rec.marital := Convert( slices, 442 );
            rec.nincseo2 := Convert( slices, 443 );
            rec.nindinc := Convert( slices, 444 );
            rec.ninearns := Convert( slices, 445 );
            rec.nininv := Convert( slices, 446 );
            rec.ninpenin := Convert( slices, 447 );
            rec.ninsein2 := Convert( slices, 448 );
            rec.nsbocti := Convert( slices, 449 );
            rec.occupnum := Convert( slices, 450 );
            rec.otbscti := Convert( slices, 451 );
            rec.pepscti := Convert( slices, 452 );
            rec.poaccti := Convert( slices, 453 );
            rec.pocardi := Convert( slices, 454 );
            rec.prbocti := Convert( slices, 455 );
            rec.relhrp := Convert( slices, 456 );
            rec.sapadj := Convert( slices, 457 );
            rec.sayecti := Convert( slices, 458 );
            rec.sclbcti := Convert( slices, 459 );
            rec.seincam2 := Convert( slices, 460 );
            rec.smpadj := Convert( slices, 461 );
            rec.sppadj := Convert( slices, 462 );
            rec.sscti := Convert( slices, 463 );
            rec.sspadj := Convert( slices, 464 );
            rec.stshcti := Convert( slices, 465 );
            rec.taxpayer := Convert( slices, 466 );
            rec.tesscti := Convert( slices, 467 );
            rec.totgrant := Convert( slices, 468 );
            rec.tothours := Convert( slices, 469 );
            rec.totoccp := Convert( slices, 470 );
            rec.ttwcosts := Convert( slices, 471 );
            rec.untrcti := Convert( slices, 472 );
            rec.uperson := Convert( slices, 473 );
            rec.widoccp := Convert( slices, 474 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0506;


   procedure Create_Asset_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0506;


   procedure Create_Benefit_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.notusamt := Convert( slices, 16 );
            rec.notuspd := Convert( slices, 17 );
            rec.numweeks := Convert( slices, 18 );
            rec.ordbkno := Convert( slices, 19 );
            rec.payslipb := Convert( slices, 20 );
            rec.pres := Convert( slices, 21 );
            rec.usual := Convert( slices, 22 );
            rec.var1 := Convert( slices, 23 );
            rec.var2 := Convert( slices, 24 );
            rec.var3 := Convert( slices, 25 );
            rec.whorec1 := Convert( slices, 26 );
            rec.whorec2 := Convert( slices, 27 );
            rec.whorec3 := Convert( slices, 28 );
            rec.whorec4 := Convert( slices, 29 );
            rec.whorec5 := Convert( slices, 30 );
            rec.month := Convert( slices, 31 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0506;


   procedure Create_Benunit_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.cdelply := Convert( slices, 13 );
            rec.cdepbed := Convert( slices, 14 );
            rec.cdepcel := Convert( slices, 15 );
            rec.cdepeqp := Convert( slices, 16 );
            rec.cdephol := Convert( slices, 17 );
            rec.cdeples := Convert( slices, 18 );
            rec.cdepsum := Convert( slices, 19 );
            rec.cdeptea := Convert( slices, 20 );
            rec.cdeptrp := Convert( slices, 21 );
            rec.cplay := Convert( slices, 22 );
            rec.debt1 := Convert( slices, 23 );
            rec.debt2 := Convert( slices, 24 );
            rec.debt3 := Convert( slices, 25 );
            rec.debt4 := Convert( slices, 26 );
            rec.debt5 := Convert( slices, 27 );
            rec.debt6 := Convert( slices, 28 );
            rec.debt7 := Convert( slices, 29 );
            rec.debt8 := Convert( slices, 30 );
            rec.debt9 := Convert( slices, 31 );
            rec.houshe1 := Convert( slices, 32 );
            rec.incchnge := Convert( slices, 33 );
            rec.inchilow := Convert( slices, 34 );
            rec.incold := Convert( slices, 35 );
            rec.kidinc := Convert( slices, 36 );
            rec.nhhchild := Convert( slices, 37 );
            rec.totsav := Convert( slices, 38 );
            rec.month := Convert( slices, 39 );
            rec.actaccb := Convert( slices, 40 );
            rec.adddabu := Convert( slices, 41 );
            rec.adultb := Convert( slices, 42 );
            rec.basactb := Convert( slices, 43 );
            rec.boarder := Convert( slices, 44 );
            rec.bpeninc := Convert( slices, 45 );
            rec.bseinc := Convert( slices, 46 );
            rec.buagegr2 := Convert( slices, 47 );
            rec.buagegrp := Convert( slices, 48 );
            rec.budisben := Convert( slices, 49 );
            rec.buearns := Convert( slices, 50 );
            rec.buethgr2 := Convert( slices, 51 );
            rec.buinc := Convert( slices, 52 );
            rec.buinv := Convert( slices, 53 );
            rec.buirben := Convert( slices, 54 );
            rec.bukids := Convert( slices, 55 );
            rec.bunirben := Convert( slices, 56 );
            rec.buothben := Convert( slices, 57 );
            rec.burent := Convert( slices, 58 );
            rec.burinc := Convert( slices, 59 );
            rec.burpinc := Convert( slices, 60 );
            rec.butvlic := Convert( slices, 61 );
            rec.butxcred := Convert( slices, 62 );
            rec.chddabu := Convert( slices, 63 );
            rec.crunacb := Convert( slices, 64 );
            rec.curactb := Convert( slices, 65 );
            rec.depchldb := Convert( slices, 66 );
            rec.depdeds := Convert( slices, 67 );
            rec.disindhb := Convert( slices, 68 );
            rec.ecotypbu := Convert( slices, 69 );
            rec.ecstatbu := Convert( slices, 70 );
            rec.enomortb := Convert( slices, 71 );
            rec.famthbai := Convert( slices, 72 );
            rec.famtypbs := Convert( slices, 73 );
            rec.famtypbu := Convert( slices, 74 );
            rec.famtype := Convert( slices, 75 );
            rec.fsbndctb := Convert( slices, 76 );
            rec.fsmbu := Convert( slices, 77 );
            rec.fsmlkbu := Convert( slices, 78 );
            rec.fwmlkbu := Convert( slices, 79 );
            rec.gebactb := Convert( slices, 80 );
            rec.giltctb := Convert( slices, 81 );
            rec.gross3 := Convert( slices, 82 );
            rec.hbindbu := Convert( slices, 83 );
            rec.hbindbu2 := Convert( slices, 84 );
            rec.isactb := Convert( slices, 85 );
            rec.kid04 := Convert( slices, 86 );
            rec.kid1115 := Convert( slices, 87 );
            rec.kid1618 := Convert( slices, 88 );
            rec.kid510 := Convert( slices, 89 );
            rec.lastwork := Convert( slices, 90 );
            rec.lodger := Convert( slices, 91 );
            rec.nsboctb := Convert( slices, 92 );
            rec.otbsctb := Convert( slices, 93 );
            rec.pepsctb := Convert( slices, 94 );
            rec.poacctb := Convert( slices, 95 );
            rec.pocardb := Convert( slices, 96 );
            rec.prboctb := Convert( slices, 97 );
            rec.sayectb := Convert( slices, 98 );
            rec.sclbctb := Convert( slices, 99 );
            rec.ssctb := Convert( slices, 100 );
            rec.stshctb := Convert( slices, 101 );
            rec.subltamt := Convert( slices, 102 );
            rec.tessctb := Convert( slices, 103 );
            rec.totcapbu := Convert( slices, 104 );
            rec.totsavbu := Convert( slices, 105 );
            rec.tuburent := Convert( slices, 106 );
            rec.untrctb := Convert( slices, 107 );
            rec.youngch := Convert( slices, 108 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0506;


   procedure Create_Care_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.wholoo01 := Convert( slices, 46 );
            rec.wholoo02 := Convert( slices, 47 );
            rec.wholoo03 := Convert( slices, 48 );
            rec.wholoo04 := Convert( slices, 49 );
            rec.wholoo05 := Convert( slices, 50 );
            rec.wholoo06 := Convert( slices, 51 );
            rec.wholoo07 := Convert( slices, 52 );
            rec.wholoo08 := Convert( slices, 53 );
            rec.wholoo09 := Convert( slices, 54 );
            rec.wholoo10 := Convert( slices, 55 );
            rec.wholoo11 := Convert( slices, 56 );
            rec.wholoo12 := Convert( slices, 57 );
            rec.wholoo13 := Convert( slices, 58 );
            rec.wholoo14 := Convert( slices, 59 );
            rec.wholoo15 := Convert( slices, 60 );
            rec.wholoo16 := Convert( slices, 61 );
            rec.wholoo17 := Convert( slices, 62 );
            rec.wholoo18 := Convert( slices, 63 );
            rec.wholoo19 := Convert( slices, 64 );
            rec.wholoo20 := Convert( slices, 65 );
            rec.month := Convert( slices, 66 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0506;


   procedure Create_Child_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddatre := Convert( slices, 7 );
            rec.cddatrep := Convert( slices, 8 );
            rec.cdisdif1 := Convert( slices, 9 );
            rec.cdisdif2 := Convert( slices, 10 );
            rec.cdisdif3 := Convert( slices, 11 );
            rec.cdisdif4 := Convert( slices, 12 );
            rec.cdisdif5 := Convert( slices, 13 );
            rec.cdisdif6 := Convert( slices, 14 );
            rec.cdisdif7 := Convert( slices, 15 );
            rec.cdisdif8 := Convert( slices, 16 );
            rec.cdisdif9 := Convert( slices, 17 );
            rec.cdisdifp := Convert( slices, 18 );
            rec.cfund := Convert( slices, 19 );
            rec.cfundh := Convert( slices, 20 );
            rec.cfundtp := Convert( slices, 21 );
            rec.chamtern := Convert( slices, 22 );
            rec.chamttst := Convert( slices, 23 );
            rec.chdla1 := Convert( slices, 24 );
            rec.chdla2 := Convert( slices, 25 );
            rec.chealth := Convert( slices, 26 );
            rec.chearns1 := Convert( slices, 27 );
            rec.chearns2 := Convert( slices, 28 );
            rec.chema := Convert( slices, 29 );
            rec.chemaamt := Convert( slices, 30 );
            rec.chemapd := Convert( slices, 31 );
            rec.chpdern := Convert( slices, 32 );
            rec.chpdtst := Convert( slices, 33 );
            rec.chprob := Convert( slices, 34 );
            rec.chsave := Convert( slices, 35 );
            rec.chwkern := Convert( slices, 36 );
            rec.chwktst := Convert( slices, 37 );
            rec.chyrern := Convert( slices, 38 );
            rec.chyrtst := Convert( slices, 39 );
            rec.cohabit := Convert( slices, 40 );
            rec.convbl := Convert( slices, 41 );
            rec.cvht := Convert( slices, 42 );
            rec.cvpay := Convert( slices, 43 );
            rec.cvpd := Convert( slices, 44 );
            rec.dentist := Convert( slices, 45 );
            rec.depend := Convert( slices, 46 );
            rec.dob := Convert( slices, 47 );
            rec.eligadlt := Convert( slices, 48 );
            rec.eligchld := Convert( slices, 49 );
            rec.endyr := Convert( slices, 50 );
            rec.eyetest := Convert( slices, 51 );
            rec.fted := Convert( slices, 52 );
            rec.fundamt1 := Convert( slices, 53 );
            rec.fundamt2 := Convert( slices, 54 );
            rec.fundamt3 := Convert( slices, 55 );
            rec.fundamt4 := Convert( slices, 56 );
            rec.fundamt5 := Convert( slices, 57 );
            rec.fundamt6 := Convert( slices, 58 );
            rec.givcfnd1 := Convert( slices, 59 );
            rec.givcfnd2 := Convert( slices, 60 );
            rec.givcfnd3 := Convert( slices, 61 );
            rec.givcfnd4 := Convert( slices, 62 );
            rec.givcfnd5 := Convert( slices, 63 );
            rec.givcfnd6 := Convert( slices, 64 );
            rec.grant := Convert( slices, 65 );
            rec.grtamt1 := Convert( slices, 66 );
            rec.grtamt2 := Convert( slices, 67 );
            rec.grtdir1 := Convert( slices, 68 );
            rec.grtdir2 := Convert( slices, 69 );
            rec.grtnum := Convert( slices, 70 );
            rec.grtsce1 := Convert( slices, 71 );
            rec.grtsce2 := Convert( slices, 72 );
            rec.grtval1 := Convert( slices, 73 );
            rec.grtval2 := Convert( slices, 74 );
            rec.hholder := Convert( slices, 75 );
            rec.hosp := Convert( slices, 76 );
            rec.lareg := Convert( slices, 77 );
            rec.legdep := Convert( slices, 78 );
            rec.ms := Convert( slices, 79 );
            rec.nhs1 := Convert( slices, 80 );
            rec.nhs2 := Convert( slices, 81 );
            rec.nhs3 := Convert( slices, 82 );
            rec.parent1 := Convert( slices, 83 );
            rec.parent2 := Convert( slices, 84 );
            rec.prit := Convert( slices, 85 );
            rec.prscrpt := Convert( slices, 86 );
            rec.r01 := Convert( slices, 87 );
            rec.r02 := Convert( slices, 88 );
            rec.r03 := Convert( slices, 89 );
            rec.r04 := Convert( slices, 90 );
            rec.r05 := Convert( slices, 91 );
            rec.r06 := Convert( slices, 92 );
            rec.r07 := Convert( slices, 93 );
            rec.r08 := Convert( slices, 94 );
            rec.r09 := Convert( slices, 95 );
            rec.r10 := Convert( slices, 96 );
            rec.r11 := Convert( slices, 97 );
            rec.r12 := Convert( slices, 98 );
            rec.r13 := Convert( slices, 99 );
            rec.r14 := Convert( slices, 100 );
            rec.sex := Convert( slices, 101 );
            rec.smkit := Convert( slices, 102 );
            rec.smlit := Convert( slices, 103 );
            rec.spcreg1 := Convert( slices, 104 );
            rec.spcreg2 := Convert( slices, 105 );
            rec.spcreg3 := Convert( slices, 106 );
            rec.specs := Convert( slices, 107 );
            rec.spout := Convert( slices, 108 );
            rec.srentamt := Convert( slices, 109 );
            rec.srentpd := Convert( slices, 110 );
            rec.startyr := Convert( slices, 111 );
            rec.totsave := Convert( slices, 112 );
            rec.trav := Convert( slices, 113 );
            rec.typeed := Convert( slices, 114 );
            rec.voucher := Convert( slices, 115 );
            rec.whytrav1 := Convert( slices, 116 );
            rec.whytrav2 := Convert( slices, 117 );
            rec.whytrav3 := Convert( slices, 118 );
            rec.whytrav4 := Convert( slices, 119 );
            rec.whytrav5 := Convert( slices, 120 );
            rec.whytrav6 := Convert( slices, 121 );
            rec.wmkit := Convert( slices, 122 );
            rec.month := Convert( slices, 123 );
            rec.careab := Convert( slices, 124 );
            rec.careah := Convert( slices, 125 );
            rec.carecb := Convert( slices, 126 );
            rec.carech := Convert( slices, 127 );
            rec.carecl := Convert( slices, 128 );
            rec.carefl := Convert( slices, 129 );
            rec.carefr := Convert( slices, 130 );
            rec.careot := Convert( slices, 131 );
            rec.carere := Convert( slices, 132 );
            rec.chdda := Convert( slices, 133 );
            rec.chearns := Convert( slices, 134 );
            rec.chincdv := Convert( slices, 135 );
            rec.chrinc := Convert( slices, 136 );
            rec.fsmlkval := Convert( slices, 137 );
            rec.fsmval := Convert( slices, 138 );
            rec.fwmlkval := Convert( slices, 139 );
            rec.hdagech := Convert( slices, 140 );
            rec.hourab := Convert( slices, 141 );
            rec.hourah := Convert( slices, 142 );
            rec.hourcb := Convert( slices, 143 );
            rec.hourch := Convert( slices, 144 );
            rec.hourcl := Convert( slices, 145 );
            rec.hourfr := Convert( slices, 146 );
            rec.hourot := Convert( slices, 147 );
            rec.hourre := Convert( slices, 148 );
            rec.hourtot := Convert( slices, 149 );
            rec.hperson := Convert( slices, 150 );
            rec.iagegr2 := Convert( slices, 151 );
            rec.iagegrp := Convert( slices, 152 );
            rec.relhrp := Convert( slices, 153 );
            rec.totgntch := Convert( slices, 154 );
            rec.tuacam := Convert( slices, 155 );
            rec.uperson := Convert( slices, 156 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0506;


   procedure Create_ChildCare_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.benccdis := Convert( slices, 5 );
            rec.chamt := Convert( slices, 6 );
            rec.chfar := Convert( slices, 7 );
            rec.chhr := Convert( slices, 8 );
            rec.chinknd1 := Convert( slices, 9 );
            rec.chinknd2 := Convert( slices, 10 );
            rec.chinknd3 := Convert( slices, 11 );
            rec.chinknd4 := Convert( slices, 12 );
            rec.chinknd5 := Convert( slices, 13 );
            rec.chpd := Convert( slices, 14 );
            rec.cost := Convert( slices, 15 );
            rec.ctrm := Convert( slices, 16 );
            rec.emplprov := Convert( slices, 17 );
            rec.registrd := Convert( slices, 18 );
            rec.month := Convert( slices, 19 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_0506;


   procedure Create_Endowment_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.menpolam := Convert( slices, 5 );
            rec.menpolpd := Convert( slices, 6 );
            rec.menstyr := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0506;


   procedure Create_ExtChild_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.nhhamt := Convert( slices, 4 );
            rec.nhhfee := Convert( slices, 5 );
            rec.nhhintro := Convert( slices, 6 );
            rec.nhhpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0506;


   procedure Create_GovPay_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.month := Convert( slices, 6 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0506;


   procedure Create_Hbai_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.sernum := Convert( slices, 19 );
            rec.benunits := Convert( slices, 20 );
            rec.gvtregn := Convert( slices, 21 );
            rec.hhstat := Convert( slices, 22 );
            rec.tenure := Convert( slices, 23 );
            rec.adulth := Convert( slices, 24 );
            rec.depchldh := Convert( slices, 25 );
            rec.tentyp2 := Convert( slices, 26 );
            rec.watsewrt := Convert( slices, 27 );
            rec.sewerage := Convert( slices, 28 );
            rec.cwathh := Convert( slices, 29 );
            rec.totsthh := Convert( slices, 30 );
            rec.totstrhh := Convert( slices, 31 );
            rec.charghh := Convert( slices, 32 );
            rec.hbmort := Convert( slices, 33 );
            rec.hbxmort := Convert( slices, 34 );
            rec.hrenthh := Convert( slices, 35 );
            rec.erenthh := Convert( slices, 36 );
            rec.hbenhh := Convert( slices, 37 );
            rec.watsewhh := Convert( slices, 38 );
            rec.hhcost := Convert( slices, 39 );
            rec.ehcost := Convert( slices, 40 );
            rec.bhcdef := Convert( slices, 41 );
            rec.ahcdef := Convert( slices, 42 );
            rec.ctliab := Convert( slices, 43 );
            rec.ctrebam1 := Convert( slices, 44 );
            rec.adultb := Convert( slices, 45 );
            rec.egrincbu := Convert( slices, 46 );
            rec.entincbu := Convert( slices, 47 );
            rec.hgrernhh := Convert( slices, 48 );
            rec.hnternhh := Convert( slices, 49 );
            rec.hgrinvhh := Convert( slices, 50 );
            rec.hntinvhh := Convert( slices, 51 );
            rec.hgrocchh := Convert( slices, 52 );
            rec.hntocchh := Convert( slices, 53 );
            rec.hbeninhh := Convert( slices, 54 );
            rec.hpribnhh := Convert( slices, 55 );
            rec.hmiscihh := Convert( slices, 56 );
            rec.sfrpahh := Convert( slices, 57 );
            rec.hgrinchh := Convert( slices, 58 );
            rec.hntinchh := Convert( slices, 59 );
            rec.inchilhh := Convert( slices, 60 );
            rec.shtseflg := Convert( slices, 61 );
            rec.sehhflg := Convert( slices, 62 );
            rec.ethgrphh := Convert( slices, 63 );
            rec.egrernhh := Convert( slices, 64 );
            rec.enternhh := Convert( slices, 65 );
            rec.ebeninhh := Convert( slices, 66 );
            rec.epribnhh := Convert( slices, 67 );
            rec.emiscihh := Convert( slices, 68 );
            rec.eothdehh := Convert( slices, 69 );
            rec.egrinchh := Convert( slices, 70 );
            rec.entinchh := Convert( slices, 71 );
            rec.tvlichh := Convert( slices, 72 );
            rec.g_newhh := Convert( slices, 73 );
            rec.gnewhhp := Convert( slices, 74 );
            rec.esgjobhh := Convert( slices, 75 );
            rec.esgrsehh := Convert( slices, 76 );
            rec.esginvhh := Convert( slices, 77 );
            rec.esgocchh := Convert( slices, 78 );
            rec.esmischh := Convert( slices, 79 );
            rec.espribhh := Convert( slices, 80 );
            rec.esbenihh := Convert( slices, 81 );
            rec.esothdhh := Convert( slices, 82 );
            rec.esginchh := Convert( slices, 83 );
            rec.esninchh := Convert( slices, 84 );
            rec.ericphh := Convert( slices, 85 );
            rec.ericnphh := Convert( slices, 86 );
            rec.gs_newhh := Convert( slices, 87 );
            rec.gs_newpph := Convert( slices, 88 );
            rec.es_hcost := Convert( slices, 89 );
            rec.esahchh := Convert( slices, 90 );
            rec.eahchh := Convert( slices, 91 );
            rec.benunit := Convert( slices, 92 );
            rec.depchldb := Convert( slices, 93 );
            rec.eqmcoup := Convert( slices, 94 );
            rec.eqmbhckd := Convert( slices, 95 );
            rec.eqmahckd := Convert( slices, 96 );
            rec.eqmbhchh := Convert( slices, 97 );
            rec.eqmahchh := Convert( slices, 98 );
            rec.over14 := Convert( slices, 99 );
            rec.under14 := Convert( slices, 100 );
            rec.eqobhchh := Convert( slices, 101 );
            rec.eqoahchh := Convert( slices, 102 );
            rec.mc_bhc := Convert( slices, 103 );
            rec.oe_bhc := Convert( slices, 104 );
            rec.mc_gro := Convert( slices, 105 );
            rec.oe_gro := Convert( slices, 106 );
            rec.mc_ahc := Convert( slices, 107 );
            rec.oe_ahc := Convert( slices, 108 );
            rec.s_mc_bhc := Convert( slices, 109 );
            rec.s_oe_bhc := Convert( slices, 110 );
            rec.s_mc_gro := Convert( slices, 111 );
            rec.s_oe_gro := Convert( slices, 112 );
            rec.s_mc_ahc := Convert( slices, 113 );
            rec.s_oe_ahc := Convert( slices, 114 );
            rec.famthbai := Convert( slices, 115 );
            rec.fsmbu := Convert( slices, 116 );
            rec.fsmlkbu := Convert( slices, 117 );
            rec.fwmlkbu := Convert( slices, 118 );
            rec.hbenbu := Convert( slices, 119 );
            rec.ehbenbu := Convert( slices, 120 );
            rec.srentbu := Convert( slices, 121 );
            rec.rentbu := Convert( slices, 122 );
            rec.erentbu := Convert( slices, 123 );
            rec.insebu := Convert( slices, 124 );
            rec.ginsebu := Convert( slices, 125 );
            rec.hgrernbu := Convert( slices, 126 );
            rec.hnternbu := Convert( slices, 127 );
            rec.hgrinvbu := Convert( slices, 128 );
            rec.hntinvbu := Convert( slices, 129 );
            rec.hgroccbu := Convert( slices, 130 );
            rec.hntoccbu := Convert( slices, 131 );
            rec.hbeninbu := Convert( slices, 132 );
            rec.hpribnbu := Convert( slices, 133 );
            rec.hmiscibu := Convert( slices, 134 );
            rec.sfrpabu := Convert( slices, 135 );
            rec.hgrincbu := Convert( slices, 136 );
            rec.hntincbu := Convert( slices, 137 );
            rec.egrernbu := Convert( slices, 138 );
            rec.enternbu := Convert( slices, 139 );
            rec.ebeninbu := Convert( slices, 140 );
            rec.epribnbu := Convert( slices, 141 );
            rec.emiscibu := Convert( slices, 142 );
            rec.eothdebu := Convert( slices, 143 );
            rec.winpaybu := Convert( slices, 144 );
            rec.tvlicbu := Convert( slices, 145 );
            rec.ecobu := Convert( slices, 146 );
            rec.disabflg := Convert( slices, 147 );
            rec.fambu := Convert( slices, 148 );
            rec.newfambu := Convert( slices, 149 );
            rec.kidecobu := Convert( slices, 150 );
            rec.kid0_1 := Convert( slices, 151 );
            rec.kid2_4 := Convert( slices, 152 );
            rec.kid5_7 := Convert( slices, 153 );
            rec.kid8_10 := Convert( slices, 154 );
            rec.kid11_12 := Convert( slices, 155 );
            rec.kid13_15 := Convert( slices, 156 );
            rec.kid16_18 := Convert( slices, 157 );
            rec.boys := Convert( slices, 158 );
            rec.wtcbu := Convert( slices, 159 );
            rec.ctcbu := Convert( slices, 160 );
            rec.isbu := Convert( slices, 161 );
            rec.inchilbu := Convert( slices, 162 );
            rec.g_newbu := Convert( slices, 163 );
            rec.g_newpp := Convert( slices, 164 );
            rec.g_newch := Convert( slices, 165 );
            rec.g_newad := Convert( slices, 166 );
            rec.g_newpn := Convert( slices, 167 );
            rec.g_newwa := Convert( slices, 168 );
            rec.esgjobbu := Convert( slices, 169 );
            rec.esgrsebu := Convert( slices, 170 );
            rec.esginvbu := Convert( slices, 171 );
            rec.esgoccbu := Convert( slices, 172 );
            rec.esmiscbu := Convert( slices, 173 );
            rec.espribbu := Convert( slices, 174 );
            rec.esbenibu := Convert( slices, 175 );
            rec.esothdbu := Convert( slices, 176 );
            rec.esgincbu := Convert( slices, 177 );
            rec.esnincbu := Convert( slices, 178 );
            rec.ericpbu := Convert( slices, 179 );
            rec.ericnpbu := Convert( slices, 180 );
            rec.gs_newbu := Convert( slices, 181 );
            rec.gs_newpp := Convert( slices, 182 );
            rec.gs_newch := Convert( slices, 183 );
            rec.gs_newad := Convert( slices, 184 );
            rec.gs_newpn := Convert( slices, 185 );
            rec.gs_newwa := Convert( slices, 186 );
            rec.region := Convert( slices, 187 );
            rec.mbhcdec := Convert( slices, 188 );
            rec.mqinbhc := Convert( slices, 189 );
            rec.obhcdec := Convert( slices, 190 );
            rec.oqinbhc := Convert( slices, 191 );
            rec.mahcdec := Convert( slices, 192 );
            rec.mqinahc := Convert( slices, 193 );
            rec.oahcdec := Convert( slices, 194 );
            rec.oqinahc := Convert( slices, 195 );
            rec.mbhcdecx := Convert( slices, 196 );
            rec.mqinbhcx := Convert( slices, 197 );
            rec.obhcdecx := Convert( slices, 198 );
            rec.oqinbhcx := Convert( slices, 199 );
            rec.mahcdecx := Convert( slices, 200 );
            rec.mqinahcx := Convert( slices, 201 );
            rec.oahcdecx := Convert( slices, 202 );
            rec.oqinahcx := Convert( slices, 203 );
            rec.agehd := Convert( slices, 204 );
            rec.sexhd := Convert( slices, 205 );
            rec.agesp := Convert( slices, 206 );
            rec.sexsp := Convert( slices, 207 );
            rec.ptentyp2 := Convert( slices, 208 );
            rec.totincm1 := Convert( slices, 209 );
            rec.totincm2 := Convert( slices, 210 );
            rec.netincm1 := Convert( slices, 211 );
            rec.netincm2 := Convert( slices, 212 );
            rec.totincw1 := Convert( slices, 213 );
            rec.totincw2 := Convert( slices, 214 );
            rec.netincw1 := Convert( slices, 215 );
            rec.netincw2 := Convert( slices, 216 );
            rec.lowoebhc := Convert( slices, 217 );
            rec.lowoeahc := Convert( slices, 218 );
            rec.lowmcbhc := Convert( slices, 219 );
            rec.lowmcahc := Convert( slices, 220 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0506;


   procedure Create_Household_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.acorn := Convert( slices, 2 );
            rec.bedroom := Convert( slices, 3 );
            rec.benunits := Convert( slices, 4 );
            rec.billrate := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.charge1 := Convert( slices, 7 );
            rec.charge2 := Convert( slices, 8 );
            rec.charge3 := Convert( slices, 9 );
            rec.charge4 := Convert( slices, 10 );
            rec.charge5 := Convert( slices, 11 );
            rec.charge6 := Convert( slices, 12 );
            rec.charge7 := Convert( slices, 13 );
            rec.charge8 := Convert( slices, 14 );
            rec.charge9 := Convert( slices, 15 );
            rec.chins := Convert( slices, 16 );
            rec.chrgamt1 := Convert( slices, 17 );
            rec.chrgamt2 := Convert( slices, 18 );
            rec.chrgamt3 := Convert( slices, 19 );
            rec.chrgamt4 := Convert( slices, 20 );
            rec.chrgamt5 := Convert( slices, 21 );
            rec.chrgamt6 := Convert( slices, 22 );
            rec.chrgamt7 := Convert( slices, 23 );
            rec.chrgamt8 := Convert( slices, 24 );
            rec.chrgamt9 := Convert( slices, 25 );
            rec.chrgpd1 := Convert( slices, 26 );
            rec.chrgpd2 := Convert( slices, 27 );
            rec.chrgpd3 := Convert( slices, 28 );
            rec.chrgpd4 := Convert( slices, 29 );
            rec.chrgpd5 := Convert( slices, 30 );
            rec.chrgpd6 := Convert( slices, 31 );
            rec.chrgpd7 := Convert( slices, 32 );
            rec.chrgpd8 := Convert( slices, 33 );
            rec.chrgpd9 := Convert( slices, 34 );
            rec.contv1 := Convert( slices, 35 );
            rec.contv2 := Convert( slices, 36 );
            rec.covoths := Convert( slices, 37 );
            rec.csewamt := Convert( slices, 38 );
            rec.csewamt1 := Convert( slices, 39 );
            rec.ct25d50d := Convert( slices, 40 );
            rec.ctamt := Convert( slices, 41 );
            rec.ctannual := Convert( slices, 42 );
            rec.ctband := Convert( slices, 43 );
            rec.ctbwait := Convert( slices, 44 );
            rec.ctcondoc := Convert( slices, 45 );
            rec.ctdisc := Convert( slices, 46 );
            rec.ctinstal := Convert( slices, 47 );
            rec.ctlvband := Convert( slices, 48 );
            rec.ctlvchk := Convert( slices, 49 );
            rec.ctreb := Convert( slices, 50 );
            rec.ctrebamt := Convert( slices, 51 );
            rec.ctrebpd := Convert( slices, 52 );
            rec.cttime := Convert( slices, 53 );
            rec.cwatamt := Convert( slices, 54 );
            rec.cwatamt1 := Convert( slices, 55 );
            rec.datyrago := Convert( slices, 56 );
            rec.dvadulth := Convert( slices, 57 );
            rec.dvtotad := Convert( slices, 58 );
            rec.entry1 := Convert( slices, 59 );
            rec.entry2 := Convert( slices, 60 );
            rec.entry3 := Convert( slices, 61 );
            rec.entry4 := Convert( slices, 62 );
            rec.estrtann := Convert( slices, 63 );
            rec.floor := Convert( slices, 64 );
            rec.givehelp := Convert( slices, 65 );
            rec.gvtregn := Convert( slices, 66 );
            rec.hhldr01 := Convert( slices, 67 );
            rec.hhldr02 := Convert( slices, 68 );
            rec.hhldr03 := Convert( slices, 69 );
            rec.hhldr04 := Convert( slices, 70 );
            rec.hhldr05 := Convert( slices, 71 );
            rec.hhldr06 := Convert( slices, 72 );
            rec.hhldr07 := Convert( slices, 73 );
            rec.hhldr08 := Convert( slices, 74 );
            rec.hhldr09 := Convert( slices, 75 );
            rec.hhldr10 := Convert( slices, 76 );
            rec.hhldr11 := Convert( slices, 77 );
            rec.hhldr12 := Convert( slices, 78 );
            rec.hhldr13 := Convert( slices, 79 );
            rec.hhldr14 := Convert( slices, 80 );
            rec.hhldr97 := Convert( slices, 81 );
            rec.hhstat := Convert( slices, 82 );
            rec.hrpnum := Convert( slices, 83 );
            rec.intdate := Convert( slices, 84 );
            rec.lac := Convert( slices, 85 );
            rec.mainacc := Convert( slices, 86 );
            rec.mnthcode := Convert( slices, 87 );
            rec.monlive := Convert( slices, 88 );
            rec.needhelp := Convert( slices, 89 );
            rec.nicoun := Convert( slices, 90 );
            rec.ninrv := Convert( slices, 91 );
            rec.nirate := Convert( slices, 92 );
            rec.norate := Convert( slices, 93 );
            rec.onbsroom := Convert( slices, 94 );
            rec.orgsewam := Convert( slices, 95 );
            rec.orgwatam := Convert( slices, 96 );
            rec.payrate := Convert( slices, 97 );
            rec.ptbsroom := Convert( slices, 98 );
            rec.rooms := Convert( slices, 99 );
            rec.roomshar := Convert( slices, 100 );
            rec.rtannual := Convert( slices, 101 );
            rec.rtcheck := Convert( slices, 102 );
            rec.rtcondoc := Convert( slices, 103 );
            rec.rtdeduc := Convert( slices, 104 );
            rec.rtinstal := Convert( slices, 105 );
            rec.rtreb := Convert( slices, 106 );
            rec.rtrebamt := Convert( slices, 107 );
            rec.rtrebpd := Convert( slices, 108 );
            rec.rttime := Convert( slices, 109 );
            rec.sampqtr := Convert( slices, 110 );
            rec.schmeal := Convert( slices, 111 );
            rec.schmilk := Convert( slices, 112 );
            rec.sewamt := Convert( slices, 113 );
            rec.sewanul := Convert( slices, 114 );
            rec.sewerpay := Convert( slices, 115 );
            rec.sewsep := Convert( slices, 116 );
            rec.sewtime := Convert( slices, 117 );
            rec.shelter := Convert( slices, 118 );
            rec.sobuy := Convert( slices, 119 );
            rec.sstrtreg := Convert( slices, 120 );
            rec.stramt1 := Convert( slices, 121 );
            rec.stramt2 := Convert( slices, 122 );
            rec.strcov := Convert( slices, 123 );
            rec.strmort := Convert( slices, 124 );
            rec.stroths := Convert( slices, 125 );
            rec.strpd1 := Convert( slices, 126 );
            rec.strpd2 := Convert( slices, 127 );
            rec.suballow := Convert( slices, 128 );
            rec.sublet := Convert( slices, 129 );
            rec.sublety := Convert( slices, 130 );
            rec.subrent := Convert( slices, 131 );
            rec.tenure := Convert( slices, 132 );
            rec.totchild := Convert( slices, 133 );
            rec.totdepdk := Convert( slices, 134 );
            rec.tvlic := Convert( slices, 135 );
            rec.typeacc := Convert( slices, 136 );
            rec.urindew := Convert( slices, 137 );
            rec.urinds := Convert( slices, 138 );
            rec.usevcl := Convert( slices, 139 );
            rec.vehnumb := Convert( slices, 140 );
            rec.watamt := Convert( slices, 141 );
            rec.watanul := Convert( slices, 142 );
            rec.watermet := Convert( slices, 143 );
            rec.waterpay := Convert( slices, 144 );
            rec.watrb := Convert( slices, 145 );
            rec.wattime := Convert( slices, 146 );
            rec.welfmilk := Convert( slices, 147 );
            rec.whoctb01 := Convert( slices, 148 );
            rec.whoctb02 := Convert( slices, 149 );
            rec.whoctb03 := Convert( slices, 150 );
            rec.whoctb04 := Convert( slices, 151 );
            rec.whoctb05 := Convert( slices, 152 );
            rec.whoctb06 := Convert( slices, 153 );
            rec.whoctb07 := Convert( slices, 154 );
            rec.whoctb08 := Convert( slices, 155 );
            rec.whoctb09 := Convert( slices, 156 );
            rec.whoctb10 := Convert( slices, 157 );
            rec.whoctb11 := Convert( slices, 158 );
            rec.whoctb12 := Convert( slices, 159 );
            rec.whoctb13 := Convert( slices, 160 );
            rec.whoctb14 := Convert( slices, 161 );
            rec.whoctbns := Convert( slices, 162 );
            rec.whoctbot := Convert( slices, 163 );
            rec.whorsp01 := Convert( slices, 164 );
            rec.whorsp02 := Convert( slices, 165 );
            rec.whorsp03 := Convert( slices, 166 );
            rec.whorsp04 := Convert( slices, 167 );
            rec.whorsp05 := Convert( slices, 168 );
            rec.whorsp06 := Convert( slices, 169 );
            rec.whorsp07 := Convert( slices, 170 );
            rec.whorsp08 := Convert( slices, 171 );
            rec.whorsp09 := Convert( slices, 172 );
            rec.whorsp10 := Convert( slices, 173 );
            rec.whorsp11 := Convert( slices, 174 );
            rec.whorsp12 := Convert( slices, 175 );
            rec.whorsp13 := Convert( slices, 176 );
            rec.whorsp14 := Convert( slices, 177 );
            rec.whynoct := Convert( slices, 178 );
            rec.wmintro := Convert( slices, 179 );
            rec.wsewamt := Convert( slices, 180 );
            rec.wsewanul := Convert( slices, 181 );
            rec.wsewtime := Convert( slices, 182 );
            rec.yearcode := Convert( slices, 183 );
            rec.yearlive := Convert( slices, 184 );
            rec.month := Convert( slices, 185 );
            rec.actacch := Convert( slices, 186 );
            rec.adddahh := Convert( slices, 187 );
            rec.adulth := Convert( slices, 188 );
            rec.basacth := Convert( slices, 189 );
            rec.chddahh := Convert( slices, 190 );
            rec.country := Convert( slices, 191 );
            rec.crunach := Convert( slices, 192 );
            rec.curacth := Convert( slices, 193 );
            rec.cwatamtd := Convert( slices, 194 );
            rec.depchldh := Convert( slices, 195 );
            rec.emp := Convert( slices, 196 );
            rec.emphrp := Convert( slices, 197 );
            rec.endowpay := Convert( slices, 198 );
            rec.enomorth := Convert( slices, 199 );
            rec.fsbndcth := Convert( slices, 200 );
            rec.gbhscost := Convert( slices, 201 );
            rec.gebacth := Convert( slices, 202 );
            rec.giltcth := Convert( slices, 203 );
            rec.gross3 := Convert( slices, 204 );
            rec.grossct := Convert( slices, 205 );
            rec.hbeninc := Convert( slices, 206 );
            rec.hbindhh := Convert( slices, 207 );
            rec.hbindhh2 := Convert( slices, 208 );
            rec.hcband := Convert( slices, 209 );
            rec.hdhhinc := Convert( slices, 210 );
            rec.hdtax := Convert( slices, 211 );
            rec.hearns := Convert( slices, 212 );
            rec.hhagegr2 := Convert( slices, 213 );
            rec.hhagegrp := Convert( slices, 214 );
            rec.hhcomp := Convert( slices, 215 );
            rec.hhcomps := Convert( slices, 216 );
            rec.hhdisben := Convert( slices, 217 );
            rec.hhethgr2 := Convert( slices, 218 );
            rec.hhinc := Convert( slices, 219 );
            rec.hhincbnd := Convert( slices, 220 );
            rec.hhinv := Convert( slices, 221 );
            rec.hhirben := Convert( slices, 222 );
            rec.hhkids := Convert( slices, 223 );
            rec.hhnirben := Convert( slices, 224 );
            rec.hhothben := Convert( slices, 225 );
            rec.hhrent := Convert( slices, 226 );
            rec.hhrinc := Convert( slices, 227 );
            rec.hhrpinc := Convert( slices, 228 );
            rec.hhsize := Convert( slices, 229 );
            rec.hhtvlic := Convert( slices, 230 );
            rec.hhtxcred := Convert( slices, 231 );
            rec.hothinc := Convert( slices, 232 );
            rec.hpeninc := Convert( slices, 233 );
            rec.hrband := Convert( slices, 234 );
            rec.hseinc := Convert( slices, 235 );
            rec.isacth := Convert( slices, 236 );
            rec.london := Convert( slices, 237 );
            rec.mortcost := Convert( slices, 238 );
            rec.mortint := Convert( slices, 239 );
            rec.mortpay := Convert( slices, 240 );
            rec.nddctb := Convert( slices, 241 );
            rec.nddishc := Convert( slices, 242 );
            rec.nihscost := Convert( slices, 243 );
            rec.nsbocth := Convert( slices, 244 );
            rec.otbscth := Convert( slices, 245 );
            rec.pacctype := Convert( slices, 246 );
            rec.penage := Convert( slices, 247 );
            rec.penhrp := Convert( slices, 248 );
            rec.pepscth := Convert( slices, 249 );
            rec.poaccth := Convert( slices, 250 );
            rec.pocardh := Convert( slices, 251 );
            rec.prbocth := Convert( slices, 252 );
            rec.ptentyp2 := Convert( slices, 253 );
            rec.sayecth := Convert( slices, 254 );
            rec.sclbcth := Convert( slices, 255 );
            rec.servpay := Convert( slices, 256 );
            rec.sick := Convert( slices, 257 );
            rec.sickhrp := Convert( slices, 258 );
            rec.sscth := Convert( slices, 259 );
            rec.struins := Convert( slices, 260 );
            rec.stshcth := Convert( slices, 261 );
            rec.tentyp2 := Convert( slices, 262 );
            rec.tesscth := Convert( slices, 263 );
            rec.tuhhrent := Convert( slices, 264 );
            rec.tuwatsew := Convert( slices, 265 );
            rec.untrcth := Convert( slices, 266 );
            rec.watsewrt := Convert( slices, 267 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0506;


   procedure Create_Job_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.dedoth := Convert( slices, 22 );
            rec.deduc1 := Convert( slices, 23 );
            rec.deduc2 := Convert( slices, 24 );
            rec.deduc3 := Convert( slices, 25 );
            rec.deduc4 := Convert( slices, 26 );
            rec.deduc5 := Convert( slices, 27 );
            rec.deduc6 := Convert( slices, 28 );
            rec.deduc7 := Convert( slices, 29 );
            rec.deduc8 := Convert( slices, 30 );
            rec.dirctr := Convert( slices, 31 );
            rec.dirni := Convert( slices, 32 );
            rec.dvtothru := Convert( slices, 33 );
            rec.dvushr := Convert( slices, 34 );
            rec.empany := Convert( slices, 35 );
            rec.empown := Convert( slices, 36 );
            rec.etype := Convert( slices, 37 );
            rec.everot := Convert( slices, 38 );
            rec.ftpt := Convert( slices, 39 );
            rec.grsofar := Convert( slices, 40 );
            rec.grwage := Convert( slices, 41 );
            rec.grwagpd := Convert( slices, 42 );
            rec.hha1 := Convert( slices, 43 );
            rec.hha2 := Convert( slices, 44 );
            rec.hha3 := Convert( slices, 45 );
            rec.hhc1 := Convert( slices, 46 );
            rec.hhc2 := Convert( slices, 47 );
            rec.hhc3 := Convert( slices, 48 );
            rec.hohinc := Convert( slices, 49 );
            rec.inclpay1 := Convert( slices, 50 );
            rec.inclpay2 := Convert( slices, 51 );
            rec.inclpay3 := Convert( slices, 52 );
            rec.inclpay4 := Convert( slices, 53 );
            rec.inclpay5 := Convert( slices, 54 );
            rec.inclpay6 := Convert( slices, 55 );
            rec.inclpay7 := Convert( slices, 56 );
            rec.inclpay8 := Convert( slices, 57 );
            rec.inkind01 := Convert( slices, 58 );
            rec.inkind02 := Convert( slices, 59 );
            rec.inkind03 := Convert( slices, 60 );
            rec.inkind04 := Convert( slices, 61 );
            rec.inkind05 := Convert( slices, 62 );
            rec.inkind06 := Convert( slices, 63 );
            rec.inkind07 := Convert( slices, 64 );
            rec.inkind08 := Convert( slices, 65 );
            rec.inkind09 := Convert( slices, 66 );
            rec.inkind10 := Convert( slices, 67 );
            rec.inkind11 := Convert( slices, 68 );
            rec.inkind12 := Convert( slices, 69 );
            rec.inkind13 := Convert( slices, 70 );
            rec.instype1 := Convert( slices, 71 );
            rec.instype2 := Convert( slices, 72 );
            rec.jobbus := Convert( slices, 73 );
            rec.likehr := Convert( slices, 74 );
            rec.mademp := Convert( slices, 75 );
            rec.matemp := Convert( slices, 76 );
            rec.matstp := Convert( slices, 77 );
            rec.mileamt := Convert( slices, 78 );
            rec.motamt := Convert( slices, 79 );
            rec.natins := Convert( slices, 80 );
            rec.nature := Convert( slices, 81 );
            rec.nidamt := Convert( slices, 82 );
            rec.nidpd := Convert( slices, 83 );
            rec.nmchc := Convert( slices, 84 );
            rec.nmper := Convert( slices, 85 );
            rec.nomor1 := Convert( slices, 86 );
            rec.nomor2 := Convert( slices, 87 );
            rec.nomor3 := Convert( slices, 88 );
            rec.numemp := Convert( slices, 89 );
            rec.othded1 := Convert( slices, 90 );
            rec.othded2 := Convert( slices, 91 );
            rec.othded3 := Convert( slices, 92 );
            rec.othded4 := Convert( slices, 93 );
            rec.othded5 := Convert( slices, 94 );
            rec.othded6 := Convert( slices, 95 );
            rec.othded7 := Convert( slices, 96 );
            rec.othded8 := Convert( slices, 97 );
            rec.othded9 := Convert( slices, 98 );
            rec.ownamt := Convert( slices, 99 );
            rec.ownotamt := Convert( slices, 100 );
            rec.ownother := Convert( slices, 101 );
            rec.ownsum := Convert( slices, 102 );
            rec.paperiod := Convert( slices, 103 );
            rec.payamt := Convert( slices, 104 );
            rec.paydat := Convert( slices, 105 );
            rec.paye := Convert( slices, 106 );
            rec.paypd := Convert( slices, 107 );
            rec.payslip := Convert( slices, 108 );
            rec.payusl := Convert( slices, 109 );
            rec.pothr := Convert( slices, 110 );
            rec.ppperiod := Convert( slices, 111 );
            rec.prbefore := Convert( slices, 112 );
            rec.profdocs := Convert( slices, 113 );
            rec.profit1 := Convert( slices, 114 );
            rec.profit2 := Convert( slices, 115 );
            rec.profni := Convert( slices, 116 );
            rec.proftax := Convert( slices, 117 );
            rec.rspoth := Convert( slices, 118 );
            rec.salsac := Convert( slices, 119 );
            rec.sapamt := Convert( slices, 120 );
            rec.se1 := Convert( slices, 121 );
            rec.se2 := Convert( slices, 122 );
            rec.seend := Convert( slices, 123 );
            rec.seincamt := Convert( slices, 124 );
            rec.seincwm := Convert( slices, 125 );
            rec.selwks := Convert( slices, 126 );
            rec.seniiamt := Convert( slices, 127 );
            rec.seniinc := Convert( slices, 128 );
            rec.senilamt := Convert( slices, 129 );
            rec.senilump := Convert( slices, 130 );
            rec.seniramt := Convert( slices, 131 );
            rec.senireg := Convert( slices, 132 );
            rec.senirpd := Convert( slices, 133 );
            rec.setax := Convert( slices, 134 );
            rec.setaxamt := Convert( slices, 135 );
            rec.smpamt := Convert( slices, 136 );
            rec.smprate := Convert( slices, 137 );
            rec.sole := Convert( slices, 138 );
            rec.sppamt := Convert( slices, 139 );
            rec.sspamt := Convert( slices, 140 );
            rec.taxamt := Convert( slices, 141 );
            rec.taxdamt := Convert( slices, 142 );
            rec.taxdpd := Convert( slices, 143 );
            rec.totus1 := Convert( slices, 144 );
            rec.ubonamt := Convert( slices, 145 );
            rec.uboninc := Convert( slices, 146 );
            rec.udeduc1 := Convert( slices, 147 );
            rec.udeduc2 := Convert( slices, 148 );
            rec.udeduc3 := Convert( slices, 149 );
            rec.udeduc4 := Convert( slices, 150 );
            rec.udeduc5 := Convert( slices, 151 );
            rec.udeduc6 := Convert( slices, 152 );
            rec.udeduc7 := Convert( slices, 153 );
            rec.udeduc8 := Convert( slices, 154 );
            rec.ugross := Convert( slices, 155 );
            rec.uincpay1 := Convert( slices, 156 );
            rec.uincpay2 := Convert( slices, 157 );
            rec.uincpay3 := Convert( slices, 158 );
            rec.uincpay4 := Convert( slices, 159 );
            rec.uincpay5 := Convert( slices, 160 );
            rec.uincpay6 := Convert( slices, 161 );
            rec.uincpay7 := Convert( slices, 162 );
            rec.uincpay8 := Convert( slices, 163 );
            rec.umileamt := Convert( slices, 164 );
            rec.umotamt := Convert( slices, 165 );
            rec.unett := Convert( slices, 166 );
            rec.uothded1 := Convert( slices, 167 );
            rec.uothded2 := Convert( slices, 168 );
            rec.uothded3 := Convert( slices, 169 );
            rec.uothded4 := Convert( slices, 170 );
            rec.uothded5 := Convert( slices, 171 );
            rec.uothded6 := Convert( slices, 172 );
            rec.uothded7 := Convert( slices, 173 );
            rec.uothded8 := Convert( slices, 174 );
            rec.uothded9 := Convert( slices, 175 );
            rec.uothdtot := Convert( slices, 176 );
            rec.uothr := Convert( slices, 177 );
            rec.upd := Convert( slices, 178 );
            rec.usapamt := Convert( slices, 179 );
            rec.usmpamt := Convert( slices, 180 );
            rec.usmprate := Convert( slices, 181 );
            rec.usppamt := Convert( slices, 182 );
            rec.usspamt := Convert( slices, 183 );
            rec.usuhr := Convert( slices, 184 );
            rec.utaxamt := Convert( slices, 185 );
            rec.watdid := Convert( slices, 186 );
            rec.watprev := Convert( slices, 187 );
            rec.where := Convert( slices, 188 );
            rec.whynopro := Convert( slices, 189 );
            rec.whynou01 := Convert( slices, 190 );
            rec.whynou02 := Convert( slices, 191 );
            rec.whynou03 := Convert( slices, 192 );
            rec.whynou04 := Convert( slices, 193 );
            rec.whynou05 := Convert( slices, 194 );
            rec.whynou06 := Convert( slices, 195 );
            rec.whynou07 := Convert( slices, 196 );
            rec.whynou08 := Convert( slices, 197 );
            rec.whynou09 := Convert( slices, 198 );
            rec.whynou10 := Convert( slices, 199 );
            rec.whynou11 := Convert( slices, 200 );
            rec.workacc := Convert( slices, 201 );
            rec.workmth := Convert( slices, 202 );
            rec.workyr := Convert( slices, 203 );
            rec.month := Convert( slices, 204 );
            rec.hdqhrs := Convert( slices, 205 );
            rec.jobhours := Convert( slices, 206 );
            rec.sspsmpfg := Convert( slices, 207 );
            rec.ugrspay := Convert( slices, 208 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0506;


   procedure Create_Maint_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.m := Convert( slices, 5 );
            rec.mrage := Convert( slices, 6 );
            rec.mramt := Convert( slices, 7 );
            rec.mrchwhy1 := Convert( slices, 8 );
            rec.mrchwhy2 := Convert( slices, 9 );
            rec.mrchwhy3 := Convert( slices, 10 );
            rec.mrchwhy4 := Convert( slices, 11 );
            rec.mrchwhy5 := Convert( slices, 12 );
            rec.mrchwhy6 := Convert( slices, 13 );
            rec.mrchwhy7 := Convert( slices, 14 );
            rec.mrchwhy8 := Convert( slices, 15 );
            rec.mrchwhy9 := Convert( slices, 16 );
            rec.mrct := Convert( slices, 17 );
            rec.mrkid := Convert( slices, 18 );
            rec.mrpd := Convert( slices, 19 );
            rec.mrr := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0506;


   procedure Create_MortCont_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.outsamt := Convert( slices, 4 );
            rec.outsincl := Convert( slices, 5 );
            rec.outspay := Convert( slices, 6 );
            rec.outspd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0506;


   procedure Create_Mortgage_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.loan2y := Convert( slices, 31 );
            rec.loanyear := Convert( slices, 32 );
            rec.menpol := Convert( slices, 33 );
            rec.morall := Convert( slices, 34 );
            rec.morflc := Convert( slices, 35 );
            rec.morinpay := Convert( slices, 36 );
            rec.morinpd := Convert( slices, 37 );
            rec.morinus := Convert( slices, 38 );
            rec.mortend := Convert( slices, 39 );
            rec.mortleft := Convert( slices, 40 );
            rec.mortprot := Convert( slices, 41 );
            rec.morttype := Convert( slices, 42 );
            rec.morupd := Convert( slices, 43 );
            rec.morus := Convert( slices, 44 );
            rec.mpcover1 := Convert( slices, 45 );
            rec.mpcover2 := Convert( slices, 46 );
            rec.mpcover3 := Convert( slices, 47 );
            rec.mpolno := Convert( slices, 48 );
            rec.outsmort := Convert( slices, 49 );
            rec.rentfrom := Convert( slices, 50 );
            rec.rmamt := Convert( slices, 51 );
            rec.rmort := Convert( slices, 52 );
            rec.rmortyr := Convert( slices, 53 );
            rec.rmpur001 := Convert( slices, 54 );
            rec.rmpur002 := Convert( slices, 55 );
            rec.rmpur003 := Convert( slices, 56 );
            rec.rmpur004 := Convert( slices, 57 );
            rec.rmpur005 := Convert( slices, 58 );
            rec.rmpur006 := Convert( slices, 59 );
            rec.rmpur007 := Convert( slices, 60 );
            rec.rmpur008 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0506;


   procedure Create_OddJob_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.ojamt := Convert( slices, 6 );
            rec.ojnow := Convert( slices, 7 );
            rec.ojreg := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0506;


   procedure Create_Owner_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.othmort1 := Convert( slices, 3 );
            rec.othmort2 := Convert( slices, 4 );
            rec.othmort3 := Convert( slices, 5 );
            rec.othpur1 := Convert( slices, 6 );
            rec.othpur2 := Convert( slices, 7 );
            rec.othpur3 := Convert( slices, 8 );
            rec.othpur31 := Convert( slices, 9 );
            rec.othpur32 := Convert( slices, 10 );
            rec.othpur33 := Convert( slices, 11 );
            rec.othpur34 := Convert( slices, 12 );
            rec.othpur35 := Convert( slices, 13 );
            rec.othpur36 := Convert( slices, 14 );
            rec.othpur37 := Convert( slices, 15 );
            rec.othpur4 := Convert( slices, 16 );
            rec.othpur5 := Convert( slices, 17 );
            rec.othpur6 := Convert( slices, 18 );
            rec.othpur7 := Convert( slices, 19 );
            rec.purcamt := Convert( slices, 20 );
            rec.purcloan := Convert( slices, 21 );
            rec.month := Convert( slices, 22 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0506;


   procedure Create_PenAmt_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.penq := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0506;


   procedure Create_PenProv_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppay := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eplong := Convert( slices, 6 );
            rec.eptype := Convert( slices, 7 );
            rec.keeppen := Convert( slices, 8 );
            rec.opgov := Convert( slices, 9 );
            rec.penamt := Convert( slices, 10 );
            rec.penamtpd := Convert( slices, 11 );
            rec.pencon := Convert( slices, 12 );
            rec.pendat := Convert( slices, 13 );
            rec.pengov := Convert( slices, 14 );
            rec.penhelp := Convert( slices, 15 );
            rec.penmort := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0506;


   procedure Create_Pension_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.penoth := Convert( slices, 6 );
            rec.penpay := Convert( slices, 7 );
            rec.penpd := Convert( slices, 8 );
            rec.pentax := Convert( slices, 9 );
            rec.pentype := Convert( slices, 10 );
            rec.poamt := Convert( slices, 11 );
            rec.poinc := Convert( slices, 12 );
            rec.posour := Convert( slices, 13 );
            rec.ptamt := Convert( slices, 14 );
            rec.ptinc := Convert( slices, 15 );
            rec.trights := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0506;


   procedure Create_RentCont_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0506;


   procedure Create_Renter_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbweeks := Convert( slices, 28 );
            rec.hbyears := Convert( slices, 29 );
            rec.landlord := Convert( slices, 30 );
            rec.lowshort := Convert( slices, 31 );
            rec.niystart := Convert( slices, 32 );
            rec.othtype := Convert( slices, 33 );
            rec.rebate := Convert( slices, 34 );
            rec.rent := Convert( slices, 35 );
            rec.rentdk := Convert( slices, 36 );
            rec.rentdoc := Convert( slices, 37 );
            rec.rentfull := Convert( slices, 38 );
            rec.renthol := Convert( slices, 39 );
            rec.rentpd := Convert( slices, 40 );
            rec.resll := Convert( slices, 41 );
            rec.resll2 := Convert( slices, 42 );
            rec.serinc1 := Convert( slices, 43 );
            rec.serinc2 := Convert( slices, 44 );
            rec.serinc3 := Convert( slices, 45 );
            rec.serinc4 := Convert( slices, 46 );
            rec.serinc5 := Convert( slices, 47 );
            rec.tentype := Convert( slices, 48 );
            rec.weekhol := Convert( slices, 49 );
            rec.wsinc := Convert( slices, 50 );
            rec.wsincamt := Convert( slices, 51 );
            rec.ystartr := Convert( slices, 52 );
            rec.month := Convert( slices, 53 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0506;


   procedure Create_Vehicle_0506( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Vehicle_IO.File_Type;
      rec         : Vehicle_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Vehicle_IO.Create (bin_file, Vehicle_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.vehseq := Convert( slices, 2 );
            rec.vehic := Convert( slices, 3 );
            rec.vehown := Convert( slices, 4 );
            rec.month := Convert( slices, 5 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( VehicleRec ).startPos = 0 ) then
               index.pointers( VehicleRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( VehicleRec ).counter := index.pointers( VehicleRec ).counter + 1;
            Put_Index( index_map, index );
            Vehicle_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Vehicle_IO.Close( bin_file );
   end Create_Vehicle_0506;


   procedure Create_Account_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.nsamt := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0607;


   procedure Create_Admin_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.ncr1 := Convert( slices, 5 );
            rec.ncr2 := Convert( slices, 6 );
            rec.ncr3 := Convert( slices, 7 );
            rec.ncr4 := Convert( slices, 8 );
            rec.ncr5 := Convert( slices, 9 );
            rec.ncr6 := Convert( slices, 10 );
            rec.ncr7 := Convert( slices, 11 );
            rec.refr01 := Convert( slices, 12 );
            rec.refr02 := Convert( slices, 13 );
            rec.refr03 := Convert( slices, 14 );
            rec.refr04 := Convert( slices, 15 );
            rec.refr05 := Convert( slices, 16 );
            rec.refr06 := Convert( slices, 17 );
            rec.refr07 := Convert( slices, 18 );
            rec.refr08 := Convert( slices, 19 );
            rec.refr09 := Convert( slices, 20 );
            rec.refr10 := Convert( slices, 21 );
            rec.refr11 := Convert( slices, 22 );
            rec.refr12 := Convert( slices, 23 );
            rec.refr13 := Convert( slices, 24 );
            rec.refr14 := Convert( slices, 25 );
            rec.refr15 := Convert( slices, 26 );
            rec.refr16 := Convert( slices, 27 );
            rec.refr17 := Convert( slices, 28 );
            rec.refr18 := Convert( slices, 29 );
            rec.tnc := Convert( slices, 30 );
            rec.version := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0607;


   procedure Create_Adult_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.allow1 := Convert( slices, 21 );
            rec.allow2 := Convert( slices, 22 );
            rec.allow3 := Convert( slices, 23 );
            rec.allow4 := Convert( slices, 24 );
            rec.allpay1 := Convert( slices, 25 );
            rec.allpay2 := Convert( slices, 26 );
            rec.allpay3 := Convert( slices, 27 );
            rec.allpay4 := Convert( slices, 28 );
            rec.allpd1 := Convert( slices, 29 );
            rec.allpd2 := Convert( slices, 30 );
            rec.allpd3 := Convert( slices, 31 );
            rec.allpd4 := Convert( slices, 32 );
            rec.anyacc := Convert( slices, 33 );
            rec.anyed := Convert( slices, 34 );
            rec.anymon := Convert( slices, 35 );
            rec.anypen1 := Convert( slices, 36 );
            rec.anypen2 := Convert( slices, 37 );
            rec.anypen3 := Convert( slices, 38 );
            rec.anypen4 := Convert( slices, 39 );
            rec.anypen5 := Convert( slices, 40 );
            rec.anypen6 := Convert( slices, 41 );
            rec.anypen7 := Convert( slices, 42 );
            rec.apamt := Convert( slices, 43 );
            rec.apdamt := Convert( slices, 44 );
            rec.apdir := Convert( slices, 45 );
            rec.apdpd := Convert( slices, 46 );
            rec.appd := Convert( slices, 47 );
            rec.b2qfut1 := Convert( slices, 48 );
            rec.b2qfut2 := Convert( slices, 49 );
            rec.b2qfut3 := Convert( slices, 50 );
            rec.b3qfut1 := Convert( slices, 51 );
            rec.b3qfut2 := Convert( slices, 52 );
            rec.b3qfut3 := Convert( slices, 53 );
            rec.b3qfut4 := Convert( slices, 54 );
            rec.b3qfut5 := Convert( slices, 55 );
            rec.b3qfut6 := Convert( slices, 56 );
            rec.ben1q1 := Convert( slices, 57 );
            rec.ben1q2 := Convert( slices, 58 );
            rec.ben1q3 := Convert( slices, 59 );
            rec.ben1q4 := Convert( slices, 60 );
            rec.ben1q5 := Convert( slices, 61 );
            rec.ben1q6 := Convert( slices, 62 );
            rec.ben1q7 := Convert( slices, 63 );
            rec.ben2q1 := Convert( slices, 64 );
            rec.ben2q2 := Convert( slices, 65 );
            rec.ben2q3 := Convert( slices, 66 );
            rec.ben3q1 := Convert( slices, 67 );
            rec.ben3q2 := Convert( slices, 68 );
            rec.ben3q3 := Convert( slices, 69 );
            rec.ben3q4 := Convert( slices, 70 );
            rec.ben3q5 := Convert( slices, 71 );
            rec.ben3q6 := Convert( slices, 72 );
            rec.ben4q1 := Convert( slices, 73 );
            rec.ben4q2 := Convert( slices, 74 );
            rec.ben4q3 := Convert( slices, 75 );
            rec.ben5q1 := Convert( slices, 76 );
            rec.ben5q2 := Convert( slices, 77 );
            rec.ben5q3 := Convert( slices, 78 );
            rec.ben5q4 := Convert( slices, 79 );
            rec.ben5q5 := Convert( slices, 80 );
            rec.ben5q6 := Convert( slices, 81 );
            rec.ben5q7 := Convert( slices, 82 );
            rec.ben5q8 := Convert( slices, 83 );
            rec.ben7q1 := Convert( slices, 84 );
            rec.ben7q2 := Convert( slices, 85 );
            rec.ben7q3 := Convert( slices, 86 );
            rec.ben7q4 := Convert( slices, 87 );
            rec.ben7q5 := Convert( slices, 88 );
            rec.ben7q6 := Convert( slices, 89 );
            rec.ben7q7 := Convert( slices, 90 );
            rec.ben7q8 := Convert( slices, 91 );
            rec.ben7q9 := Convert( slices, 92 );
            rec.chkdpn := Convert( slices, 93 );
            rec.chknop := Convert( slices, 94 );
            rec.claimant := Convert( slices, 95 );
            rec.cohabit := Convert( slices, 96 );
            rec.combid := Convert( slices, 97 );
            rec.consent := Convert( slices, 98 );
            rec.convbl := Convert( slices, 99 );
            rec.ctclum1 := Convert( slices, 100 );
            rec.ctclum2 := Convert( slices, 101 );
            rec.cupchk := Convert( slices, 102 );
            rec.cvht := Convert( slices, 103 );
            rec.cvpay := Convert( slices, 104 );
            rec.cvpd := Convert( slices, 105 );
            rec.ddatre := Convert( slices, 106 );
            rec.ddatrep := Convert( slices, 107 );
            rec.defrpen := Convert( slices, 108 );
            rec.depend := Convert( slices, 109 );
            rec.disdif1 := Convert( slices, 110 );
            rec.disdif2 := Convert( slices, 111 );
            rec.disdif3 := Convert( slices, 112 );
            rec.disdif4 := Convert( slices, 113 );
            rec.disdif5 := Convert( slices, 114 );
            rec.disdif6 := Convert( slices, 115 );
            rec.disdif7 := Convert( slices, 116 );
            rec.disdif8 := Convert( slices, 117 );
            rec.disdif9 := Convert( slices, 118 );
            rec.disdifp := Convert( slices, 119 );
            rec.dob := Convert( slices, 120 );
            rec.dvil03a := Convert( slices, 121 );
            rec.dvil04a := Convert( slices, 122 );
            rec.dvjb12ml := Convert( slices, 123 );
            rec.dvmardf := Convert( slices, 124 );
            rec.dvpens := Convert( slices, 125 );
            rec.ed1amt := Convert( slices, 126 );
            rec.ed1borr := Convert( slices, 127 );
            rec.ed1int := Convert( slices, 128 );
            rec.ed1monyr := Convert( slices, 129 );
            rec.ed1pd := Convert( slices, 130 );
            rec.ed1sum := Convert( slices, 131 );
            rec.ed2amt := Convert( slices, 132 );
            rec.ed2borr := Convert( slices, 133 );
            rec.ed2int := Convert( slices, 134 );
            rec.ed2monyr := Convert( slices, 135 );
            rec.ed2pd := Convert( slices, 136 );
            rec.ed2sum := Convert( slices, 137 );
            rec.edatt := Convert( slices, 138 );
            rec.edattn1 := Convert( slices, 139 );
            rec.edattn2 := Convert( slices, 140 );
            rec.edattn3 := Convert( slices, 141 );
            rec.edhr := Convert( slices, 142 );
            rec.edtime := Convert( slices, 143 );
            rec.edtyp := Convert( slices, 144 );
            rec.eligadlt := Convert( slices, 145 );
            rec.eligchld := Convert( slices, 146 );
            rec.eligschm := Convert( slices, 147 );
            rec.emparr := Convert( slices, 148 );
            rec.emppen := Convert( slices, 149 );
            rec.empschm := Convert( slices, 150 );
            rec.empstat := Convert( slices, 151 );
            rec.endyr := Convert( slices, 152 );
            rec.es2000 := Convert( slices, 153 );
            rec.ethgrp := Convert( slices, 154 );
            rec.everwrk := Convert( slices, 155 );
            rec.exthbct1 := Convert( slices, 156 );
            rec.exthbct2 := Convert( slices, 157 );
            rec.exthbct3 := Convert( slices, 158 );
            rec.fare := Convert( slices, 159 );
            rec.followup := Convert( slices, 160 );
            rec.fted := Convert( slices, 161 );
            rec.ftwk := Convert( slices, 162 );
            rec.govpis := Convert( slices, 163 );
            rec.govpjsa := Convert( slices, 164 );
            rec.grant := Convert( slices, 165 );
            rec.grtamt1 := Convert( slices, 166 );
            rec.grtamt2 := Convert( slices, 167 );
            rec.grtdir1 := Convert( slices, 168 );
            rec.grtdir2 := Convert( slices, 169 );
            rec.grtnum := Convert( slices, 170 );
            rec.grtsce1 := Convert( slices, 171 );
            rec.grtsce2 := Convert( slices, 172 );
            rec.grtval1 := Convert( slices, 173 );
            rec.grtval2 := Convert( slices, 174 );
            rec.gta := Convert( slices, 175 );
            rec.hbothamt := Convert( slices, 176 );
            rec.hbothbu := Convert( slices, 177 );
            rec.hbothpd := Convert( slices, 178 );
            rec.hbothwk := Convert( slices, 179 );
            rec.hbotwait := Convert( slices, 180 );
            rec.health := Convert( slices, 181 );
            rec.hholder := Convert( slices, 182 );
            rec.hprob := Convert( slices, 183 );
            rec.hrpid := Convert( slices, 184 );
            rec.incdur := Convert( slices, 185 );
            rec.injlong := Convert( slices, 186 );
            rec.injwk := Convert( slices, 187 );
            rec.invests := Convert( slices, 188 );
            rec.iout := Convert( slices, 189 );
            rec.isa1type := Convert( slices, 190 );
            rec.isa2type := Convert( slices, 191 );
            rec.jobaway := Convert( slices, 192 );
            rec.lareg := Convert( slices, 193 );
            rec.likewk := Convert( slices, 194 );
            rec.lktime := Convert( slices, 195 );
            rec.ln1rpint := Convert( slices, 196 );
            rec.ln2rpint := Convert( slices, 197 );
            rec.lnkref1 := Convert( slices, 198 );
            rec.lnkref2 := Convert( slices, 199 );
            rec.lnkref21 := Convert( slices, 200 );
            rec.lnkref22 := Convert( slices, 201 );
            rec.lnkref23 := Convert( slices, 202 );
            rec.lnkref24 := Convert( slices, 203 );
            rec.lnkref25 := Convert( slices, 204 );
            rec.lnkref3 := Convert( slices, 205 );
            rec.lnkref4 := Convert( slices, 206 );
            rec.lnkref5 := Convert( slices, 207 );
            rec.loan := Convert( slices, 208 );
            rec.loannum := Convert( slices, 209 );
            rec.look := Convert( slices, 210 );
            rec.lookwk := Convert( slices, 211 );
            rec.lstwrk1 := Convert( slices, 212 );
            rec.lstwrk2 := Convert( slices, 213 );
            rec.lstyr := Convert( slices, 214 );
            rec.memschm := Convert( slices, 215 );
            rec.mntamt1 := Convert( slices, 216 );
            rec.mntamt2 := Convert( slices, 217 );
            rec.mntct := Convert( slices, 218 );
            rec.mntfor1 := Convert( slices, 219 );
            rec.mntfor2 := Convert( slices, 220 );
            rec.mntgov1 := Convert( slices, 221 );
            rec.mntgov2 := Convert( slices, 222 );
            rec.mntpay := Convert( slices, 223 );
            rec.mntpd1 := Convert( slices, 224 );
            rec.mntpd2 := Convert( slices, 225 );
            rec.mntrec := Convert( slices, 226 );
            rec.mnttota1 := Convert( slices, 227 );
            rec.mnttota2 := Convert( slices, 228 );
            rec.mntus1 := Convert( slices, 229 );
            rec.mntus2 := Convert( slices, 230 );
            rec.mntusam1 := Convert( slices, 231 );
            rec.mntusam2 := Convert( slices, 232 );
            rec.mntuspd1 := Convert( slices, 233 );
            rec.mntuspd2 := Convert( slices, 234 );
            rec.ms := Convert( slices, 235 );
            rec.natid1 := Convert( slices, 236 );
            rec.natid2 := Convert( slices, 237 );
            rec.natid3 := Convert( slices, 238 );
            rec.natid4 := Convert( slices, 239 );
            rec.natid5 := Convert( slices, 240 );
            rec.natid6 := Convert( slices, 241 );
            rec.ndeal := Convert( slices, 242 );
            rec.newdtype := Convert( slices, 243 );
            rec.niamt := Convert( slices, 244 );
            rec.niethgrp := Convert( slices, 245 );
            rec.niexthbb := Convert( slices, 246 );
            rec.ninatid1 := Convert( slices, 247 );
            rec.ninatid2 := Convert( slices, 248 );
            rec.ninatid3 := Convert( slices, 249 );
            rec.ninatid4 := Convert( slices, 250 );
            rec.ninatid5 := Convert( slices, 251 );
            rec.ninatid6 := Convert( slices, 252 );
            rec.ninatid7 := Convert( slices, 253 );
            rec.ninatid8 := Convert( slices, 254 );
            rec.nipd := Convert( slices, 255 );
            rec.nireg := Convert( slices, 256 );
            rec.nirel := Convert( slices, 257 );
            rec.nitrain := Convert( slices, 258 );
            rec.nittwmod := Convert( slices, 259 );
            rec.nlper := Convert( slices, 260 );
            rec.nolk1 := Convert( slices, 261 );
            rec.nolk2 := Convert( slices, 262 );
            rec.nolk3 := Convert( slices, 263 );
            rec.nolook := Convert( slices, 264 );
            rec.nowant := Convert( slices, 265 );
            rec.nssec := Convert( slices, 266 );
            rec.ntcdat := Convert( slices, 267 );
            rec.ntcinc := Convert( slices, 268 );
            rec.numjob := Convert( slices, 269 );
            rec.numjob2 := Convert( slices, 270 );
            rec.oddjob := Convert( slices, 271 );
            rec.oldstud := Convert( slices, 272 );
            rec.oneway := Convert( slices, 273 );
            rec.otabspar := Convert( slices, 274 );
            rec.otamt := Convert( slices, 275 );
            rec.otapamt := Convert( slices, 276 );
            rec.otappd := Convert( slices, 277 );
            rec.othtax := Convert( slices, 278 );
            rec.otinva := Convert( slices, 279 );
            rec.pareamt := Convert( slices, 280 );
            rec.parepd := Convert( slices, 281 );
            rec.pconsent := Convert( slices, 282 );
            rec.penlump := Convert( slices, 283 );
            rec.perspen1 := Convert( slices, 284 );
            rec.perspen2 := Convert( slices, 285 );
            rec.ppnumc := Convert( slices, 286 );
            rec.practice := Convert( slices, 287 );
            rec.privpen := Convert( slices, 288 );
            rec.pssamt := Convert( slices, 289 );
            rec.pssdate := Convert( slices, 290 );
            rec.ptwk := Convert( slices, 291 );
            rec.r01 := Convert( slices, 292 );
            rec.r02 := Convert( slices, 293 );
            rec.r03 := Convert( slices, 294 );
            rec.r04 := Convert( slices, 295 );
            rec.r05 := Convert( slices, 296 );
            rec.r06 := Convert( slices, 297 );
            rec.r07 := Convert( slices, 298 );
            rec.r08 := Convert( slices, 299 );
            rec.r09 := Convert( slices, 300 );
            rec.r10 := Convert( slices, 301 );
            rec.r11 := Convert( slices, 302 );
            rec.r12 := Convert( slices, 303 );
            rec.r13 := Convert( slices, 304 );
            rec.r14 := Convert( slices, 305 );
            rec.redamt := Convert( slices, 306 );
            rec.redany := Convert( slices, 307 );
            rec.rentprof := Convert( slices, 308 );
            rec.retire := Convert( slices, 309 );
            rec.retire1 := Convert( slices, 310 );
            rec.retreas := Convert( slices, 311 );
            rec.royal1 := Convert( slices, 312 );
            rec.royal2 := Convert( slices, 313 );
            rec.royal3 := Convert( slices, 314 );
            rec.royal4 := Convert( slices, 315 );
            rec.royyr1 := Convert( slices, 316 );
            rec.royyr2 := Convert( slices, 317 );
            rec.royyr3 := Convert( slices, 318 );
            rec.royyr4 := Convert( slices, 319 );
            rec.rstrct := Convert( slices, 320 );
            rec.schchk := Convert( slices, 321 );
            rec.sex := Convert( slices, 322 );
            rec.sflntyp1 := Convert( slices, 323 );
            rec.sflntyp2 := Convert( slices, 324 );
            rec.sfrpis := Convert( slices, 325 );
            rec.sfrpjsa := Convert( slices, 326 );
            rec.sftype1 := Convert( slices, 327 );
            rec.sftype2 := Convert( slices, 328 );
            rec.sic := Convert( slices, 329 );
            rec.slrepamt := Convert( slices, 330 );
            rec.slrepay := Convert( slices, 331 );
            rec.slreppd := Convert( slices, 332 );
            rec.soc2000 := Convert( slices, 333 );
            rec.spcreg1 := Convert( slices, 334 );
            rec.spcreg2 := Convert( slices, 335 );
            rec.spcreg3 := Convert( slices, 336 );
            rec.spnumc := Convert( slices, 337 );
            rec.spout := Convert( slices, 338 );
            rec.srentamt := Convert( slices, 339 );
            rec.srentpd := Convert( slices, 340 );
            rec.stakep := Convert( slices, 341 );
            rec.start := Convert( slices, 342 );
            rec.startyr := Convert( slices, 343 );
            rec.taxcred1 := Convert( slices, 344 );
            rec.taxcred2 := Convert( slices, 345 );
            rec.taxfut := Convert( slices, 346 );
            rec.tdaywrk := Convert( slices, 347 );
            rec.tea := Convert( slices, 348 );
            rec.topupl := Convert( slices, 349 );
            rec.totint := Convert( slices, 350 );
            rec.train := Convert( slices, 351 );
            rec.trainee := Convert( slices, 352 );
            rec.ttwcode1 := Convert( slices, 353 );
            rec.ttwcode2 := Convert( slices, 354 );
            rec.ttwcode3 := Convert( slices, 355 );
            rec.ttwcost := Convert( slices, 356 );
            rec.ttwfar := Convert( slices, 357 );
            rec.ttwfrq := Convert( slices, 358 );
            rec.ttwmod := Convert( slices, 359 );
            rec.ttwpay := Convert( slices, 360 );
            rec.ttwpss := Convert( slices, 361 );
            rec.ttwrec := Convert( slices, 362 );
            rec.tuborr := Convert( slices, 363 );
            rec.typeed := Convert( slices, 364 );
            rec.unpaid1 := Convert( slices, 365 );
            rec.unpaid2 := Convert( slices, 366 );
            rec.w1 := Convert( slices, 367 );
            rec.w2 := Convert( slices, 368 );
            rec.wait := Convert( slices, 369 );
            rec.war1 := Convert( slices, 370 );
            rec.war2 := Convert( slices, 371 );
            rec.whoresp := Convert( slices, 372 );
            rec.whosectb := Convert( slices, 373 );
            rec.wintfuel := Convert( slices, 374 );
            rec.wmkit := Convert( slices, 375 );
            rec.working := Convert( slices, 376 );
            rec.wpa := Convert( slices, 377 );
            rec.wpba := Convert( slices, 378 );
            rec.wtclum1 := Convert( slices, 379 );
            rec.wtclum2 := Convert( slices, 380 );
            rec.wtclum3 := Convert( slices, 381 );
            rec.ystrtwk := Convert( slices, 382 );
            rec.month := Convert( slices, 383 );
            rec.able := Convert( slices, 384 );
            rec.actacci := Convert( slices, 385 );
            rec.addda := Convert( slices, 386 );
            rec.age80 := Convert( slices, 387 );
            rec.basacti := Convert( slices, 388 );
            rec.bntxcred := Convert( slices, 389 );
            rec.careab := Convert( slices, 390 );
            rec.careah := Convert( slices, 391 );
            rec.carecb := Convert( slices, 392 );
            rec.carech := Convert( slices, 393 );
            rec.carecl := Convert( slices, 394 );
            rec.carefl := Convert( slices, 395 );
            rec.carefr := Convert( slices, 396 );
            rec.careot := Convert( slices, 397 );
            rec.carere := Convert( slices, 398 );
            rec.chbflg := Convert( slices, 399 );
            rec.crunaci := Convert( slices, 400 );
            rec.curacti := Convert( slices, 401 );
            rec.empoccp := Convert( slices, 402 );
            rec.empstatb := Convert( slices, 403 );
            rec.empstatc := Convert( slices, 404 );
            rec.empstati := Convert( slices, 405 );
            rec.enomorti := Convert( slices, 406 );
            rec.ethgr2 := Convert( slices, 407 );
            rec.fsbndcti := Convert( slices, 408 );
            rec.fwmlkval := Convert( slices, 409 );
            rec.gebacti := Convert( slices, 410 );
            rec.giltcti := Convert( slices, 411 );
            rec.gross3 := Convert( slices, 412 );
            rec.hdage := Convert( slices, 413 );
            rec.hdben := Convert( slices, 414 );
            rec.hdindinc := Convert( slices, 415 );
            rec.hourab := Convert( slices, 416 );
            rec.hourah := Convert( slices, 417 );
            rec.hourcare := Convert( slices, 418 );
            rec.hourcb := Convert( slices, 419 );
            rec.hourch := Convert( slices, 420 );
            rec.hourcl := Convert( slices, 421 );
            rec.hourfr := Convert( slices, 422 );
            rec.hourot := Convert( slices, 423 );
            rec.hourre := Convert( slices, 424 );
            rec.hourtot := Convert( slices, 425 );
            rec.hperson := Convert( slices, 426 );
            rec.iagegr2 := Convert( slices, 427 );
            rec.iagegrp := Convert( slices, 428 );
            rec.incseo2 := Convert( slices, 429 );
            rec.indinc := Convert( slices, 430 );
            rec.indisben := Convert( slices, 431 );
            rec.inearns := Convert( slices, 432 );
            rec.ininv := Convert( slices, 433 );
            rec.inirben := Convert( slices, 434 );
            rec.innirben := Convert( slices, 435 );
            rec.inothben := Convert( slices, 436 );
            rec.inpeninc := Convert( slices, 437 );
            rec.inrinc := Convert( slices, 438 );
            rec.inrpinc := Convert( slices, 439 );
            rec.intvlic := Convert( slices, 440 );
            rec.intxcred := Convert( slices, 441 );
            rec.isacti := Convert( slices, 442 );
            rec.marital := Convert( slices, 443 );
            rec.nincseo2 := Convert( slices, 444 );
            rec.nindinc := Convert( slices, 445 );
            rec.ninearns := Convert( slices, 446 );
            rec.nininv := Convert( slices, 447 );
            rec.ninpenin := Convert( slices, 448 );
            rec.ninsein2 := Convert( slices, 449 );
            rec.nsbocti := Convert( slices, 450 );
            rec.occupnum := Convert( slices, 451 );
            rec.otbscti := Convert( slices, 452 );
            rec.pepscti := Convert( slices, 453 );
            rec.poaccti := Convert( slices, 454 );
            rec.pocardi := Convert( slices, 455 );
            rec.prbocti := Convert( slices, 456 );
            rec.relhrp := Convert( slices, 457 );
            rec.sapadj := Convert( slices, 458 );
            rec.sayecti := Convert( slices, 459 );
            rec.sclbcti := Convert( slices, 460 );
            rec.seincam2 := Convert( slices, 461 );
            rec.smpadj := Convert( slices, 462 );
            rec.sppadj := Convert( slices, 463 );
            rec.sscti := Convert( slices, 464 );
            rec.sspadj := Convert( slices, 465 );
            rec.stshcti := Convert( slices, 466 );
            rec.taxpayer := Convert( slices, 467 );
            rec.tesscti := Convert( slices, 468 );
            rec.totgrant := Convert( slices, 469 );
            rec.tothours := Convert( slices, 470 );
            rec.totoccp := Convert( slices, 471 );
            rec.untrcti := Convert( slices, 472 );
            rec.uperson := Convert( slices, 473 );
            rec.widoccp := Convert( slices, 474 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0607;


   procedure Create_Asset_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0607;


   procedure Create_Benefit_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.notusamt := Convert( slices, 16 );
            rec.notuspd := Convert( slices, 17 );
            rec.numweeks := Convert( slices, 18 );
            rec.ordbkno := Convert( slices, 19 );
            rec.payslipb := Convert( slices, 20 );
            rec.pres := Convert( slices, 21 );
            rec.usual := Convert( slices, 22 );
            rec.var1 := Convert( slices, 23 );
            rec.var2 := Convert( slices, 24 );
            rec.var3 := Convert( slices, 25 );
            rec.whorec1 := Convert( slices, 26 );
            rec.whorec2 := Convert( slices, 27 );
            rec.whorec3 := Convert( slices, 28 );
            rec.whorec4 := Convert( slices, 29 );
            rec.whorec5 := Convert( slices, 30 );
            rec.month := Convert( slices, 31 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0607;


   procedure Create_Benunit_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.cdelply := Convert( slices, 13 );
            rec.cdepbed := Convert( slices, 14 );
            rec.cdepcel := Convert( slices, 15 );
            rec.cdepeqp := Convert( slices, 16 );
            rec.cdephol := Convert( slices, 17 );
            rec.cdeples := Convert( slices, 18 );
            rec.cdepsum := Convert( slices, 19 );
            rec.cdeptea := Convert( slices, 20 );
            rec.cdeptrp := Convert( slices, 21 );
            rec.cplay := Convert( slices, 22 );
            rec.debt1 := Convert( slices, 23 );
            rec.debt2 := Convert( slices, 24 );
            rec.debt3 := Convert( slices, 25 );
            rec.debt4 := Convert( slices, 26 );
            rec.debt5 := Convert( slices, 27 );
            rec.debt6 := Convert( slices, 28 );
            rec.debt7 := Convert( slices, 29 );
            rec.debt8 := Convert( slices, 30 );
            rec.debt9 := Convert( slices, 31 );
            rec.houshe1 := Convert( slices, 32 );
            rec.incchnge := Convert( slices, 33 );
            rec.inchilow := Convert( slices, 34 );
            rec.incold := Convert( slices, 35 );
            rec.kidinc := Convert( slices, 36 );
            rec.nhhchild := Convert( slices, 37 );
            rec.totsav := Convert( slices, 38 );
            rec.month := Convert( slices, 39 );
            rec.actaccb := Convert( slices, 40 );
            rec.adddabu := Convert( slices, 41 );
            rec.adultb := Convert( slices, 42 );
            rec.basactb := Convert( slices, 43 );
            rec.boarder := Convert( slices, 44 );
            rec.bpeninc := Convert( slices, 45 );
            rec.bseinc := Convert( slices, 46 );
            rec.buagegr2 := Convert( slices, 47 );
            rec.buagegrp := Convert( slices, 48 );
            rec.budisben := Convert( slices, 49 );
            rec.buearns := Convert( slices, 50 );
            rec.buethgr2 := Convert( slices, 51 );
            rec.buinc := Convert( slices, 52 );
            rec.buinv := Convert( slices, 53 );
            rec.buirben := Convert( slices, 54 );
            rec.bukids := Convert( slices, 55 );
            rec.bunirben := Convert( slices, 56 );
            rec.buothben := Convert( slices, 57 );
            rec.burent := Convert( slices, 58 );
            rec.burinc := Convert( slices, 59 );
            rec.burpinc := Convert( slices, 60 );
            rec.butvlic := Convert( slices, 61 );
            rec.butxcred := Convert( slices, 62 );
            rec.chddabu := Convert( slices, 63 );
            rec.crunacb := Convert( slices, 64 );
            rec.curactb := Convert( slices, 65 );
            rec.depchldb := Convert( slices, 66 );
            rec.depdeds := Convert( slices, 67 );
            rec.disindhb := Convert( slices, 68 );
            rec.ecotypbu := Convert( slices, 69 );
            rec.ecstatbu := Convert( slices, 70 );
            rec.enomortb := Convert( slices, 71 );
            rec.famthbai := Convert( slices, 72 );
            rec.famtypbs := Convert( slices, 73 );
            rec.famtypbu := Convert( slices, 74 );
            rec.famtype := Convert( slices, 75 );
            rec.fsbndctb := Convert( slices, 76 );
            rec.fsmbu := Convert( slices, 77 );
            rec.fsmlkbu := Convert( slices, 78 );
            rec.fwmlkbu := Convert( slices, 79 );
            rec.gebactb := Convert( slices, 80 );
            rec.giltctb := Convert( slices, 81 );
            rec.gross3 := Convert( slices, 82 );
            rec.hbindbu := Convert( slices, 83 );
            rec.hbindbu2 := Convert( slices, 84 );
            rec.isactb := Convert( slices, 85 );
            rec.kid04 := Convert( slices, 86 );
            rec.kid1115 := Convert( slices, 87 );
            rec.kid1619 := Convert( slices, 88 );
            rec.kid510 := Convert( slices, 89 );
            rec.lastwork := Convert( slices, 90 );
            rec.lodger := Convert( slices, 91 );
            rec.nsboctb := Convert( slices, 92 );
            rec.otbsctb := Convert( slices, 93 );
            rec.pepsctb := Convert( slices, 94 );
            rec.poacctb := Convert( slices, 95 );
            rec.pocardb := Convert( slices, 96 );
            rec.prboctb := Convert( slices, 97 );
            rec.sayectb := Convert( slices, 98 );
            rec.sclbctb := Convert( slices, 99 );
            rec.ssctb := Convert( slices, 100 );
            rec.stshctb := Convert( slices, 101 );
            rec.subltamt := Convert( slices, 102 );
            rec.tessctb := Convert( slices, 103 );
            rec.totcapb2 := Convert( slices, 104 );
            rec.totcapbu := Convert( slices, 105 );
            rec.totsavbu := Convert( slices, 106 );
            rec.tuburent := Convert( slices, 107 );
            rec.untrctb := Convert( slices, 108 );
            rec.youngch := Convert( slices, 109 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0607;


   procedure Create_Care_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.wholoo01 := Convert( slices, 46 );
            rec.wholoo02 := Convert( slices, 47 );
            rec.wholoo03 := Convert( slices, 48 );
            rec.wholoo04 := Convert( slices, 49 );
            rec.wholoo05 := Convert( slices, 50 );
            rec.wholoo06 := Convert( slices, 51 );
            rec.wholoo07 := Convert( slices, 52 );
            rec.wholoo08 := Convert( slices, 53 );
            rec.wholoo09 := Convert( slices, 54 );
            rec.wholoo10 := Convert( slices, 55 );
            rec.wholoo11 := Convert( slices, 56 );
            rec.wholoo12 := Convert( slices, 57 );
            rec.wholoo13 := Convert( slices, 58 );
            rec.wholoo14 := Convert( slices, 59 );
            rec.wholoo15 := Convert( slices, 60 );
            rec.wholoo16 := Convert( slices, 61 );
            rec.wholoo17 := Convert( slices, 62 );
            rec.wholoo18 := Convert( slices, 63 );
            rec.wholoo19 := Convert( slices, 64 );
            rec.wholoo20 := Convert( slices, 65 );
            rec.month := Convert( slices, 66 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0607;


   procedure Create_Child_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddatre := Convert( slices, 7 );
            rec.cddatrep := Convert( slices, 8 );
            rec.cdisdif1 := Convert( slices, 9 );
            rec.cdisdif2 := Convert( slices, 10 );
            rec.cdisdif3 := Convert( slices, 11 );
            rec.cdisdif4 := Convert( slices, 12 );
            rec.cdisdif5 := Convert( slices, 13 );
            rec.cdisdif6 := Convert( slices, 14 );
            rec.cdisdif7 := Convert( slices, 15 );
            rec.cdisdif8 := Convert( slices, 16 );
            rec.cdisdif9 := Convert( slices, 17 );
            rec.cdisdifp := Convert( slices, 18 );
            rec.cfund := Convert( slices, 19 );
            rec.cfundh := Convert( slices, 20 );
            rec.cfundtp := Convert( slices, 21 );
            rec.chamtern := Convert( slices, 22 );
            rec.chamttst := Convert( slices, 23 );
            rec.chdla1 := Convert( slices, 24 );
            rec.chdla2 := Convert( slices, 25 );
            rec.chealth := Convert( slices, 26 );
            rec.chearns1 := Convert( slices, 27 );
            rec.chearns2 := Convert( slices, 28 );
            rec.chema := Convert( slices, 29 );
            rec.chemaamt := Convert( slices, 30 );
            rec.chemapd := Convert( slices, 31 );
            rec.chpdern := Convert( slices, 32 );
            rec.chpdtst := Convert( slices, 33 );
            rec.chprob := Convert( slices, 34 );
            rec.chsave := Convert( slices, 35 );
            rec.chwkern := Convert( slices, 36 );
            rec.chwktst := Convert( slices, 37 );
            rec.chyrern := Convert( slices, 38 );
            rec.chyrtst := Convert( slices, 39 );
            rec.cohabit := Convert( slices, 40 );
            rec.convbl := Convert( slices, 41 );
            rec.cvht := Convert( slices, 42 );
            rec.cvpay := Convert( slices, 43 );
            rec.cvpd := Convert( slices, 44 );
            rec.depend := Convert( slices, 45 );
            rec.dob := Convert( slices, 46 );
            rec.eligadlt := Convert( slices, 47 );
            rec.eligchld := Convert( slices, 48 );
            rec.endyr := Convert( slices, 49 );
            rec.fted := Convert( slices, 50 );
            rec.fundamt1 := Convert( slices, 51 );
            rec.fundamt2 := Convert( slices, 52 );
            rec.fundamt3 := Convert( slices, 53 );
            rec.fundamt4 := Convert( slices, 54 );
            rec.fundamt5 := Convert( slices, 55 );
            rec.fundamt6 := Convert( slices, 56 );
            rec.givcfnd1 := Convert( slices, 57 );
            rec.givcfnd2 := Convert( slices, 58 );
            rec.givcfnd3 := Convert( slices, 59 );
            rec.givcfnd4 := Convert( slices, 60 );
            rec.givcfnd5 := Convert( slices, 61 );
            rec.givcfnd6 := Convert( slices, 62 );
            rec.grant := Convert( slices, 63 );
            rec.grtamt1 := Convert( slices, 64 );
            rec.grtamt2 := Convert( slices, 65 );
            rec.grtdir1 := Convert( slices, 66 );
            rec.grtdir2 := Convert( slices, 67 );
            rec.grtnum := Convert( slices, 68 );
            rec.grtsce1 := Convert( slices, 69 );
            rec.grtsce2 := Convert( slices, 70 );
            rec.grtval1 := Convert( slices, 71 );
            rec.grtval2 := Convert( slices, 72 );
            rec.hholder := Convert( slices, 73 );
            rec.lareg := Convert( slices, 74 );
            rec.legdep := Convert( slices, 75 );
            rec.ms := Convert( slices, 76 );
            rec.parent1 := Convert( slices, 77 );
            rec.parent2 := Convert( slices, 78 );
            rec.r01 := Convert( slices, 79 );
            rec.r02 := Convert( slices, 80 );
            rec.r03 := Convert( slices, 81 );
            rec.r04 := Convert( slices, 82 );
            rec.r05 := Convert( slices, 83 );
            rec.r06 := Convert( slices, 84 );
            rec.r07 := Convert( slices, 85 );
            rec.r08 := Convert( slices, 86 );
            rec.r09 := Convert( slices, 87 );
            rec.r10 := Convert( slices, 88 );
            rec.r11 := Convert( slices, 89 );
            rec.r12 := Convert( slices, 90 );
            rec.r13 := Convert( slices, 91 );
            rec.r14 := Convert( slices, 92 );
            rec.schchk := Convert( slices, 93 );
            rec.sex := Convert( slices, 94 );
            rec.smkit := Convert( slices, 95 );
            rec.smlit := Convert( slices, 96 );
            rec.spcreg1 := Convert( slices, 97 );
            rec.spcreg2 := Convert( slices, 98 );
            rec.spcreg3 := Convert( slices, 99 );
            rec.spout := Convert( slices, 100 );
            rec.srentamt := Convert( slices, 101 );
            rec.srentpd := Convert( slices, 102 );
            rec.startyr := Convert( slices, 103 );
            rec.totsave := Convert( slices, 104 );
            rec.trainee := Convert( slices, 105 );
            rec.typeed := Convert( slices, 106 );
            rec.wmkit := Convert( slices, 107 );
            rec.month := Convert( slices, 108 );
            rec.careab := Convert( slices, 109 );
            rec.careah := Convert( slices, 110 );
            rec.carecb := Convert( slices, 111 );
            rec.carech := Convert( slices, 112 );
            rec.carecl := Convert( slices, 113 );
            rec.carefl := Convert( slices, 114 );
            rec.carefr := Convert( slices, 115 );
            rec.careot := Convert( slices, 116 );
            rec.carere := Convert( slices, 117 );
            rec.chdda := Convert( slices, 118 );
            rec.chearns := Convert( slices, 119 );
            rec.chincdv := Convert( slices, 120 );
            rec.chrinc := Convert( slices, 121 );
            rec.fsmlkval := Convert( slices, 122 );
            rec.fsmval := Convert( slices, 123 );
            rec.fwmlkval := Convert( slices, 124 );
            rec.hdagech := Convert( slices, 125 );
            rec.hourab := Convert( slices, 126 );
            rec.hourah := Convert( slices, 127 );
            rec.hourcb := Convert( slices, 128 );
            rec.hourch := Convert( slices, 129 );
            rec.hourcl := Convert( slices, 130 );
            rec.hourfr := Convert( slices, 131 );
            rec.hourot := Convert( slices, 132 );
            rec.hourre := Convert( slices, 133 );
            rec.hourtot := Convert( slices, 134 );
            rec.hperson := Convert( slices, 135 );
            rec.iagegr2 := Convert( slices, 136 );
            rec.iagegrp := Convert( slices, 137 );
            rec.relhrp := Convert( slices, 138 );
            rec.totgntch := Convert( slices, 139 );
            rec.tuacam := Convert( slices, 140 );
            rec.uperson := Convert( slices, 141 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0607;


   procedure Create_ChildCare_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.benccdis := Convert( slices, 5 );
            rec.chamt := Convert( slices, 6 );
            rec.chhr := Convert( slices, 7 );
            rec.chinknd1 := Convert( slices, 8 );
            rec.chinknd2 := Convert( slices, 9 );
            rec.chinknd3 := Convert( slices, 10 );
            rec.chinknd4 := Convert( slices, 11 );
            rec.chinknd5 := Convert( slices, 12 );
            rec.chpd := Convert( slices, 13 );
            rec.cost := Convert( slices, 14 );
            rec.ctrm := Convert( slices, 15 );
            rec.emplprov := Convert( slices, 16 );
            rec.pmchk := Convert( slices, 17 );
            rec.registrd := Convert( slices, 18 );
            rec.month := Convert( slices, 19 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_0607;


   procedure Create_Endowment_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.menpolam := Convert( slices, 5 );
            rec.menpolpd := Convert( slices, 6 );
            rec.menstyr := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0607;


   procedure Create_ExtChild_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.nhhamt := Convert( slices, 4 );
            rec.nhhfee := Convert( slices, 5 );
            rec.nhhintro := Convert( slices, 6 );
            rec.nhhpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0607;


   procedure Create_GovPay_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.month := Convert( slices, 6 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0607;


   procedure Create_Hbai_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.sernum := Convert( slices, 19 );
            rec.benunits := Convert( slices, 20 );
            rec.gvtregn := Convert( slices, 21 );
            rec.hhstat := Convert( slices, 22 );
            rec.tenure := Convert( slices, 23 );
            rec.adulth := Convert( slices, 24 );
            rec.depchldh := Convert( slices, 25 );
            rec.tentyp2 := Convert( slices, 26 );
            rec.watsewrt := Convert( slices, 27 );
            rec.sewerage := Convert( slices, 28 );
            rec.cwathh := Convert( slices, 29 );
            rec.totsthh := Convert( slices, 30 );
            rec.totstrhh := Convert( slices, 31 );
            rec.charghh := Convert( slices, 32 );
            rec.hbmort := Convert( slices, 33 );
            rec.hbxmort := Convert( slices, 34 );
            rec.hrenthh := Convert( slices, 35 );
            rec.erenthh := Convert( slices, 36 );
            rec.hbenhh := Convert( slices, 37 );
            rec.watsewhh := Convert( slices, 38 );
            rec.hhcost := Convert( slices, 39 );
            rec.ehcost := Convert( slices, 40 );
            rec.bhcdef := Convert( slices, 41 );
            rec.ahcdef := Convert( slices, 42 );
            rec.ctrebam1 := Convert( slices, 43 );
            rec.adultb := Convert( slices, 44 );
            rec.egrincbu := Convert( slices, 45 );
            rec.entincbu := Convert( slices, 46 );
            rec.hgrernhh := Convert( slices, 47 );
            rec.hnternhh := Convert( slices, 48 );
            rec.hgrinvhh := Convert( slices, 49 );
            rec.hntinvhh := Convert( slices, 50 );
            rec.hgrocchh := Convert( slices, 51 );
            rec.hntocchh := Convert( slices, 52 );
            rec.hbeninhh := Convert( slices, 53 );
            rec.hpribnhh := Convert( slices, 54 );
            rec.hmiscihh := Convert( slices, 55 );
            rec.sfrpahh := Convert( slices, 56 );
            rec.hgrinchh := Convert( slices, 57 );
            rec.hntinchh := Convert( slices, 58 );
            rec.inchilhh := Convert( slices, 59 );
            rec.ethgrphh := Convert( slices, 60 );
            rec.egrernhh := Convert( slices, 61 );
            rec.enternhh := Convert( slices, 62 );
            rec.ebeninhh := Convert( slices, 63 );
            rec.epribnhh := Convert( slices, 64 );
            rec.emiscihh := Convert( slices, 65 );
            rec.eothdehh := Convert( slices, 66 );
            rec.egrinchh := Convert( slices, 67 );
            rec.entinchh := Convert( slices, 68 );
            rec.tvlichh := Convert( slices, 69 );
            rec.g_newhh := Convert( slices, 70 );
            rec.gnewhhp := Convert( slices, 71 );
            rec.esgjobhh := Convert( slices, 72 );
            rec.esgrsehh := Convert( slices, 73 );
            rec.esginvhh := Convert( slices, 74 );
            rec.esgocchh := Convert( slices, 75 );
            rec.esmischh := Convert( slices, 76 );
            rec.espribhh := Convert( slices, 77 );
            rec.esbenihh := Convert( slices, 78 );
            rec.esothdhh := Convert( slices, 79 );
            rec.esginchh := Convert( slices, 80 );
            rec.esninchh := Convert( slices, 81 );
            rec.ericphh := Convert( slices, 82 );
            rec.ericnphh := Convert( slices, 83 );
            rec.gs_newhh := Convert( slices, 84 );
            rec.gs_newpph := Convert( slices, 85 );
            rec.es_hcost := Convert( slices, 86 );
            rec.esahchh := Convert( slices, 87 );
            rec.eahchh := Convert( slices, 88 );
            rec.benunit := Convert( slices, 89 );
            rec.depchldb := Convert( slices, 90 );
            rec.eqmcoup := Convert( slices, 91 );
            rec.eqmbhckd := Convert( slices, 92 );
            rec.eqmahckd := Convert( slices, 93 );
            rec.eqmbhchh := Convert( slices, 94 );
            rec.eqmahchh := Convert( slices, 95 );
            rec.over14 := Convert( slices, 96 );
            rec.under14 := Convert( slices, 97 );
            rec.eqobhchh := Convert( slices, 98 );
            rec.eqoahchh := Convert( slices, 99 );
            rec.mc_bhc := Convert( slices, 100 );
            rec.oe_bhc := Convert( slices, 101 );
            rec.mc_gro := Convert( slices, 102 );
            rec.oe_gro := Convert( slices, 103 );
            rec.mc_ahc := Convert( slices, 104 );
            rec.oe_ahc := Convert( slices, 105 );
            rec.s_mc_bhc := Convert( slices, 106 );
            rec.s_oe_bhc := Convert( slices, 107 );
            rec.s_mc_gro := Convert( slices, 108 );
            rec.s_oe_gro := Convert( slices, 109 );
            rec.s_mc_ahc := Convert( slices, 110 );
            rec.s_oe_ahc := Convert( slices, 111 );
            rec.famthbai := Convert( slices, 112 );
            rec.fsmbu := Convert( slices, 113 );
            rec.fsmlkbu := Convert( slices, 114 );
            rec.fwmlkbu := Convert( slices, 115 );
            rec.hbenbu := Convert( slices, 116 );
            rec.ehbenbu := Convert( slices, 117 );
            rec.srentbu := Convert( slices, 118 );
            rec.rentbu := Convert( slices, 119 );
            rec.erentbu := Convert( slices, 120 );
            rec.insebu := Convert( slices, 121 );
            rec.ginsebu := Convert( slices, 122 );
            rec.hgrernbu := Convert( slices, 123 );
            rec.hnternbu := Convert( slices, 124 );
            rec.hgrinvbu := Convert( slices, 125 );
            rec.hntinvbu := Convert( slices, 126 );
            rec.hgroccbu := Convert( slices, 127 );
            rec.hntoccbu := Convert( slices, 128 );
            rec.hbeninbu := Convert( slices, 129 );
            rec.hpribnbu := Convert( slices, 130 );
            rec.hmiscibu := Convert( slices, 131 );
            rec.sfrpabu := Convert( slices, 132 );
            rec.hgrincbu := Convert( slices, 133 );
            rec.hntincbu := Convert( slices, 134 );
            rec.egrernbu := Convert( slices, 135 );
            rec.enternbu := Convert( slices, 136 );
            rec.ebeninbu := Convert( slices, 137 );
            rec.epribnbu := Convert( slices, 138 );
            rec.emiscibu := Convert( slices, 139 );
            rec.eothdebu := Convert( slices, 140 );
            rec.winpaybu := Convert( slices, 141 );
            rec.tvlicbu := Convert( slices, 142 );
            rec.oldecobu := Convert( slices, 143 );
            rec.disabflg := Convert( slices, 144 );
            rec.fambu := Convert( slices, 145 );
            rec.newfambu := Convert( slices, 146 );
            rec.personhd := Convert( slices, 147 );
            rec.personsp := Convert( slices, 148 );
            rec.oldkidecobu := Convert( slices, 149 );
            rec.kid0_1 := Convert( slices, 150 );
            rec.kid2_4 := Convert( slices, 151 );
            rec.kid5_7 := Convert( slices, 152 );
            rec.kid8_10 := Convert( slices, 153 );
            rec.kid11_12 := Convert( slices, 154 );
            rec.kid13_15 := Convert( slices, 155 );
            rec.kid16_19 := Convert( slices, 156 );
            rec.boys := Convert( slices, 157 );
            rec.wtcbu := Convert( slices, 158 );
            rec.ctcbu := Convert( slices, 159 );
            rec.isbu := Convert( slices, 160 );
            rec.inchilbu := Convert( slices, 161 );
            rec.g_newbu := Convert( slices, 162 );
            rec.g_newpp := Convert( slices, 163 );
            rec.g_newch := Convert( slices, 164 );
            rec.g_newad := Convert( slices, 165 );
            rec.g_newpn := Convert( slices, 166 );
            rec.g_newwa := Convert( slices, 167 );
            rec.esgjobbu := Convert( slices, 168 );
            rec.esgrsebu := Convert( slices, 169 );
            rec.esginvbu := Convert( slices, 170 );
            rec.esgoccbu := Convert( slices, 171 );
            rec.esmiscbu := Convert( slices, 172 );
            rec.espribbu := Convert( slices, 173 );
            rec.esbenibu := Convert( slices, 174 );
            rec.esothdbu := Convert( slices, 175 );
            rec.esgincbu := Convert( slices, 176 );
            rec.esnincbu := Convert( slices, 177 );
            rec.ericpbu := Convert( slices, 178 );
            rec.ericnpbu := Convert( slices, 179 );
            rec.gs_newbu := Convert( slices, 180 );
            rec.gs_newpp := Convert( slices, 181 );
            rec.gs_newch := Convert( slices, 182 );
            rec.gs_newad := Convert( slices, 183 );
            rec.gs_newpn := Convert( slices, 184 );
            rec.gs_newwa := Convert( slices, 185 );
            rec.mbhcdec := Convert( slices, 186 );
            rec.mqinbhc := Convert( slices, 187 );
            rec.obhcdec := Convert( slices, 188 );
            rec.oqinbhc := Convert( slices, 189 );
            rec.mahcdec := Convert( slices, 190 );
            rec.mqinahc := Convert( slices, 191 );
            rec.oahcdec := Convert( slices, 192 );
            rec.oqinahc := Convert( slices, 193 );
            rec.agehd := Convert( slices, 194 );
            rec.sexhd := Convert( slices, 195 );
            rec.esbenihd := Convert( slices, 196 );
            rec.esgjobhd := Convert( slices, 198 );
            rec.esgocchd := Convert( slices, 199 );
            rec.esgrsehd := Convert( slices, 200 );
            rec.esmischd := Convert( slices, 201 );
            rec.espribhd := Convert( slices, 202 );
            rec.agesp := Convert( slices, 203 );
            rec.sexsp := Convert( slices, 204 );
            rec.esbenisp := Convert( slices, 205 );
            rec.esginvsp := Convert( slices, 206 );
            rec.esgjobsp := Convert( slices, 207 );
            rec.esgoccsp := Convert( slices, 208 );
            rec.esgrsesp := Convert( slices, 209 );
            rec.esmiscsp := Convert( slices, 210 );
            rec.espribsp := Convert( slices, 211 );
            rec.ptentyp2 := Convert( slices, 212 );
            rec.low50bhc := Convert( slices, 213 );
            rec.low60bhc := Convert( slices, 214 );
            rec.low70bhc := Convert( slices, 215 );
            rec.low50ahc := Convert( slices, 216 );
            rec.low60ahc := Convert( slices, 217 );
            rec.low70ahc := Convert( slices, 218 );
            rec.mdscorech := Convert( slices, 219 );
            rec.mdch := Convert( slices, 220 );
            rec.lowincmdch := Convert( slices, 221 );
            rec.ecobu := Convert( slices, 222 );
            rec.kidecobu := Convert( slices, 223 );
            rec.sehhflg := Convert( slices, 224 );
            rec.oldsehhflg := Convert( slices, 225 );
            rec.lowincmdchsev := Convert( slices, 226 );
            rec.mbhcdecx := Convert( slices, 227 );
            rec.mqinbhcx := Convert( slices, 228 );
            rec.obhcdecx := Convert( slices, 229 );
            rec.oqinbhcx := Convert( slices, 230 );
            rec.mahcdecx := Convert( slices, 231 );
            rec.mqinahcx := Convert( slices, 232 );
            rec.oahcdecx := Convert( slices, 233 );
            rec.oqinahcx := Convert( slices, 234 );
            rec.lowmcbhc := Convert( slices, 235 );
            rec.lowmcahc := Convert( slices, 236 );
            rec.chbenhh := Convert( slices, 237 );
            rec.chbenbu := Convert( slices, 238 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0607;


   procedure Create_Household_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.acorn := Convert( slices, 2 );
            rec.bedroom := Convert( slices, 3 );
            rec.benunits := Convert( slices, 4 );
            rec.billrate := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.charge1 := Convert( slices, 7 );
            rec.charge2 := Convert( slices, 8 );
            rec.charge3 := Convert( slices, 9 );
            rec.charge4 := Convert( slices, 10 );
            rec.charge5 := Convert( slices, 11 );
            rec.charge6 := Convert( slices, 12 );
            rec.charge7 := Convert( slices, 13 );
            rec.charge8 := Convert( slices, 14 );
            rec.charge9 := Convert( slices, 15 );
            rec.chins := Convert( slices, 16 );
            rec.chrgamt1 := Convert( slices, 17 );
            rec.chrgamt2 := Convert( slices, 18 );
            rec.chrgamt3 := Convert( slices, 19 );
            rec.chrgamt4 := Convert( slices, 20 );
            rec.chrgamt5 := Convert( slices, 21 );
            rec.chrgamt6 := Convert( slices, 22 );
            rec.chrgamt7 := Convert( slices, 23 );
            rec.chrgamt8 := Convert( slices, 24 );
            rec.chrgamt9 := Convert( slices, 25 );
            rec.chrgpd1 := Convert( slices, 26 );
            rec.chrgpd2 := Convert( slices, 27 );
            rec.chrgpd3 := Convert( slices, 28 );
            rec.chrgpd4 := Convert( slices, 29 );
            rec.chrgpd5 := Convert( slices, 30 );
            rec.chrgpd6 := Convert( slices, 31 );
            rec.chrgpd7 := Convert( slices, 32 );
            rec.chrgpd8 := Convert( slices, 33 );
            rec.chrgpd9 := Convert( slices, 34 );
            rec.contv1 := Convert( slices, 35 );
            rec.contv2 := Convert( slices, 36 );
            rec.covoths := Convert( slices, 37 );
            rec.csewamt := Convert( slices, 38 );
            rec.csewamt1 := Convert( slices, 39 );
            rec.ct25d50d := Convert( slices, 40 );
            rec.ctamt := Convert( slices, 41 );
            rec.ctannual := Convert( slices, 42 );
            rec.ctband := Convert( slices, 43 );
            rec.ctbwait := Convert( slices, 44 );
            rec.ctcondoc := Convert( slices, 45 );
            rec.ctdisc := Convert( slices, 46 );
            rec.ctinstal := Convert( slices, 47 );
            rec.ctlvband := Convert( slices, 48 );
            rec.ctlvchk := Convert( slices, 49 );
            rec.ctreb := Convert( slices, 50 );
            rec.ctrebamt := Convert( slices, 51 );
            rec.ctrebpd := Convert( slices, 52 );
            rec.cttime := Convert( slices, 53 );
            rec.cwatamt := Convert( slices, 54 );
            rec.cwatamt1 := Convert( slices, 55 );
            rec.datyrago := Convert( slices, 56 );
            rec.dvadulth := Convert( slices, 57 );
            rec.dvtotad := Convert( slices, 58 );
            rec.entry1 := Convert( slices, 59 );
            rec.entry2 := Convert( slices, 60 );
            rec.entry3 := Convert( slices, 61 );
            rec.entry4 := Convert( slices, 62 );
            rec.entry5 := Convert( slices, 63 );
            rec.entry6 := Convert( slices, 64 );
            rec.estrtann := Convert( slices, 65 );
            rec.floor := Convert( slices, 66 );
            rec.givehelp := Convert( slices, 67 );
            rec.gvtregn := Convert( slices, 68 );
            rec.hhldr01 := Convert( slices, 69 );
            rec.hhldr02 := Convert( slices, 70 );
            rec.hhldr03 := Convert( slices, 71 );
            rec.hhldr04 := Convert( slices, 72 );
            rec.hhldr05 := Convert( slices, 73 );
            rec.hhldr06 := Convert( slices, 74 );
            rec.hhldr07 := Convert( slices, 75 );
            rec.hhldr08 := Convert( slices, 76 );
            rec.hhldr09 := Convert( slices, 77 );
            rec.hhldr10 := Convert( slices, 78 );
            rec.hhldr11 := Convert( slices, 79 );
            rec.hhldr12 := Convert( slices, 80 );
            rec.hhldr13 := Convert( slices, 81 );
            rec.hhldr14 := Convert( slices, 82 );
            rec.hhldr97 := Convert( slices, 83 );
            rec.hhstat := Convert( slices, 84 );
            rec.hrpnum := Convert( slices, 85 );
            rec.intdate := Convert( slices, 86 );
            rec.lac := Convert( slices, 87 );
            rec.mainacc := Convert( slices, 88 );
            rec.mnthcode := Convert( slices, 89 );
            rec.monlive := Convert( slices, 90 );
            rec.needhelp := Convert( slices, 91 );
            rec.nicoun := Convert( slices, 92 );
            rec.ninrv := Convert( slices, 93 );
            rec.nirate := Convert( slices, 94 );
            rec.norate := Convert( slices, 95 );
            rec.onbsroom := Convert( slices, 96 );
            rec.orgsewam := Convert( slices, 97 );
            rec.orgwatam := Convert( slices, 98 );
            rec.payrate := Convert( slices, 99 );
            rec.ptbsroom := Convert( slices, 100 );
            rec.rooms := Convert( slices, 101 );
            rec.roomshar := Convert( slices, 102 );
            rec.rtannual := Convert( slices, 103 );
            rec.rtcheck := Convert( slices, 104 );
            rec.rtcondoc := Convert( slices, 105 );
            rec.rtdeduc := Convert( slices, 106 );
            rec.rtinstal := Convert( slices, 107 );
            rec.rtreb := Convert( slices, 108 );
            rec.rtrebamt := Convert( slices, 109 );
            rec.rtrebpd := Convert( slices, 110 );
            rec.rttime := Convert( slices, 111 );
            rec.sampqtr := Convert( slices, 112 );
            rec.schmeal := Convert( slices, 113 );
            rec.schmilk := Convert( slices, 114 );
            rec.sewamt := Convert( slices, 115 );
            rec.sewanul := Convert( slices, 116 );
            rec.sewerpay := Convert( slices, 117 );
            rec.sewsep := Convert( slices, 118 );
            rec.sewtime := Convert( slices, 119 );
            rec.shelter := Convert( slices, 120 );
            rec.sobuy := Convert( slices, 121 );
            rec.sstrtreg := Convert( slices, 122 );
            rec.stramt1 := Convert( slices, 123 );
            rec.stramt2 := Convert( slices, 124 );
            rec.strcov := Convert( slices, 125 );
            rec.strmort := Convert( slices, 126 );
            rec.stroths := Convert( slices, 127 );
            rec.strpd1 := Convert( slices, 128 );
            rec.strpd2 := Convert( slices, 129 );
            rec.suballow := Convert( slices, 130 );
            rec.sublet := Convert( slices, 131 );
            rec.sublety := Convert( slices, 132 );
            rec.subrent := Convert( slices, 133 );
            rec.tenure := Convert( slices, 134 );
            rec.totchild := Convert( slices, 135 );
            rec.totdepdk := Convert( slices, 136 );
            rec.tvlic := Convert( slices, 137 );
            rec.typeacc := Convert( slices, 138 );
            rec.urindew := Convert( slices, 139 );
            rec.urinds := Convert( slices, 140 );
            rec.watamt := Convert( slices, 141 );
            rec.watanul := Convert( slices, 142 );
            rec.watermet := Convert( slices, 143 );
            rec.waterpay := Convert( slices, 144 );
            rec.watrb := Convert( slices, 145 );
            rec.wattime := Convert( slices, 146 );
            rec.welfmilk := Convert( slices, 147 );
            rec.whoctb01 := Convert( slices, 148 );
            rec.whoctb02 := Convert( slices, 149 );
            rec.whoctb03 := Convert( slices, 150 );
            rec.whoctb04 := Convert( slices, 151 );
            rec.whoctb05 := Convert( slices, 152 );
            rec.whoctb06 := Convert( slices, 153 );
            rec.whoctb07 := Convert( slices, 154 );
            rec.whoctb08 := Convert( slices, 155 );
            rec.whoctb09 := Convert( slices, 156 );
            rec.whoctb10 := Convert( slices, 157 );
            rec.whoctb11 := Convert( slices, 158 );
            rec.whoctb12 := Convert( slices, 159 );
            rec.whoctb13 := Convert( slices, 160 );
            rec.whoctb14 := Convert( slices, 161 );
            rec.whoctbns := Convert( slices, 162 );
            rec.whoctbot := Convert( slices, 163 );
            rec.whorsp01 := Convert( slices, 164 );
            rec.whorsp02 := Convert( slices, 165 );
            rec.whorsp03 := Convert( slices, 166 );
            rec.whorsp04 := Convert( slices, 167 );
            rec.whorsp05 := Convert( slices, 168 );
            rec.whorsp06 := Convert( slices, 169 );
            rec.whorsp07 := Convert( slices, 170 );
            rec.whorsp08 := Convert( slices, 171 );
            rec.whorsp09 := Convert( slices, 172 );
            rec.whorsp10 := Convert( slices, 173 );
            rec.whorsp11 := Convert( slices, 174 );
            rec.whorsp12 := Convert( slices, 175 );
            rec.whorsp13 := Convert( slices, 176 );
            rec.whorsp14 := Convert( slices, 177 );
            rec.whynoct := Convert( slices, 178 );
            rec.wmintro := Convert( slices, 179 );
            rec.wsewamt := Convert( slices, 180 );
            rec.wsewanul := Convert( slices, 181 );
            rec.wsewtime := Convert( slices, 182 );
            rec.yearcode := Convert( slices, 183 );
            rec.yearlive := Convert( slices, 184 );
            rec.month := Convert( slices, 185 );
            rec.actacch := Convert( slices, 186 );
            rec.adddahh := Convert( slices, 187 );
            rec.adulth := Convert( slices, 188 );
            rec.basacth := Convert( slices, 189 );
            rec.chddahh := Convert( slices, 190 );
            rec.country := Convert( slices, 191 );
            rec.crunach := Convert( slices, 192 );
            rec.curacth := Convert( slices, 193 );
            rec.cwatamtd := Convert( slices, 194 );
            rec.depchldh := Convert( slices, 195 );
            rec.emp := Convert( slices, 196 );
            rec.emphrp := Convert( slices, 197 );
            rec.endowpay := Convert( slices, 198 );
            rec.enomorth := Convert( slices, 199 );
            rec.fsbndcth := Convert( slices, 200 );
            rec.gbhscost := Convert( slices, 201 );
            rec.gebacth := Convert( slices, 202 );
            rec.giltcth := Convert( slices, 203 );
            rec.gross3 := Convert( slices, 204 );
            rec.grossct := Convert( slices, 205 );
            rec.hbeninc := Convert( slices, 206 );
            rec.hbindhh := Convert( slices, 207 );
            rec.hbindhh2 := Convert( slices, 208 );
            rec.hcband := Convert( slices, 209 );
            rec.hdhhinc := Convert( slices, 210 );
            rec.hdtax := Convert( slices, 211 );
            rec.hearns := Convert( slices, 212 );
            rec.hhagegr2 := Convert( slices, 213 );
            rec.hhagegrp := Convert( slices, 214 );
            rec.hhcomp := Convert( slices, 215 );
            rec.hhcomps := Convert( slices, 216 );
            rec.hhdisben := Convert( slices, 217 );
            rec.hhethgr2 := Convert( slices, 218 );
            rec.hhinc := Convert( slices, 219 );
            rec.hhincbnd := Convert( slices, 220 );
            rec.hhinv := Convert( slices, 221 );
            rec.hhirben := Convert( slices, 222 );
            rec.hhkids := Convert( slices, 223 );
            rec.hhnirben := Convert( slices, 224 );
            rec.hhothben := Convert( slices, 225 );
            rec.hhrent := Convert( slices, 226 );
            rec.hhrinc := Convert( slices, 227 );
            rec.hhrpinc := Convert( slices, 228 );
            rec.hhsize := Convert( slices, 229 );
            rec.hhtvlic := Convert( slices, 230 );
            rec.hhtxcred := Convert( slices, 231 );
            rec.hothinc := Convert( slices, 232 );
            rec.hpeninc := Convert( slices, 233 );
            rec.hrband := Convert( slices, 234 );
            rec.hseinc := Convert( slices, 235 );
            rec.isacth := Convert( slices, 236 );
            rec.london := Convert( slices, 237 );
            rec.mortcost := Convert( slices, 238 );
            rec.mortint := Convert( slices, 239 );
            rec.mortpay := Convert( slices, 240 );
            rec.nddctb := Convert( slices, 241 );
            rec.nddishc := Convert( slices, 242 );
            rec.nihscost := Convert( slices, 243 );
            rec.nsbocth := Convert( slices, 244 );
            rec.otbscth := Convert( slices, 245 );
            rec.pacctype := Convert( slices, 246 );
            rec.penage := Convert( slices, 247 );
            rec.penhrp := Convert( slices, 248 );
            rec.pepscth := Convert( slices, 249 );
            rec.poaccth := Convert( slices, 250 );
            rec.pocardh := Convert( slices, 251 );
            rec.prbocth := Convert( slices, 252 );
            rec.ptentyp2 := Convert( slices, 253 );
            rec.sayecth := Convert( slices, 254 );
            rec.sclbcth := Convert( slices, 255 );
            rec.servpay := Convert( slices, 256 );
            rec.sick := Convert( slices, 257 );
            rec.sickhrp := Convert( slices, 258 );
            rec.sscth := Convert( slices, 259 );
            rec.struins := Convert( slices, 260 );
            rec.stshcth := Convert( slices, 261 );
            rec.tentyp2 := Convert( slices, 262 );
            rec.tesscth := Convert( slices, 263 );
            rec.tuhhrent := Convert( slices, 264 );
            rec.tuwatsew := Convert( slices, 265 );
            rec.untrcth := Convert( slices, 266 );
            rec.watsewrt := Convert( slices, 267 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0607;


   procedure Create_Job_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.chvamt := Convert( slices, 22 );
            rec.chvpd := Convert( slices, 23 );
            rec.chvsac := Convert( slices, 24 );
            rec.chvuamt := Convert( slices, 25 );
            rec.chvupd := Convert( slices, 26 );
            rec.chvusu := Convert( slices, 27 );
            rec.dedoth := Convert( slices, 28 );
            rec.deduc1 := Convert( slices, 29 );
            rec.deduc2 := Convert( slices, 30 );
            rec.deduc3 := Convert( slices, 31 );
            rec.deduc4 := Convert( slices, 32 );
            rec.deduc5 := Convert( slices, 33 );
            rec.deduc6 := Convert( slices, 34 );
            rec.deduc7 := Convert( slices, 35 );
            rec.deduc8 := Convert( slices, 36 );
            rec.dirctr := Convert( slices, 37 );
            rec.dirni := Convert( slices, 38 );
            rec.dvtothru := Convert( slices, 39 );
            rec.dvushr := Convert( slices, 40 );
            rec.empany := Convert( slices, 41 );
            rec.empown := Convert( slices, 42 );
            rec.etype := Convert( slices, 43 );
            rec.everot := Convert( slices, 44 );
            rec.expben01 := Convert( slices, 45 );
            rec.expben02 := Convert( slices, 46 );
            rec.expben03 := Convert( slices, 47 );
            rec.expben04 := Convert( slices, 48 );
            rec.expben05 := Convert( slices, 49 );
            rec.expben06 := Convert( slices, 50 );
            rec.expben07 := Convert( slices, 51 );
            rec.expben08 := Convert( slices, 52 );
            rec.expben09 := Convert( slices, 53 );
            rec.expben10 := Convert( slices, 54 );
            rec.ftpt := Convert( slices, 55 );
            rec.grsofar := Convert( slices, 56 );
            rec.grwage := Convert( slices, 57 );
            rec.grwagpd := Convert( slices, 58 );
            rec.hha1 := Convert( slices, 59 );
            rec.hha2 := Convert( slices, 60 );
            rec.hha3 := Convert( slices, 61 );
            rec.hhc1 := Convert( slices, 62 );
            rec.hhc2 := Convert( slices, 63 );
            rec.hhc3 := Convert( slices, 64 );
            rec.hohinc := Convert( slices, 65 );
            rec.inclpay1 := Convert( slices, 66 );
            rec.inclpay2 := Convert( slices, 67 );
            rec.inclpay3 := Convert( slices, 68 );
            rec.inclpay4 := Convert( slices, 69 );
            rec.inclpay5 := Convert( slices, 70 );
            rec.inclpay6 := Convert( slices, 71 );
            rec.inclpay7 := Convert( slices, 72 );
            rec.instype1 := Convert( slices, 73 );
            rec.instype2 := Convert( slices, 74 );
            rec.jobbus := Convert( slices, 75 );
            rec.likehr := Convert( slices, 76 );
            rec.mademp := Convert( slices, 77 );
            rec.matemp := Convert( slices, 78 );
            rec.matstp := Convert( slices, 79 );
            rec.mileamt := Convert( slices, 80 );
            rec.motamt := Convert( slices, 81 );
            rec.natins := Convert( slices, 82 );
            rec.nature := Convert( slices, 83 );
            rec.nidamt := Convert( slices, 84 );
            rec.nidpd := Convert( slices, 85 );
            rec.nmchc := Convert( slices, 86 );
            rec.nmper := Convert( slices, 87 );
            rec.nomor1 := Convert( slices, 88 );
            rec.nomor2 := Convert( slices, 89 );
            rec.nomor3 := Convert( slices, 90 );
            rec.numemp := Convert( slices, 91 );
            rec.othded1 := Convert( slices, 92 );
            rec.othded2 := Convert( slices, 93 );
            rec.othded3 := Convert( slices, 94 );
            rec.othded4 := Convert( slices, 95 );
            rec.othded5 := Convert( slices, 96 );
            rec.othded6 := Convert( slices, 97 );
            rec.othded7 := Convert( slices, 98 );
            rec.othded8 := Convert( slices, 99 );
            rec.othded9 := Convert( slices, 100 );
            rec.ownamt := Convert( slices, 101 );
            rec.ownotamt := Convert( slices, 102 );
            rec.ownother := Convert( slices, 103 );
            rec.ownsum := Convert( slices, 104 );
            rec.paperiod := Convert( slices, 105 );
            rec.payamt := Convert( slices, 106 );
            rec.paydat := Convert( slices, 107 );
            rec.paye := Convert( slices, 108 );
            rec.paypd := Convert( slices, 109 );
            rec.payslip := Convert( slices, 110 );
            rec.payusl := Convert( slices, 111 );
            rec.pothr := Convert( slices, 112 );
            rec.ppperiod := Convert( slices, 113 );
            rec.prbefore := Convert( slices, 114 );
            rec.profdocs := Convert( slices, 115 );
            rec.profit1 := Convert( slices, 116 );
            rec.profit2 := Convert( slices, 117 );
            rec.profni := Convert( slices, 118 );
            rec.proftax := Convert( slices, 119 );
            rec.rspoth := Convert( slices, 120 );
            rec.salsac := Convert( slices, 121 );
            rec.sapamt := Convert( slices, 122 );
            rec.se1 := Convert( slices, 123 );
            rec.se2 := Convert( slices, 124 );
            rec.seend := Convert( slices, 125 );
            rec.seincamt := Convert( slices, 126 );
            rec.seincwm := Convert( slices, 127 );
            rec.selwks := Convert( slices, 128 );
            rec.seniiamt := Convert( slices, 129 );
            rec.seniinc := Convert( slices, 130 );
            rec.senilamt := Convert( slices, 131 );
            rec.senilump := Convert( slices, 132 );
            rec.seniramt := Convert( slices, 133 );
            rec.senireg := Convert( slices, 134 );
            rec.senirpd := Convert( slices, 135 );
            rec.setax := Convert( slices, 136 );
            rec.setaxamt := Convert( slices, 137 );
            rec.smpamt := Convert( slices, 138 );
            rec.smprate := Convert( slices, 139 );
            rec.sole := Convert( slices, 140 );
            rec.sppamt := Convert( slices, 141 );
            rec.sspamt := Convert( slices, 142 );
            rec.taxamt := Convert( slices, 143 );
            rec.taxdamt := Convert( slices, 144 );
            rec.taxdpd := Convert( slices, 145 );
            rec.totus1 := Convert( slices, 146 );
            rec.ubonamt := Convert( slices, 147 );
            rec.uboninc := Convert( slices, 148 );
            rec.udeduc1 := Convert( slices, 149 );
            rec.udeduc2 := Convert( slices, 150 );
            rec.udeduc3 := Convert( slices, 151 );
            rec.udeduc4 := Convert( slices, 152 );
            rec.udeduc5 := Convert( slices, 153 );
            rec.udeduc6 := Convert( slices, 154 );
            rec.udeduc7 := Convert( slices, 155 );
            rec.udeduc8 := Convert( slices, 156 );
            rec.ugross := Convert( slices, 157 );
            rec.uincpay1 := Convert( slices, 158 );
            rec.uincpay2 := Convert( slices, 159 );
            rec.uincpay3 := Convert( slices, 160 );
            rec.uincpay4 := Convert( slices, 161 );
            rec.uincpay5 := Convert( slices, 162 );
            rec.uincpay6 := Convert( slices, 163 );
            rec.uincpay7 := Convert( slices, 164 );
            rec.umileamt := Convert( slices, 165 );
            rec.umotamt := Convert( slices, 166 );
            rec.unett := Convert( slices, 167 );
            rec.uothded1 := Convert( slices, 168 );
            rec.uothded2 := Convert( slices, 169 );
            rec.uothded3 := Convert( slices, 170 );
            rec.uothded4 := Convert( slices, 171 );
            rec.uothded5 := Convert( slices, 172 );
            rec.uothded6 := Convert( slices, 173 );
            rec.uothded7 := Convert( slices, 174 );
            rec.uothded8 := Convert( slices, 175 );
            rec.uothded9 := Convert( slices, 176 );
            rec.uothdtot := Convert( slices, 177 );
            rec.uothr := Convert( slices, 178 );
            rec.upd := Convert( slices, 179 );
            rec.usapamt := Convert( slices, 180 );
            rec.usmpamt := Convert( slices, 181 );
            rec.usmprate := Convert( slices, 182 );
            rec.usppamt := Convert( slices, 183 );
            rec.usspamt := Convert( slices, 184 );
            rec.usuhr := Convert( slices, 185 );
            rec.utaxamt := Convert( slices, 186 );
            rec.watdid := Convert( slices, 187 );
            rec.watprev := Convert( slices, 188 );
            rec.where := Convert( slices, 189 );
            rec.whynopro := Convert( slices, 190 );
            rec.whynou01 := Convert( slices, 191 );
            rec.whynou02 := Convert( slices, 192 );
            rec.whynou03 := Convert( slices, 193 );
            rec.whynou04 := Convert( slices, 194 );
            rec.whynou05 := Convert( slices, 195 );
            rec.whynou06 := Convert( slices, 196 );
            rec.whynou07 := Convert( slices, 197 );
            rec.whynou08 := Convert( slices, 198 );
            rec.whynou09 := Convert( slices, 199 );
            rec.whynou10 := Convert( slices, 200 );
            rec.whynou11 := Convert( slices, 201 );
            rec.workacc := Convert( slices, 202 );
            rec.workmth := Convert( slices, 203 );
            rec.workyr := Convert( slices, 204 );
            rec.month := Convert( slices, 205 );
            rec.hdqhrs := Convert( slices, 206 );
            rec.jobhours := Convert( slices, 207 );
            rec.sspsmpfg := Convert( slices, 208 );
            rec.ugrspay := Convert( slices, 209 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0607;


   procedure Create_Maint_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.m := Convert( slices, 5 );
            rec.mrage := Convert( slices, 6 );
            rec.mramt := Convert( slices, 7 );
            rec.mrchwhy1 := Convert( slices, 8 );
            rec.mrchwhy2 := Convert( slices, 9 );
            rec.mrchwhy3 := Convert( slices, 10 );
            rec.mrchwhy4 := Convert( slices, 11 );
            rec.mrchwhy5 := Convert( slices, 12 );
            rec.mrchwhy6 := Convert( slices, 13 );
            rec.mrchwhy7 := Convert( slices, 14 );
            rec.mrchwhy8 := Convert( slices, 15 );
            rec.mrchwhy9 := Convert( slices, 16 );
            rec.mrct := Convert( slices, 17 );
            rec.mrkid := Convert( slices, 18 );
            rec.mrpd := Convert( slices, 19 );
            rec.mrr := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0607;


   procedure Create_MortCont_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.outsamt := Convert( slices, 4 );
            rec.outsincl := Convert( slices, 5 );
            rec.outspay := Convert( slices, 6 );
            rec.outspd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0607;


   procedure Create_Mortgage_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.loan2y := Convert( slices, 31 );
            rec.loanyear := Convert( slices, 32 );
            rec.menpol := Convert( slices, 33 );
            rec.morall := Convert( slices, 34 );
            rec.morflc := Convert( slices, 35 );
            rec.morinpay := Convert( slices, 36 );
            rec.morinpd := Convert( slices, 37 );
            rec.morinus := Convert( slices, 38 );
            rec.mortend := Convert( slices, 39 );
            rec.mortleft := Convert( slices, 40 );
            rec.mortprot := Convert( slices, 41 );
            rec.morttype := Convert( slices, 42 );
            rec.morupd := Convert( slices, 43 );
            rec.morus := Convert( slices, 44 );
            rec.mpcover1 := Convert( slices, 45 );
            rec.mpcover2 := Convert( slices, 46 );
            rec.mpcover3 := Convert( slices, 47 );
            rec.mpolno := Convert( slices, 48 );
            rec.outsmort := Convert( slices, 49 );
            rec.rentfrom := Convert( slices, 50 );
            rec.rmamt := Convert( slices, 51 );
            rec.rmort := Convert( slices, 52 );
            rec.rmortyr := Convert( slices, 53 );
            rec.rmpur001 := Convert( slices, 54 );
            rec.rmpur002 := Convert( slices, 55 );
            rec.rmpur003 := Convert( slices, 56 );
            rec.rmpur004 := Convert( slices, 57 );
            rec.rmpur005 := Convert( slices, 58 );
            rec.rmpur006 := Convert( slices, 59 );
            rec.rmpur007 := Convert( slices, 60 );
            rec.rmpur008 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0607;


   procedure Create_OddJob_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.ojamt := Convert( slices, 6 );
            rec.ojnow := Convert( slices, 7 );
            rec.ojreg := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0607;


   procedure Create_Owner_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.othmort1 := Convert( slices, 3 );
            rec.othmort2 := Convert( slices, 4 );
            rec.othmort3 := Convert( slices, 5 );
            rec.othpur1 := Convert( slices, 6 );
            rec.othpur2 := Convert( slices, 7 );
            rec.othpur3 := Convert( slices, 8 );
            rec.othpur31 := Convert( slices, 9 );
            rec.othpur32 := Convert( slices, 10 );
            rec.othpur33 := Convert( slices, 11 );
            rec.othpur34 := Convert( slices, 12 );
            rec.othpur35 := Convert( slices, 13 );
            rec.othpur36 := Convert( slices, 14 );
            rec.othpur37 := Convert( slices, 15 );
            rec.othpur4 := Convert( slices, 16 );
            rec.othpur5 := Convert( slices, 17 );
            rec.othpur6 := Convert( slices, 18 );
            rec.othpur7 := Convert( slices, 19 );
            rec.purcamt := Convert( slices, 20 );
            rec.purcloan := Convert( slices, 21 );
            rec.month := Convert( slices, 22 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0607;


   procedure Create_PenAmt_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.penq := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0607;


   procedure Create_PenProv_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppen := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eptype := Convert( slices, 6 );
            rec.penamt := Convert( slices, 7 );
            rec.penamtpd := Convert( slices, 8 );
            rec.pencon := Convert( slices, 9 );
            rec.pendat := Convert( slices, 10 );
            rec.pengov := Convert( slices, 11 );
            rec.penhelp := Convert( slices, 12 );
            rec.penmort := Convert( slices, 13 );
            rec.penreb := Convert( slices, 14 );
            rec.rebgov := Convert( slices, 15 );
            rec.spwho := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0607;


   procedure Create_Pension_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.penoth := Convert( slices, 6 );
            rec.penpay := Convert( slices, 7 );
            rec.penpd := Convert( slices, 8 );
            rec.pentax := Convert( slices, 9 );
            rec.pentype := Convert( slices, 10 );
            rec.poamt := Convert( slices, 11 );
            rec.poinc := Convert( slices, 12 );
            rec.posour := Convert( slices, 13 );
            rec.ptamt := Convert( slices, 14 );
            rec.ptinc := Convert( slices, 15 );
            rec.trights := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0607;


   procedure Create_RentCont_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0607;


   procedure Create_Renter_0607( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbweeks := Convert( slices, 28 );
            rec.hbyears := Convert( slices, 29 );
            rec.landlord := Convert( slices, 30 );
            rec.lowshort := Convert( slices, 31 );
            rec.niystart := Convert( slices, 32 );
            rec.othtype := Convert( slices, 33 );
            rec.rebate := Convert( slices, 34 );
            rec.rent := Convert( slices, 35 );
            rec.rentdk := Convert( slices, 36 );
            rec.rentdoc := Convert( slices, 37 );
            rec.rentfull := Convert( slices, 38 );
            rec.renthol := Convert( slices, 39 );
            rec.rentpd := Convert( slices, 40 );
            rec.resll := Convert( slices, 41 );
            rec.resll2 := Convert( slices, 42 );
            rec.serinc1 := Convert( slices, 43 );
            rec.serinc2 := Convert( slices, 44 );
            rec.serinc3 := Convert( slices, 45 );
            rec.serinc4 := Convert( slices, 46 );
            rec.serinc5 := Convert( slices, 47 );
            rec.tentype := Convert( slices, 48 );
            rec.weekhol := Convert( slices, 49 );
            rec.wsinc := Convert( slices, 50 );
            rec.wsincamt := Convert( slices, 51 );
            rec.ystartr := Convert( slices, 52 );
            rec.month := Convert( slices, 53 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0607;


   procedure Create_Account_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.nsamt := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0708;


   procedure Create_Admin_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.ncr1 := Convert( slices, 5 );
            rec.ncr2 := Convert( slices, 6 );
            rec.ncr3 := Convert( slices, 7 );
            rec.ncr4 := Convert( slices, 8 );
            rec.ncr5 := Convert( slices, 9 );
            rec.ncr6 := Convert( slices, 10 );
            rec.ncr7 := Convert( slices, 11 );
            rec.refr01 := Convert( slices, 12 );
            rec.refr02 := Convert( slices, 13 );
            rec.refr03 := Convert( slices, 14 );
            rec.refr04 := Convert( slices, 15 );
            rec.refr05 := Convert( slices, 16 );
            rec.refr06 := Convert( slices, 17 );
            rec.refr07 := Convert( slices, 18 );
            rec.refr08 := Convert( slices, 19 );
            rec.refr09 := Convert( slices, 20 );
            rec.refr10 := Convert( slices, 21 );
            rec.refr11 := Convert( slices, 22 );
            rec.refr12 := Convert( slices, 23 );
            rec.refr13 := Convert( slices, 24 );
            rec.refr14 := Convert( slices, 25 );
            rec.refr15 := Convert( slices, 26 );
            rec.refr16 := Convert( slices, 27 );
            rec.refr17 := Convert( slices, 28 );
            rec.refr18 := Convert( slices, 29 );
            rec.tnc := Convert( slices, 30 );
            rec.version := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0708;


   procedure Create_Adult_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.allow1 := Convert( slices, 21 );
            rec.allow2 := Convert( slices, 22 );
            rec.allow3 := Convert( slices, 23 );
            rec.allow4 := Convert( slices, 24 );
            rec.allpay1 := Convert( slices, 25 );
            rec.allpay2 := Convert( slices, 26 );
            rec.allpay3 := Convert( slices, 27 );
            rec.allpay4 := Convert( slices, 28 );
            rec.allpd1 := Convert( slices, 29 );
            rec.allpd2 := Convert( slices, 30 );
            rec.allpd3 := Convert( slices, 31 );
            rec.allpd4 := Convert( slices, 32 );
            rec.anyacc := Convert( slices, 33 );
            rec.anyed := Convert( slices, 34 );
            rec.anymon := Convert( slices, 35 );
            rec.anypen1 := Convert( slices, 36 );
            rec.anypen2 := Convert( slices, 37 );
            rec.anypen3 := Convert( slices, 38 );
            rec.anypen4 := Convert( slices, 39 );
            rec.anypen5 := Convert( slices, 40 );
            rec.anypen6 := Convert( slices, 41 );
            rec.anypen7 := Convert( slices, 42 );
            rec.apamt := Convert( slices, 43 );
            rec.apdamt := Convert( slices, 44 );
            rec.apdir := Convert( slices, 45 );
            rec.apdpd := Convert( slices, 46 );
            rec.appd := Convert( slices, 47 );
            rec.b2qfut1 := Convert( slices, 48 );
            rec.b2qfut2 := Convert( slices, 49 );
            rec.b2qfut3 := Convert( slices, 50 );
            rec.b3qfut1 := Convert( slices, 51 );
            rec.b3qfut2 := Convert( slices, 52 );
            rec.b3qfut3 := Convert( slices, 53 );
            rec.b3qfut4 := Convert( slices, 54 );
            rec.b3qfut5 := Convert( slices, 55 );
            rec.b3qfut6 := Convert( slices, 56 );
            rec.ben1q1 := Convert( slices, 57 );
            rec.ben1q2 := Convert( slices, 58 );
            rec.ben1q3 := Convert( slices, 59 );
            rec.ben1q4 := Convert( slices, 60 );
            rec.ben1q5 := Convert( slices, 61 );
            rec.ben1q6 := Convert( slices, 62 );
            rec.ben1q7 := Convert( slices, 63 );
            rec.ben2q1 := Convert( slices, 64 );
            rec.ben2q2 := Convert( slices, 65 );
            rec.ben2q3 := Convert( slices, 66 );
            rec.ben3q1 := Convert( slices, 67 );
            rec.ben3q2 := Convert( slices, 68 );
            rec.ben3q3 := Convert( slices, 69 );
            rec.ben3q4 := Convert( slices, 70 );
            rec.ben3q5 := Convert( slices, 71 );
            rec.ben3q6 := Convert( slices, 72 );
            rec.ben4q1 := Convert( slices, 73 );
            rec.ben4q2 := Convert( slices, 74 );
            rec.ben4q3 := Convert( slices, 75 );
            rec.ben5q1 := Convert( slices, 76 );
            rec.ben5q2 := Convert( slices, 77 );
            rec.ben5q3 := Convert( slices, 78 );
            rec.ben5q4 := Convert( slices, 79 );
            rec.ben5q5 := Convert( slices, 80 );
            rec.ben5q6 := Convert( slices, 81 );
            rec.ben5q7 := Convert( slices, 82 );
            rec.ben5q8 := Convert( slices, 83 );
            rec.ben5q9 := Convert( slices, 84 );
            rec.ben7q1 := Convert( slices, 85 );
            rec.ben7q2 := Convert( slices, 86 );
            rec.ben7q3 := Convert( slices, 87 );
            rec.ben7q4 := Convert( slices, 88 );
            rec.ben7q5 := Convert( slices, 89 );
            rec.ben7q6 := Convert( slices, 90 );
            rec.ben7q7 := Convert( slices, 91 );
            rec.ben7q8 := Convert( slices, 92 );
            rec.ben7q9 := Convert( slices, 93 );
            rec.chkdpn := Convert( slices, 94 );
            rec.chknop := Convert( slices, 95 );
            rec.claimant := Convert( slices, 96 );
            rec.cohabit := Convert( slices, 97 );
            rec.combid := Convert( slices, 98 );
            rec.consent := Convert( slices, 99 );
            rec.convbl := Convert( slices, 100 );
            rec.ctclum1 := Convert( slices, 101 );
            rec.ctclum2 := Convert( slices, 102 );
            rec.cupchk := Convert( slices, 103 );
            rec.cvht := Convert( slices, 104 );
            rec.cvpay := Convert( slices, 105 );
            rec.cvpd := Convert( slices, 106 );
            rec.ddatre := Convert( slices, 107 );
            rec.ddatrep := Convert( slices, 108 );
            rec.defrpen := Convert( slices, 109 );
            rec.depend := Convert( slices, 110 );
            rec.disdif1 := Convert( slices, 111 );
            rec.disdif2 := Convert( slices, 112 );
            rec.disdif3 := Convert( slices, 113 );
            rec.disdif4 := Convert( slices, 114 );
            rec.disdif5 := Convert( slices, 115 );
            rec.disdif6 := Convert( slices, 116 );
            rec.disdif7 := Convert( slices, 117 );
            rec.disdif8 := Convert( slices, 118 );
            rec.disdif9 := Convert( slices, 119 );
            rec.disdifp := Convert( slices, 120 );
            rec.dob := Convert( slices, 121 );
            rec.dvil03a := Convert( slices, 122 );
            rec.dvil04a := Convert( slices, 123 );
            rec.dvjb12ml := Convert( slices, 124 );
            rec.dvmardf := Convert( slices, 125 );
            rec.dvpens := Convert( slices, 126 );
            rec.ed1amt := Convert( slices, 127 );
            rec.ed1borr := Convert( slices, 128 );
            rec.ed1int := Convert( slices, 129 );
            rec.ed1monyr := Convert( slices, 130 );
            rec.ed1pd := Convert( slices, 131 );
            rec.ed1sum := Convert( slices, 132 );
            rec.ed2amt := Convert( slices, 133 );
            rec.ed2borr := Convert( slices, 134 );
            rec.ed2int := Convert( slices, 135 );
            rec.ed2monyr := Convert( slices, 136 );
            rec.ed2pd := Convert( slices, 137 );
            rec.ed2sum := Convert( slices, 138 );
            rec.edatt := Convert( slices, 139 );
            rec.edattn1 := Convert( slices, 140 );
            rec.edattn2 := Convert( slices, 141 );
            rec.edattn3 := Convert( slices, 142 );
            rec.edhr := Convert( slices, 143 );
            rec.edtime := Convert( slices, 144 );
            rec.edtyp := Convert( slices, 145 );
            rec.eligadlt := Convert( slices, 146 );
            rec.eligchld := Convert( slices, 147 );
            rec.eligschm := Convert( slices, 148 );
            rec.emparr := Convert( slices, 149 );
            rec.emppen := Convert( slices, 150 );
            rec.empschm := Convert( slices, 151 );
            rec.empstat := Convert( slices, 152 );
            rec.endyr := Convert( slices, 153 );
            rec.es2000 := Convert( slices, 154 );
            rec.ethgrp := Convert( slices, 155 );
            rec.everwrk := Convert( slices, 156 );
            rec.exthbct1 := Convert( slices, 157 );
            rec.exthbct2 := Convert( slices, 158 );
            rec.exthbct3 := Convert( slices, 159 );
            rec.followup := Convert( slices, 160 );
            rec.fted := Convert( slices, 161 );
            rec.ftwk := Convert( slices, 162 );
            rec.govpis := Convert( slices, 163 );
            rec.govpjsa := Convert( slices, 164 );
            rec.grant := Convert( slices, 165 );
            rec.grtamt1 := Convert( slices, 166 );
            rec.grtamt2 := Convert( slices, 167 );
            rec.grtdir1 := Convert( slices, 168 );
            rec.grtdir2 := Convert( slices, 169 );
            rec.grtnum := Convert( slices, 170 );
            rec.grtsce1 := Convert( slices, 171 );
            rec.grtsce2 := Convert( slices, 172 );
            rec.grtval1 := Convert( slices, 173 );
            rec.grtval2 := Convert( slices, 174 );
            rec.gta := Convert( slices, 175 );
            rec.hbothamt := Convert( slices, 176 );
            rec.hbothbu := Convert( slices, 177 );
            rec.hbothpd := Convert( slices, 178 );
            rec.hbothwk := Convert( slices, 179 );
            rec.hbotwait := Convert( slices, 180 );
            rec.health := Convert( slices, 181 );
            rec.hholder := Convert( slices, 182 );
            rec.hprob := Convert( slices, 183 );
            rec.hrpid := Convert( slices, 184 );
            rec.incdur := Convert( slices, 185 );
            rec.injlong := Convert( slices, 186 );
            rec.injwk := Convert( slices, 187 );
            rec.invests := Convert( slices, 188 );
            rec.iout := Convert( slices, 189 );
            rec.isa1type := Convert( slices, 190 );
            rec.isa2type := Convert( slices, 191 );
            rec.jobaway := Convert( slices, 192 );
            rec.lareg := Convert( slices, 193 );
            rec.likewk := Convert( slices, 194 );
            rec.lktime := Convert( slices, 195 );
            rec.ln1rpint := Convert( slices, 196 );
            rec.ln2rpint := Convert( slices, 197 );
            rec.lnkdwp := Convert( slices, 198 );
            rec.lnkons := Convert( slices, 199 );
            rec.lnkref1 := Convert( slices, 200 );
            rec.lnkref2 := Convert( slices, 201 );
            rec.lnkref3 := Convert( slices, 202 );
            rec.lnkref4 := Convert( slices, 203 );
            rec.lnkref5 := Convert( slices, 204 );
            rec.lnkref6 := Convert( slices, 205 );
            rec.lnkref7 := Convert( slices, 206 );
            rec.lnkref8 := Convert( slices, 207 );
            rec.lnkref9 := Convert( slices, 208 );
            rec.loan := Convert( slices, 209 );
            rec.loannum := Convert( slices, 210 );
            rec.look := Convert( slices, 211 );
            rec.lookwk := Convert( slices, 212 );
            rec.lstwrk1 := Convert( slices, 213 );
            rec.lstwrk2 := Convert( slices, 214 );
            rec.lstyr := Convert( slices, 215 );
            rec.memschm := Convert( slices, 216 );
            rec.mntamt1 := Convert( slices, 217 );
            rec.mntamt2 := Convert( slices, 218 );
            rec.mntct := Convert( slices, 219 );
            rec.mntfor1 := Convert( slices, 220 );
            rec.mntfor2 := Convert( slices, 221 );
            rec.mntgov1 := Convert( slices, 222 );
            rec.mntgov2 := Convert( slices, 223 );
            rec.mntpay := Convert( slices, 224 );
            rec.mntpd1 := Convert( slices, 225 );
            rec.mntpd2 := Convert( slices, 226 );
            rec.mntrec := Convert( slices, 227 );
            rec.mnttota1 := Convert( slices, 228 );
            rec.mnttota2 := Convert( slices, 229 );
            rec.mntus1 := Convert( slices, 230 );
            rec.mntus2 := Convert( slices, 231 );
            rec.mntusam1 := Convert( slices, 232 );
            rec.mntusam2 := Convert( slices, 233 );
            rec.mntuspd1 := Convert( slices, 234 );
            rec.mntuspd2 := Convert( slices, 235 );
            rec.ms := Convert( slices, 236 );
            rec.natid1 := Convert( slices, 237 );
            rec.natid2 := Convert( slices, 238 );
            rec.natid3 := Convert( slices, 239 );
            rec.natid4 := Convert( slices, 240 );
            rec.natid5 := Convert( slices, 241 );
            rec.natid6 := Convert( slices, 242 );
            rec.ndeal := Convert( slices, 243 );
            rec.newdtype := Convert( slices, 244 );
            rec.niamt := Convert( slices, 245 );
            rec.niethgrp := Convert( slices, 246 );
            rec.niexthbb := Convert( slices, 247 );
            rec.ninatid1 := Convert( slices, 248 );
            rec.ninatid2 := Convert( slices, 249 );
            rec.ninatid3 := Convert( slices, 250 );
            rec.ninatid4 := Convert( slices, 251 );
            rec.ninatid5 := Convert( slices, 252 );
            rec.ninatid6 := Convert( slices, 253 );
            rec.ninatid7 := Convert( slices, 254 );
            rec.ninatid8 := Convert( slices, 255 );
            rec.nipd := Convert( slices, 256 );
            rec.nireg := Convert( slices, 257 );
            rec.nirel := Convert( slices, 258 );
            rec.nitrain := Convert( slices, 259 );
            rec.nlper := Convert( slices, 260 );
            rec.nolk1 := Convert( slices, 261 );
            rec.nolk2 := Convert( slices, 262 );
            rec.nolk3 := Convert( slices, 263 );
            rec.nolook := Convert( slices, 264 );
            rec.nowant := Convert( slices, 265 );
            rec.nssec := Convert( slices, 266 );
            rec.ntcdat := Convert( slices, 267 );
            rec.ntcinc := Convert( slices, 268 );
            rec.numjob := Convert( slices, 269 );
            rec.numjob2 := Convert( slices, 270 );
            rec.oddjob := Convert( slices, 271 );
            rec.oldstud := Convert( slices, 272 );
            rec.otabspar := Convert( slices, 273 );
            rec.otamt := Convert( slices, 274 );
            rec.otapamt := Convert( slices, 275 );
            rec.otappd := Convert( slices, 276 );
            rec.othtax := Convert( slices, 277 );
            rec.otinva := Convert( slices, 278 );
            rec.pareamt := Convert( slices, 279 );
            rec.parepd := Convert( slices, 280 );
            rec.pconsent := Convert( slices, 281 );
            rec.penlump := Convert( slices, 282 );
            rec.perspen1 := Convert( slices, 283 );
            rec.perspen2 := Convert( slices, 284 );
            rec.ppnumc := Convert( slices, 285 );
            rec.practice := Convert( slices, 286 );
            rec.privpen := Convert( slices, 287 );
            rec.ptwk := Convert( slices, 288 );
            rec.r01 := Convert( slices, 289 );
            rec.r02 := Convert( slices, 290 );
            rec.r03 := Convert( slices, 291 );
            rec.r04 := Convert( slices, 292 );
            rec.r05 := Convert( slices, 293 );
            rec.r06 := Convert( slices, 294 );
            rec.r07 := Convert( slices, 295 );
            rec.r08 := Convert( slices, 296 );
            rec.r09 := Convert( slices, 297 );
            rec.r10 := Convert( slices, 298 );
            rec.r11 := Convert( slices, 299 );
            rec.r12 := Convert( slices, 300 );
            rec.r13 := Convert( slices, 301 );
            rec.r14 := Convert( slices, 302 );
            rec.redamt := Convert( slices, 303 );
            rec.redany := Convert( slices, 304 );
            rec.rentprof := Convert( slices, 305 );
            rec.retire := Convert( slices, 306 );
            rec.retire1 := Convert( slices, 307 );
            rec.retreas := Convert( slices, 308 );
            rec.royal1 := Convert( slices, 309 );
            rec.royal2 := Convert( slices, 310 );
            rec.royal3 := Convert( slices, 311 );
            rec.royal4 := Convert( slices, 312 );
            rec.royyr1 := Convert( slices, 313 );
            rec.royyr2 := Convert( slices, 314 );
            rec.royyr3 := Convert( slices, 315 );
            rec.royyr4 := Convert( slices, 316 );
            rec.rstrct := Convert( slices, 317 );
            rec.schchk := Convert( slices, 318 );
            rec.sex := Convert( slices, 319 );
            rec.sflntyp1 := Convert( slices, 320 );
            rec.sflntyp2 := Convert( slices, 321 );
            rec.sfrpis := Convert( slices, 322 );
            rec.sfrpjsa := Convert( slices, 323 );
            rec.sftype1 := Convert( slices, 324 );
            rec.sftype2 := Convert( slices, 325 );
            rec.sic := Convert( slices, 326 );
            rec.slrepamt := Convert( slices, 327 );
            rec.slrepay := Convert( slices, 328 );
            rec.slreppd := Convert( slices, 329 );
            rec.soc2000 := Convert( slices, 330 );
            rec.spcreg1 := Convert( slices, 331 );
            rec.spcreg2 := Convert( slices, 332 );
            rec.spcreg3 := Convert( slices, 333 );
            rec.spnumc := Convert( slices, 334 );
            rec.spout := Convert( slices, 335 );
            rec.srentamt := Convert( slices, 336 );
            rec.srentpd := Convert( slices, 337 );
            rec.stakep := Convert( slices, 338 );
            rec.start := Convert( slices, 339 );
            rec.startyr := Convert( slices, 340 );
            rec.taxcred1 := Convert( slices, 341 );
            rec.taxcred2 := Convert( slices, 342 );
            rec.taxfut := Convert( slices, 343 );
            rec.tcever1 := Convert( slices, 344 );
            rec.tcever2 := Convert( slices, 345 );
            rec.tcrepay1 := Convert( slices, 346 );
            rec.tcrepay2 := Convert( slices, 347 );
            rec.tcrepay3 := Convert( slices, 348 );
            rec.tcrepay4 := Convert( slices, 349 );
            rec.tcrepay5 := Convert( slices, 350 );
            rec.tcrepay6 := Convert( slices, 351 );
            rec.tcthsyr1 := Convert( slices, 352 );
            rec.tcthsyr2 := Convert( slices, 353 );
            rec.tdaywrk := Convert( slices, 354 );
            rec.tea := Convert( slices, 355 );
            rec.topupl := Convert( slices, 356 );
            rec.totint := Convert( slices, 357 );
            rec.train := Convert( slices, 358 );
            rec.trainee := Convert( slices, 359 );
            rec.tuborr := Convert( slices, 360 );
            rec.typeed := Convert( slices, 361 );
            rec.unpaid1 := Convert( slices, 362 );
            rec.unpaid2 := Convert( slices, 363 );
            rec.w1 := Convert( slices, 364 );
            rec.w2 := Convert( slices, 365 );
            rec.wait := Convert( slices, 366 );
            rec.war1 := Convert( slices, 367 );
            rec.war2 := Convert( slices, 368 );
            rec.whoresp := Convert( slices, 369 );
            rec.whosectb := Convert( slices, 370 );
            rec.wintfuel := Convert( slices, 371 );
            rec.wmkit := Convert( slices, 372 );
            rec.working := Convert( slices, 373 );
            rec.wpa := Convert( slices, 374 );
            rec.wpba := Convert( slices, 375 );
            rec.wtclum1 := Convert( slices, 376 );
            rec.wtclum2 := Convert( slices, 377 );
            rec.wtclum3 := Convert( slices, 378 );
            rec.ystrtwk := Convert( slices, 379 );
            rec.month := Convert( slices, 380 );
            rec.able := Convert( slices, 381 );
            rec.actacci := Convert( slices, 382 );
            rec.addda := Convert( slices, 383 );
            rec.age80 := Convert( slices, 384 );
            rec.basacti := Convert( slices, 385 );
            rec.bntxcred := Convert( slices, 386 );
            rec.careab := Convert( slices, 387 );
            rec.careah := Convert( slices, 388 );
            rec.carecb := Convert( slices, 389 );
            rec.carech := Convert( slices, 390 );
            rec.carecl := Convert( slices, 391 );
            rec.carefl := Convert( slices, 392 );
            rec.carefr := Convert( slices, 393 );
            rec.careot := Convert( slices, 394 );
            rec.carere := Convert( slices, 395 );
            rec.chbflg := Convert( slices, 396 );
            rec.crunaci := Convert( slices, 397 );
            rec.curacti := Convert( slices, 398 );
            rec.currjobm := Convert( slices, 399 );
            rec.empoccp := Convert( slices, 400 );
            rec.empstatb := Convert( slices, 401 );
            rec.empstatc := Convert( slices, 402 );
            rec.empstati := Convert( slices, 403 );
            rec.enomorti := Convert( slices, 404 );
            rec.ethgr2 := Convert( slices, 405 );
            rec.fsbndcti := Convert( slices, 406 );
            rec.fwmlkval := Convert( slices, 407 );
            rec.gebacti := Convert( slices, 408 );
            rec.giltcti := Convert( slices, 409 );
            rec.gross3 := Convert( slices, 410 );
            rec.hdage := Convert( slices, 411 );
            rec.hdben := Convert( slices, 412 );
            rec.hdindinc := Convert( slices, 413 );
            rec.hourab := Convert( slices, 414 );
            rec.hourah := Convert( slices, 415 );
            rec.hourcare := Convert( slices, 416 );
            rec.hourcb := Convert( slices, 417 );
            rec.hourch := Convert( slices, 418 );
            rec.hourcl := Convert( slices, 419 );
            rec.hourfr := Convert( slices, 420 );
            rec.hourot := Convert( slices, 421 );
            rec.hourre := Convert( slices, 422 );
            rec.hourtot := Convert( slices, 423 );
            rec.hperson := Convert( slices, 424 );
            rec.iagegr2 := Convert( slices, 425 );
            rec.iagegrp := Convert( slices, 426 );
            rec.incseo2 := Convert( slices, 427 );
            rec.indinc := Convert( slices, 428 );
            rec.indisben := Convert( slices, 429 );
            rec.inearns := Convert( slices, 430 );
            rec.ininv := Convert( slices, 431 );
            rec.inirben := Convert( slices, 432 );
            rec.innirben := Convert( slices, 433 );
            rec.inothben := Convert( slices, 434 );
            rec.inpeninc := Convert( slices, 435 );
            rec.inrinc := Convert( slices, 436 );
            rec.inrpinc := Convert( slices, 437 );
            rec.intvlic := Convert( slices, 438 );
            rec.intxcred := Convert( slices, 439 );
            rec.isacti := Convert( slices, 440 );
            rec.marital := Convert( slices, 441 );
            rec.nincseo2 := Convert( slices, 442 );
            rec.nindinc := Convert( slices, 443 );
            rec.ninearns := Convert( slices, 444 );
            rec.nininv := Convert( slices, 445 );
            rec.ninpenin := Convert( slices, 446 );
            rec.ninsein2 := Convert( slices, 447 );
            rec.nsbocti := Convert( slices, 448 );
            rec.occupnum := Convert( slices, 449 );
            rec.otbscti := Convert( slices, 450 );
            rec.pepscti := Convert( slices, 451 );
            rec.poaccti := Convert( slices, 452 );
            rec.pocardi := Convert( slices, 453 );
            rec.prbocti := Convert( slices, 454 );
            rec.prevjobm := Convert( slices, 455 );
            rec.relhrp := Convert( slices, 456 );
            rec.sapadj := Convert( slices, 457 );
            rec.sayecti := Convert( slices, 458 );
            rec.sclbcti := Convert( slices, 459 );
            rec.seincam2 := Convert( slices, 460 );
            rec.smpadj := Convert( slices, 461 );
            rec.sppadj := Convert( slices, 462 );
            rec.sscti := Convert( slices, 463 );
            rec.sspadj := Convert( slices, 464 );
            rec.stshcti := Convert( slices, 465 );
            rec.taxpayer := Convert( slices, 466 );
            rec.tesscti := Convert( slices, 467 );
            rec.totgrant := Convert( slices, 468 );
            rec.tothours := Convert( slices, 469 );
            rec.totoccp := Convert( slices, 470 );
            rec.untrcti := Convert( slices, 471 );
            rec.uperson := Convert( slices, 472 );
            rec.widoccp := Convert( slices, 473 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0708;


   procedure Create_Asset_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0708;


   procedure Create_Benefit_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.notusamt := Convert( slices, 16 );
            rec.notuspd := Convert( slices, 17 );
            rec.numweeks := Convert( slices, 18 );
            rec.ordbkno := Convert( slices, 19 );
            rec.payslipb := Convert( slices, 20 );
            rec.pres := Convert( slices, 21 );
            rec.usual := Convert( slices, 22 );
            rec.var1 := Convert( slices, 23 );
            rec.var2 := Convert( slices, 24 );
            rec.var3 := Convert( slices, 25 );
            rec.whorec1 := Convert( slices, 26 );
            rec.whorec2 := Convert( slices, 27 );
            rec.whorec3 := Convert( slices, 28 );
            rec.whorec4 := Convert( slices, 29 );
            rec.whorec5 := Convert( slices, 30 );
            rec.month := Convert( slices, 31 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0708;


   procedure Create_Benunit_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.cdelply := Convert( slices, 13 );
            rec.cdepbed := Convert( slices, 14 );
            rec.cdepcel := Convert( slices, 15 );
            rec.cdepeqp := Convert( slices, 16 );
            rec.cdephol := Convert( slices, 17 );
            rec.cdeples := Convert( slices, 18 );
            rec.cdepsum := Convert( slices, 19 );
            rec.cdeptea := Convert( slices, 20 );
            rec.cdeptrp := Convert( slices, 21 );
            rec.cplay := Convert( slices, 22 );
            rec.debt1 := Convert( slices, 23 );
            rec.debt2 := Convert( slices, 24 );
            rec.debt3 := Convert( slices, 25 );
            rec.debt4 := Convert( slices, 26 );
            rec.debt5 := Convert( slices, 27 );
            rec.debt6 := Convert( slices, 28 );
            rec.debt7 := Convert( slices, 29 );
            rec.debt8 := Convert( slices, 30 );
            rec.debt9 := Convert( slices, 31 );
            rec.houshe1 := Convert( slices, 32 );
            rec.incchnge := Convert( slices, 33 );
            rec.inchilow := Convert( slices, 34 );
            rec.incold := Convert( slices, 35 );
            rec.kidinc := Convert( slices, 36 );
            rec.nhhchild := Convert( slices, 37 );
            rec.totsav := Convert( slices, 38 );
            rec.month := Convert( slices, 39 );
            rec.actaccb := Convert( slices, 40 );
            rec.adddabu := Convert( slices, 41 );
            rec.adultb := Convert( slices, 42 );
            rec.basactb := Convert( slices, 43 );
            rec.boarder := Convert( slices, 44 );
            rec.bpeninc := Convert( slices, 45 );
            rec.bseinc := Convert( slices, 46 );
            rec.buagegr2 := Convert( slices, 47 );
            rec.buagegrp := Convert( slices, 48 );
            rec.budisben := Convert( slices, 49 );
            rec.buearns := Convert( slices, 50 );
            rec.buethgr2 := Convert( slices, 51 );
            rec.buinc := Convert( slices, 52 );
            rec.buinv := Convert( slices, 53 );
            rec.buirben := Convert( slices, 54 );
            rec.bukids := Convert( slices, 55 );
            rec.bunirben := Convert( slices, 56 );
            rec.buothben := Convert( slices, 57 );
            rec.burent := Convert( slices, 58 );
            rec.burinc := Convert( slices, 59 );
            rec.burpinc := Convert( slices, 60 );
            rec.butvlic := Convert( slices, 61 );
            rec.butxcred := Convert( slices, 62 );
            rec.chddabu := Convert( slices, 63 );
            rec.crunacb := Convert( slices, 64 );
            rec.curactb := Convert( slices, 65 );
            rec.depchldb := Convert( slices, 66 );
            rec.depdeds := Convert( slices, 67 );
            rec.disindhb := Convert( slices, 68 );
            rec.ecotypbu := Convert( slices, 69 );
            rec.ecstatbu := Convert( slices, 70 );
            rec.enomortb := Convert( slices, 71 );
            rec.famthbai := Convert( slices, 72 );
            rec.famtypbs := Convert( slices, 73 );
            rec.famtypbu := Convert( slices, 74 );
            rec.famtype := Convert( slices, 75 );
            rec.fsbndctb := Convert( slices, 76 );
            rec.fsmbu := Convert( slices, 77 );
            rec.fsmlkbu := Convert( slices, 78 );
            rec.fwmlkbu := Convert( slices, 79 );
            rec.gebactb := Convert( slices, 80 );
            rec.giltctb := Convert( slices, 81 );
            rec.gross3 := Convert( slices, 82 );
            rec.hbindbu := Convert( slices, 83 );
            rec.hbindbu2 := Convert( slices, 84 );
            rec.isactb := Convert( slices, 85 );
            rec.kid04 := Convert( slices, 86 );
            rec.kid1115 := Convert( slices, 87 );
            rec.kid1619 := Convert( slices, 88 );
            rec.kid510 := Convert( slices, 89 );
            rec.lastwork := Convert( slices, 90 );
            rec.lodger := Convert( slices, 91 );
            rec.nsboctb := Convert( slices, 92 );
            rec.otbsctb := Convert( slices, 93 );
            rec.pepsctb := Convert( slices, 94 );
            rec.poacctb := Convert( slices, 95 );
            rec.pocardb := Convert( slices, 96 );
            rec.prboctb := Convert( slices, 97 );
            rec.sayectb := Convert( slices, 98 );
            rec.sclbctb := Convert( slices, 99 );
            rec.ssctb := Convert( slices, 100 );
            rec.stshctb := Convert( slices, 101 );
            rec.subltamt := Convert( slices, 102 );
            rec.tessctb := Convert( slices, 103 );
            rec.totcapb2 := Convert( slices, 104 );
            rec.totcapbu := Convert( slices, 105 );
            rec.totsavbu := Convert( slices, 106 );
            rec.tuburent := Convert( slices, 107 );
            rec.untrctb := Convert( slices, 108 );
            rec.youngch := Convert( slices, 109 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0708;


   procedure Create_Care_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.wholoo01 := Convert( slices, 46 );
            rec.wholoo02 := Convert( slices, 47 );
            rec.wholoo03 := Convert( slices, 48 );
            rec.wholoo04 := Convert( slices, 49 );
            rec.wholoo05 := Convert( slices, 50 );
            rec.wholoo06 := Convert( slices, 51 );
            rec.wholoo07 := Convert( slices, 52 );
            rec.wholoo08 := Convert( slices, 53 );
            rec.wholoo09 := Convert( slices, 54 );
            rec.wholoo10 := Convert( slices, 55 );
            rec.wholoo11 := Convert( slices, 56 );
            rec.wholoo12 := Convert( slices, 57 );
            rec.wholoo13 := Convert( slices, 58 );
            rec.wholoo14 := Convert( slices, 59 );
            rec.wholoo15 := Convert( slices, 60 );
            rec.wholoo16 := Convert( slices, 61 );
            rec.wholoo17 := Convert( slices, 62 );
            rec.wholoo18 := Convert( slices, 63 );
            rec.wholoo19 := Convert( slices, 64 );
            rec.wholoo20 := Convert( slices, 65 );
            rec.month := Convert( slices, 66 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0708;


   procedure Create_Child_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddatre := Convert( slices, 7 );
            rec.cddatrep := Convert( slices, 8 );
            rec.cdisdif1 := Convert( slices, 9 );
            rec.cdisdif2 := Convert( slices, 10 );
            rec.cdisdif3 := Convert( slices, 11 );
            rec.cdisdif4 := Convert( slices, 12 );
            rec.cdisdif5 := Convert( slices, 13 );
            rec.cdisdif6 := Convert( slices, 14 );
            rec.cdisdif7 := Convert( slices, 15 );
            rec.cdisdif8 := Convert( slices, 16 );
            rec.cdisdif9 := Convert( slices, 17 );
            rec.cdisdifp := Convert( slices, 18 );
            rec.cfund := Convert( slices, 19 );
            rec.cfundh := Convert( slices, 20 );
            rec.cfundtp := Convert( slices, 21 );
            rec.chamtern := Convert( slices, 22 );
            rec.chamttst := Convert( slices, 23 );
            rec.chdla1 := Convert( slices, 24 );
            rec.chdla2 := Convert( slices, 25 );
            rec.chealth := Convert( slices, 26 );
            rec.chearns1 := Convert( slices, 27 );
            rec.chearns2 := Convert( slices, 28 );
            rec.chema := Convert( slices, 29 );
            rec.chemaamt := Convert( slices, 30 );
            rec.chemapd := Convert( slices, 31 );
            rec.chpdern := Convert( slices, 32 );
            rec.chpdtst := Convert( slices, 33 );
            rec.chprob := Convert( slices, 34 );
            rec.chsave := Convert( slices, 35 );
            rec.chwkern := Convert( slices, 36 );
            rec.chwktst := Convert( slices, 37 );
            rec.chyrern := Convert( slices, 38 );
            rec.chyrtst := Convert( slices, 39 );
            rec.cohabit := Convert( slices, 40 );
            rec.convbl := Convert( slices, 41 );
            rec.cvht := Convert( slices, 42 );
            rec.cvpay := Convert( slices, 43 );
            rec.cvpd := Convert( slices, 44 );
            rec.depend := Convert( slices, 45 );
            rec.dob := Convert( slices, 46 );
            rec.eligadlt := Convert( slices, 47 );
            rec.eligchld := Convert( slices, 48 );
            rec.endyr := Convert( slices, 49 );
            rec.fted := Convert( slices, 50 );
            rec.fundamt1 := Convert( slices, 51 );
            rec.fundamt2 := Convert( slices, 52 );
            rec.fundamt3 := Convert( slices, 53 );
            rec.fundamt4 := Convert( slices, 54 );
            rec.fundamt5 := Convert( slices, 55 );
            rec.fundamt6 := Convert( slices, 56 );
            rec.givcfnd1 := Convert( slices, 57 );
            rec.givcfnd2 := Convert( slices, 58 );
            rec.givcfnd3 := Convert( slices, 59 );
            rec.givcfnd4 := Convert( slices, 60 );
            rec.givcfnd5 := Convert( slices, 61 );
            rec.givcfnd6 := Convert( slices, 62 );
            rec.grant := Convert( slices, 63 );
            rec.grtamt1 := Convert( slices, 64 );
            rec.grtamt2 := Convert( slices, 65 );
            rec.grtdir1 := Convert( slices, 66 );
            rec.grtdir2 := Convert( slices, 67 );
            rec.grtnum := Convert( slices, 68 );
            rec.grtsce1 := Convert( slices, 69 );
            rec.grtsce2 := Convert( slices, 70 );
            rec.grtval1 := Convert( slices, 71 );
            rec.grtval2 := Convert( slices, 72 );
            rec.hholder := Convert( slices, 73 );
            rec.lareg := Convert( slices, 74 );
            rec.legdep := Convert( slices, 75 );
            rec.ms := Convert( slices, 76 );
            rec.parent1 := Convert( slices, 77 );
            rec.parent2 := Convert( slices, 78 );
            rec.r01 := Convert( slices, 79 );
            rec.r02 := Convert( slices, 80 );
            rec.r03 := Convert( slices, 81 );
            rec.r04 := Convert( slices, 82 );
            rec.r05 := Convert( slices, 83 );
            rec.r06 := Convert( slices, 84 );
            rec.r07 := Convert( slices, 85 );
            rec.r08 := Convert( slices, 86 );
            rec.r09 := Convert( slices, 87 );
            rec.r10 := Convert( slices, 88 );
            rec.r11 := Convert( slices, 89 );
            rec.r12 := Convert( slices, 90 );
            rec.r13 := Convert( slices, 91 );
            rec.r14 := Convert( slices, 92 );
            rec.schchk := Convert( slices, 93 );
            rec.sex := Convert( slices, 94 );
            rec.smkit := Convert( slices, 95 );
            rec.smlit := Convert( slices, 96 );
            rec.spcreg1 := Convert( slices, 97 );
            rec.spcreg2 := Convert( slices, 98 );
            rec.spcreg3 := Convert( slices, 99 );
            rec.spout := Convert( slices, 100 );
            rec.srentamt := Convert( slices, 101 );
            rec.srentpd := Convert( slices, 102 );
            rec.startyr := Convert( slices, 103 );
            rec.totsave := Convert( slices, 104 );
            rec.trainee := Convert( slices, 105 );
            rec.typeed := Convert( slices, 106 );
            rec.wmkit := Convert( slices, 107 );
            rec.month := Convert( slices, 108 );
            rec.careab := Convert( slices, 109 );
            rec.careah := Convert( slices, 110 );
            rec.carecb := Convert( slices, 111 );
            rec.carech := Convert( slices, 112 );
            rec.carecl := Convert( slices, 113 );
            rec.carefl := Convert( slices, 114 );
            rec.carefr := Convert( slices, 115 );
            rec.careot := Convert( slices, 116 );
            rec.carere := Convert( slices, 117 );
            rec.chdda := Convert( slices, 118 );
            rec.chearns := Convert( slices, 119 );
            rec.chincdv := Convert( slices, 120 );
            rec.chrinc := Convert( slices, 121 );
            rec.fsmlkval := Convert( slices, 122 );
            rec.fsmval := Convert( slices, 123 );
            rec.fwmlkval := Convert( slices, 124 );
            rec.hdagech := Convert( slices, 125 );
            rec.hourab := Convert( slices, 126 );
            rec.hourah := Convert( slices, 127 );
            rec.hourcb := Convert( slices, 128 );
            rec.hourch := Convert( slices, 129 );
            rec.hourcl := Convert( slices, 130 );
            rec.hourfr := Convert( slices, 131 );
            rec.hourot := Convert( slices, 132 );
            rec.hourre := Convert( slices, 133 );
            rec.hourtot := Convert( slices, 134 );
            rec.hperson := Convert( slices, 135 );
            rec.iagegr2 := Convert( slices, 136 );
            rec.iagegrp := Convert( slices, 137 );
            rec.relhrp := Convert( slices, 138 );
            rec.totgntch := Convert( slices, 139 );
            rec.tuacam := Convert( slices, 140 );
            rec.uperson := Convert( slices, 141 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0708;


   procedure Create_ChildCare_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.benccdis := Convert( slices, 5 );
            rec.chamt := Convert( slices, 6 );
            rec.chhr := Convert( slices, 7 );
            rec.chinknd1 := Convert( slices, 8 );
            rec.chinknd2 := Convert( slices, 9 );
            rec.chinknd3 := Convert( slices, 10 );
            rec.chinknd4 := Convert( slices, 11 );
            rec.chinknd5 := Convert( slices, 12 );
            rec.chpd := Convert( slices, 13 );
            rec.cost := Convert( slices, 14 );
            rec.ctrm := Convert( slices, 15 );
            rec.emplprov := Convert( slices, 16 );
            rec.pmchk := Convert( slices, 17 );
            rec.registrd := Convert( slices, 18 );
            rec.month := Convert( slices, 19 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_0708;


   procedure Create_Endowment_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.menpolam := Convert( slices, 5 );
            rec.menpolpd := Convert( slices, 6 );
            rec.menstyr := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0708;


   procedure Create_ExtChild_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.nhhamt := Convert( slices, 4 );
            rec.nhhfee := Convert( slices, 5 );
            rec.nhhintro := Convert( slices, 6 );
            rec.nhhpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0708;


   procedure Create_GovPay_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.month := Convert( slices, 6 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0708;


   procedure Create_Hbai_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.sernum := Convert( slices, 19 );
            rec.benunits := Convert( slices, 20 );
            rec.gvtregn := Convert( slices, 21 );
            rec.hhstat := Convert( slices, 22 );
            rec.tenure := Convert( slices, 23 );
            rec.adulth := Convert( slices, 24 );
            rec.depchldh := Convert( slices, 25 );
            rec.ptentyp2 := Convert( slices, 26 );
            rec.tentyp2 := Convert( slices, 27 );
            rec.watsewrt := Convert( slices, 28 );
            rec.sewerage := Convert( slices, 29 );
            rec.cwathh := Convert( slices, 30 );
            rec.totsthh := Convert( slices, 31 );
            rec.totstrhh := Convert( slices, 32 );
            rec.charghh := Convert( slices, 33 );
            rec.hbmort := Convert( slices, 34 );
            rec.hbxmort := Convert( slices, 35 );
            rec.hrenthh := Convert( slices, 36 );
            rec.erenthh := Convert( slices, 37 );
            rec.hbenhh := Convert( slices, 38 );
            rec.watsewhh := Convert( slices, 39 );
            rec.hhcost := Convert( slices, 40 );
            rec.ehcost := Convert( slices, 41 );
            rec.bhcdef := Convert( slices, 42 );
            rec.ahcdef := Convert( slices, 43 );
            rec.ctrebam1 := Convert( slices, 44 );
            rec.cwatadj := Convert( slices, 45 );
            rec.adultb := Convert( slices, 46 );
            rec.egrincbu := Convert( slices, 47 );
            rec.entincbu := Convert( slices, 48 );
            rec.hgrernhh := Convert( slices, 49 );
            rec.hnternhh := Convert( slices, 50 );
            rec.hgrinvhh := Convert( slices, 51 );
            rec.hntinvhh := Convert( slices, 52 );
            rec.hgrocchh := Convert( slices, 53 );
            rec.hntocchh := Convert( slices, 54 );
            rec.hbeninhh := Convert( slices, 55 );
            rec.hpribnhh := Convert( slices, 56 );
            rec.hmiscihh := Convert( slices, 57 );
            rec.sfrpahh := Convert( slices, 58 );
            rec.hgrinchh := Convert( slices, 59 );
            rec.hntinchh := Convert( slices, 60 );
            rec.inchilhh := Convert( slices, 61 );
            rec.ethgrphh := Convert( slices, 62 );
            rec.egrernhh := Convert( slices, 63 );
            rec.enternhh := Convert( slices, 64 );
            rec.ebeninhh := Convert( slices, 65 );
            rec.epribnhh := Convert( slices, 66 );
            rec.emiscihh := Convert( slices, 67 );
            rec.eothdehh := Convert( slices, 68 );
            rec.egrinchh := Convert( slices, 69 );
            rec.entinchh := Convert( slices, 70 );
            rec.tvlichh := Convert( slices, 71 );
            rec.g_newhh := Convert( slices, 72 );
            rec.gnewhhp := Convert( slices, 73 );
            rec.esgjobhh := Convert( slices, 74 );
            rec.esgrsehh := Convert( slices, 75 );
            rec.esginvhh := Convert( slices, 76 );
            rec.esgocchh := Convert( slices, 77 );
            rec.esmischh := Convert( slices, 78 );
            rec.espribhh := Convert( slices, 79 );
            rec.esbenihh := Convert( slices, 80 );
            rec.esothdhh := Convert( slices, 81 );
            rec.esginchh := Convert( slices, 82 );
            rec.esninchh := Convert( slices, 83 );
            rec.ericphh := Convert( slices, 84 );
            rec.ericnphh := Convert( slices, 85 );
            rec.gs_newhh := Convert( slices, 86 );
            rec.gs_newpph := Convert( slices, 87 );
            rec.es_hcost := Convert( slices, 88 );
            rec.esahchh := Convert( slices, 89 );
            rec.eahchh := Convert( slices, 90 );
            rec.benunit := Convert( slices, 91 );
            rec.depchldb := Convert( slices, 92 );
            rec.eqmcoup := Convert( slices, 93 );
            rec.eqmbhckd := Convert( slices, 94 );
            rec.eqmahckd := Convert( slices, 95 );
            rec.eqmbhchh := Convert( slices, 96 );
            rec.eqmahchh := Convert( slices, 97 );
            rec.over14 := Convert( slices, 98 );
            rec.under14 := Convert( slices, 99 );
            rec.eqobhchh := Convert( slices, 100 );
            rec.eqoahchh := Convert( slices, 101 );
            rec.mc_bhc := Convert( slices, 102 );
            rec.oe_bhc := Convert( slices, 103 );
            rec.mc_gro := Convert( slices, 104 );
            rec.oe_gro := Convert( slices, 105 );
            rec.mc_ahc := Convert( slices, 106 );
            rec.oe_ahc := Convert( slices, 107 );
            rec.s_mc_bhc := Convert( slices, 108 );
            rec.s_oe_bhc := Convert( slices, 109 );
            rec.s_mc_gro := Convert( slices, 110 );
            rec.s_oe_gro := Convert( slices, 111 );
            rec.s_mc_ahc := Convert( slices, 112 );
            rec.s_oe_ahc := Convert( slices, 113 );
            rec.famthbai := Convert( slices, 114 );
            rec.fsmbu := Convert( slices, 115 );
            rec.fsmlkbu := Convert( slices, 116 );
            rec.fwmlkbu := Convert( slices, 117 );
            rec.hbenbu := Convert( slices, 118 );
            rec.ehbenbu := Convert( slices, 119 );
            rec.srentbu := Convert( slices, 120 );
            rec.rentbu := Convert( slices, 121 );
            rec.erentbu := Convert( slices, 122 );
            rec.insebu := Convert( slices, 123 );
            rec.ginsebu := Convert( slices, 124 );
            rec.hgrernbu := Convert( slices, 125 );
            rec.hnternbu := Convert( slices, 126 );
            rec.hgrinvbu := Convert( slices, 127 );
            rec.hntinvbu := Convert( slices, 128 );
            rec.hgroccbu := Convert( slices, 129 );
            rec.hntoccbu := Convert( slices, 130 );
            rec.hbeninbu := Convert( slices, 131 );
            rec.hpribnbu := Convert( slices, 132 );
            rec.hmiscibu := Convert( slices, 133 );
            rec.sfrpabu := Convert( slices, 134 );
            rec.hgrincbu := Convert( slices, 135 );
            rec.hntincbu := Convert( slices, 136 );
            rec.egrernbu := Convert( slices, 137 );
            rec.enternbu := Convert( slices, 138 );
            rec.ebeninbu := Convert( slices, 139 );
            rec.epribnbu := Convert( slices, 140 );
            rec.emiscibu := Convert( slices, 141 );
            rec.eothdebu := Convert( slices, 142 );
            rec.winpaybu := Convert( slices, 143 );
            rec.tvlicbu := Convert( slices, 144 );
            rec.oldecobu := Convert( slices, 145 );
            rec.disabflg := Convert( slices, 146 );
            rec.fambu := Convert( slices, 147 );
            rec.newfambu := Convert( slices, 148 );
            rec.personhd := Convert( slices, 149 );
            rec.personsp := Convert( slices, 150 );
            rec.oldkidecobu := Convert( slices, 151 );
            rec.kid0_1 := Convert( slices, 152 );
            rec.kid2_4 := Convert( slices, 153 );
            rec.kid5_7 := Convert( slices, 154 );
            rec.kid8_10 := Convert( slices, 155 );
            rec.kid11_12 := Convert( slices, 156 );
            rec.kid13_15 := Convert( slices, 157 );
            rec.kid16_19 := Convert( slices, 158 );
            rec.boys := Convert( slices, 159 );
            rec.wtcbu := Convert( slices, 160 );
            rec.ctcbu := Convert( slices, 161 );
            rec.isbu := Convert( slices, 162 );
            rec.inchilbu := Convert( slices, 163 );
            rec.g_newbu := Convert( slices, 164 );
            rec.g_newpp := Convert( slices, 165 );
            rec.g_newch := Convert( slices, 166 );
            rec.g_newad := Convert( slices, 167 );
            rec.g_newpn := Convert( slices, 168 );
            rec.g_newwa := Convert( slices, 169 );
            rec.esgjobbu := Convert( slices, 170 );
            rec.esgrsebu := Convert( slices, 171 );
            rec.esginvbu := Convert( slices, 172 );
            rec.esgoccbu := Convert( slices, 173 );
            rec.esmiscbu := Convert( slices, 174 );
            rec.espribbu := Convert( slices, 175 );
            rec.esbenibu := Convert( slices, 176 );
            rec.esothdbu := Convert( slices, 177 );
            rec.esgincbu := Convert( slices, 178 );
            rec.esnincbu := Convert( slices, 179 );
            rec.ericpbu := Convert( slices, 180 );
            rec.ericnpbu := Convert( slices, 181 );
            rec.gs_newbu := Convert( slices, 182 );
            rec.gs_newpp := Convert( slices, 183 );
            rec.gs_newch := Convert( slices, 184 );
            rec.gs_newad := Convert( slices, 185 );
            rec.gs_newpn := Convert( slices, 186 );
            rec.gs_newwa := Convert( slices, 187 );
            rec.mbhcdec := Convert( slices, 188 );
            rec.mqinbhc := Convert( slices, 189 );
            rec.obhcdec := Convert( slices, 190 );
            rec.oqinbhc := Convert( slices, 191 );
            rec.mahcdec := Convert( slices, 192 );
            rec.mqinahc := Convert( slices, 193 );
            rec.oahcdec := Convert( slices, 194 );
            rec.oqinahc := Convert( slices, 195 );
            rec.agehd := Convert( slices, 196 );
            rec.sexhd := Convert( slices, 197 );
            rec.esbenihd := Convert( slices, 198 );
            rec.esgjobhd := Convert( slices, 200 );
            rec.esgocchd := Convert( slices, 201 );
            rec.esgrsehd := Convert( slices, 202 );
            rec.esmischd := Convert( slices, 203 );
            rec.espribhd := Convert( slices, 204 );
            rec.agesp := Convert( slices, 205 );
            rec.sexsp := Convert( slices, 206 );
            rec.esbenisp := Convert( slices, 207 );
            rec.esginvsp := Convert( slices, 208 );
            rec.esgjobsp := Convert( slices, 209 );
            rec.esgoccsp := Convert( slices, 210 );
            rec.esgrsesp := Convert( slices, 211 );
            rec.esmiscsp := Convert( slices, 212 );
            rec.espribsp := Convert( slices, 213 );
            rec.low50bhc := Convert( slices, 214 );
            rec.low60bhc := Convert( slices, 215 );
            rec.low70bhc := Convert( slices, 216 );
            rec.low50ahc := Convert( slices, 217 );
            rec.low60ahc := Convert( slices, 218 );
            rec.low70ahc := Convert( slices, 219 );
            rec.mdscorech := Convert( slices, 220 );
            rec.mdch := Convert( slices, 221 );
            rec.lowincmdch := Convert( slices, 222 );
            rec.ecobu := Convert( slices, 223 );
            rec.kidecobu := Convert( slices, 224 );
            rec.sehhflg := Convert( slices, 225 );
            rec.oldsehhflg := Convert( slices, 226 );
            rec.lowincmdchsev := Convert( slices, 227 );
            rec.mbhcdecx := Convert( slices, 228 );
            rec.mqinbhcx := Convert( slices, 229 );
            rec.obhcdecx := Convert( slices, 230 );
            rec.oqinbhcx := Convert( slices, 231 );
            rec.mahcdecx := Convert( slices, 232 );
            rec.mqinahcx := Convert( slices, 233 );
            rec.oahcdecx := Convert( slices, 234 );
            rec.oqinahcx := Convert( slices, 235 );
            rec.lowmcbhc := Convert( slices, 236 );
            rec.lowmcahc := Convert( slices, 237 );
            rec.chbenhh := Convert( slices, 238 );
            rec.chbenbu := Convert( slices, 239 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0708;


   procedure Create_Household_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.bedroom := Convert( slices, 2 );
            rec.benunits := Convert( slices, 3 );
            rec.billrate := Convert( slices, 4 );
            rec.busroom := Convert( slices, 5 );
            rec.charge1 := Convert( slices, 6 );
            rec.charge2 := Convert( slices, 7 );
            rec.charge3 := Convert( slices, 8 );
            rec.charge4 := Convert( slices, 9 );
            rec.charge5 := Convert( slices, 10 );
            rec.charge6 := Convert( slices, 11 );
            rec.charge7 := Convert( slices, 12 );
            rec.charge8 := Convert( slices, 13 );
            rec.charge9 := Convert( slices, 14 );
            rec.chins := Convert( slices, 15 );
            rec.chrgamt1 := Convert( slices, 16 );
            rec.chrgamt2 := Convert( slices, 17 );
            rec.chrgamt3 := Convert( slices, 18 );
            rec.chrgamt4 := Convert( slices, 19 );
            rec.chrgamt5 := Convert( slices, 20 );
            rec.chrgamt6 := Convert( slices, 21 );
            rec.chrgamt7 := Convert( slices, 22 );
            rec.chrgamt8 := Convert( slices, 23 );
            rec.chrgamt9 := Convert( slices, 24 );
            rec.chrgpd1 := Convert( slices, 25 );
            rec.chrgpd2 := Convert( slices, 26 );
            rec.chrgpd3 := Convert( slices, 27 );
            rec.chrgpd4 := Convert( slices, 28 );
            rec.chrgpd5 := Convert( slices, 29 );
            rec.chrgpd6 := Convert( slices, 30 );
            rec.chrgpd7 := Convert( slices, 31 );
            rec.chrgpd8 := Convert( slices, 32 );
            rec.chrgpd9 := Convert( slices, 33 );
            rec.covoths := Convert( slices, 34 );
            rec.csewamt := Convert( slices, 35 );
            rec.csewamt1 := Convert( slices, 36 );
            rec.ct25d50d := Convert( slices, 37 );
            rec.ctamt := Convert( slices, 38 );
            rec.ctannual := Convert( slices, 39 );
            rec.ctband := Convert( slices, 40 );
            rec.ctbwait := Convert( slices, 41 );
            rec.ctcondoc := Convert( slices, 42 );
            rec.ctdisc := Convert( slices, 43 );
            rec.ctinstal := Convert( slices, 44 );
            rec.ctlvband := Convert( slices, 45 );
            rec.ctlvchk := Convert( slices, 46 );
            rec.ctreb := Convert( slices, 47 );
            rec.ctrebamt := Convert( slices, 48 );
            rec.ctrebpd := Convert( slices, 49 );
            rec.cttime := Convert( slices, 50 );
            rec.cwatamt := Convert( slices, 51 );
            rec.cwatamt1 := Convert( slices, 52 );
            rec.datyrago := Convert( slices, 53 );
            rec.dvadulth := Convert( slices, 54 );
            rec.dvtotad := Convert( slices, 55 );
            rec.entry1 := Convert( slices, 56 );
            rec.entry2 := Convert( slices, 57 );
            rec.entry3 := Convert( slices, 58 );
            rec.entry4 := Convert( slices, 59 );
            rec.entry5 := Convert( slices, 60 );
            rec.entry6 := Convert( slices, 61 );
            rec.floor := Convert( slices, 62 );
            rec.givehelp := Convert( slices, 63 );
            rec.gvtregn := Convert( slices, 64 );
            rec.hhldr01 := Convert( slices, 65 );
            rec.hhldr02 := Convert( slices, 66 );
            rec.hhldr03 := Convert( slices, 67 );
            rec.hhldr04 := Convert( slices, 68 );
            rec.hhldr05 := Convert( slices, 69 );
            rec.hhldr06 := Convert( slices, 70 );
            rec.hhldr07 := Convert( slices, 71 );
            rec.hhldr08 := Convert( slices, 72 );
            rec.hhldr09 := Convert( slices, 73 );
            rec.hhldr10 := Convert( slices, 74 );
            rec.hhldr11 := Convert( slices, 75 );
            rec.hhldr12 := Convert( slices, 76 );
            rec.hhldr13 := Convert( slices, 77 );
            rec.hhldr14 := Convert( slices, 78 );
            rec.hhldr97 := Convert( slices, 79 );
            rec.hhstat := Convert( slices, 80 );
            rec.hrpnum := Convert( slices, 81 );
            rec.imd_e := Convert( slices, 82 );
            rec.imd_s := Convert( slices, 83 );
            rec.imd_w := Convert( slices, 84 );
            rec.intdate := Convert( slices, 85 );
            rec.lac := Convert( slices, 86 );
            rec.mainacc := Convert( slices, 87 );
            rec.mnthcode := Convert( slices, 88 );
            rec.monlive := Convert( slices, 89 );
            rec.needhelp := Convert( slices, 90 );
            rec.nicoun := Convert( slices, 91 );
            rec.ninrv := Convert( slices, 92 );
            rec.nirate := Convert( slices, 93 );
            rec.norate := Convert( slices, 94 );
            rec.numtv1 := Convert( slices, 95 );
            rec.numtv2 := Convert( slices, 96 );
            rec.oac := Convert( slices, 97 );
            rec.onbsroom := Convert( slices, 98 );
            rec.orgsewam := Convert( slices, 99 );
            rec.orgwatam := Convert( slices, 100 );
            rec.payrate := Convert( slices, 101 );
            rec.ptbsroom := Convert( slices, 102 );
            rec.rooms := Convert( slices, 103 );
            rec.roomshar := Convert( slices, 104 );
            rec.rtannual := Convert( slices, 105 );
            rec.rtcondoc := Convert( slices, 106 );
            rec.rtdeduc := Convert( slices, 107 );
            rec.rtinstal := Convert( slices, 108 );
            rec.rtreb := Convert( slices, 109 );
            rec.rtrebamt := Convert( slices, 110 );
            rec.rtrebpd := Convert( slices, 111 );
            rec.rttime := Convert( slices, 112 );
            rec.sampqtr := Convert( slices, 113 );
            rec.schmeal := Convert( slices, 114 );
            rec.schmilk := Convert( slices, 115 );
            rec.sewamt := Convert( slices, 116 );
            rec.sewanul := Convert( slices, 117 );
            rec.sewerpay := Convert( slices, 118 );
            rec.sewsep := Convert( slices, 119 );
            rec.sewtime := Convert( slices, 120 );
            rec.shelter := Convert( slices, 121 );
            rec.sobuy := Convert( slices, 122 );
            rec.sstrtreg := Convert( slices, 123 );
            rec.stramt1 := Convert( slices, 124 );
            rec.stramt2 := Convert( slices, 125 );
            rec.strcov := Convert( slices, 126 );
            rec.strmort := Convert( slices, 127 );
            rec.stroths := Convert( slices, 128 );
            rec.strpd1 := Convert( slices, 129 );
            rec.strpd2 := Convert( slices, 130 );
            rec.suballow := Convert( slices, 131 );
            rec.sublet := Convert( slices, 132 );
            rec.sublety := Convert( slices, 133 );
            rec.subrent := Convert( slices, 134 );
            rec.tenure := Convert( slices, 135 );
            rec.totchild := Convert( slices, 136 );
            rec.totdepdk := Convert( slices, 137 );
            rec.tvlic := Convert( slices, 138 );
            rec.typeacc := Convert( slices, 139 );
            rec.urindew := Convert( slices, 140 );
            rec.urinds := Convert( slices, 141 );
            rec.watamt := Convert( slices, 142 );
            rec.watanul := Convert( slices, 143 );
            rec.watermet := Convert( slices, 144 );
            rec.waterpay := Convert( slices, 145 );
            rec.watrb := Convert( slices, 146 );
            rec.wattime := Convert( slices, 147 );
            rec.welfmilk := Convert( slices, 148 );
            rec.whoctb01 := Convert( slices, 149 );
            rec.whoctb02 := Convert( slices, 150 );
            rec.whoctb03 := Convert( slices, 151 );
            rec.whoctb04 := Convert( slices, 152 );
            rec.whoctb05 := Convert( slices, 153 );
            rec.whoctb06 := Convert( slices, 154 );
            rec.whoctb07 := Convert( slices, 155 );
            rec.whoctb08 := Convert( slices, 156 );
            rec.whoctb09 := Convert( slices, 157 );
            rec.whoctb10 := Convert( slices, 158 );
            rec.whoctb11 := Convert( slices, 159 );
            rec.whoctb12 := Convert( slices, 160 );
            rec.whoctb13 := Convert( slices, 161 );
            rec.whoctb14 := Convert( slices, 162 );
            rec.whoctbns := Convert( slices, 163 );
            rec.whoctbot := Convert( slices, 164 );
            rec.whorsp01 := Convert( slices, 165 );
            rec.whorsp02 := Convert( slices, 166 );
            rec.whorsp03 := Convert( slices, 167 );
            rec.whorsp04 := Convert( slices, 168 );
            rec.whorsp05 := Convert( slices, 169 );
            rec.whorsp06 := Convert( slices, 170 );
            rec.whorsp07 := Convert( slices, 171 );
            rec.whorsp08 := Convert( slices, 172 );
            rec.whorsp09 := Convert( slices, 173 );
            rec.whorsp10 := Convert( slices, 174 );
            rec.whorsp11 := Convert( slices, 175 );
            rec.whorsp12 := Convert( slices, 176 );
            rec.whorsp13 := Convert( slices, 177 );
            rec.whorsp14 := Convert( slices, 178 );
            rec.whynoct := Convert( slices, 179 );
            rec.wmintro := Convert( slices, 180 );
            rec.wsewamt := Convert( slices, 181 );
            rec.wsewanul := Convert( slices, 182 );
            rec.wsewtime := Convert( slices, 183 );
            rec.yearcode := Convert( slices, 184 );
            rec.yearlive := Convert( slices, 185 );
            rec.month := Convert( slices, 186 );
            rec.actacch := Convert( slices, 187 );
            rec.adddahh := Convert( slices, 188 );
            rec.adulth := Convert( slices, 189 );
            rec.basacth := Convert( slices, 190 );
            rec.bedroom6 := Convert( slices, 191 );
            rec.chddahh := Convert( slices, 192 );
            rec.country := Convert( slices, 193 );
            rec.crunach := Convert( slices, 194 );
            rec.curacth := Convert( slices, 195 );
            rec.cwatamtd := Convert( slices, 196 );
            rec.depchldh := Convert( slices, 197 );
            rec.emp := Convert( slices, 198 );
            rec.emphrp := Convert( slices, 199 );
            rec.endowpay := Convert( slices, 200 );
            rec.enomorth := Convert( slices, 201 );
            rec.fsbndcth := Convert( slices, 202 );
            rec.gbhscost := Convert( slices, 203 );
            rec.gebacth := Convert( slices, 204 );
            rec.giltcth := Convert( slices, 205 );
            rec.gross3 := Convert( slices, 206 );
            rec.grossct := Convert( slices, 207 );
            rec.hbeninc := Convert( slices, 208 );
            rec.hbindhh := Convert( slices, 209 );
            rec.hbindhh2 := Convert( slices, 210 );
            rec.hcband := Convert( slices, 211 );
            rec.hdhhinc := Convert( slices, 212 );
            rec.hdtax := Convert( slices, 213 );
            rec.hearns := Convert( slices, 214 );
            rec.hhagegr2 := Convert( slices, 215 );
            rec.hhagegrp := Convert( slices, 216 );
            rec.hhcomp := Convert( slices, 217 );
            rec.hhcomps := Convert( slices, 218 );
            rec.hhdisben := Convert( slices, 219 );
            rec.hhethgr2 := Convert( slices, 220 );
            rec.hhinc := Convert( slices, 221 );
            rec.hhincbnd := Convert( slices, 222 );
            rec.hhinv := Convert( slices, 223 );
            rec.hhirben := Convert( slices, 224 );
            rec.hhkids := Convert( slices, 225 );
            rec.hhnirben := Convert( slices, 226 );
            rec.hhothben := Convert( slices, 227 );
            rec.hhrent := Convert( slices, 228 );
            rec.hhrinc := Convert( slices, 229 );
            rec.hhrpinc := Convert( slices, 230 );
            rec.hhsize := Convert( slices, 231 );
            rec.hhtvlic := Convert( slices, 232 );
            rec.hhtxcred := Convert( slices, 233 );
            rec.hothinc := Convert( slices, 234 );
            rec.hpeninc := Convert( slices, 235 );
            rec.hrband := Convert( slices, 236 );
            rec.hseinc := Convert( slices, 237 );
            rec.isacth := Convert( slices, 238 );
            rec.london := Convert( slices, 239 );
            rec.mortcost := Convert( slices, 240 );
            rec.mortint := Convert( slices, 241 );
            rec.mortpay := Convert( slices, 242 );
            rec.nddctb := Convert( slices, 243 );
            rec.nddishc := Convert( slices, 244 );
            rec.nihscost := Convert( slices, 245 );
            rec.nsbocth := Convert( slices, 246 );
            rec.otbscth := Convert( slices, 247 );
            rec.pacctype := Convert( slices, 248 );
            rec.penage := Convert( slices, 249 );
            rec.penhrp := Convert( slices, 250 );
            rec.pepscth := Convert( slices, 251 );
            rec.poaccth := Convert( slices, 252 );
            rec.pocardh := Convert( slices, 253 );
            rec.prbocth := Convert( slices, 254 );
            rec.ptentyp2 := Convert( slices, 255 );
            rec.rooms10 := Convert( slices, 256 );
            rec.sayecth := Convert( slices, 257 );
            rec.sclbcth := Convert( slices, 258 );
            rec.servpay := Convert( slices, 259 );
            rec.sick := Convert( slices, 260 );
            rec.sickhrp := Convert( slices, 261 );
            rec.sscth := Convert( slices, 262 );
            rec.struins := Convert( slices, 263 );
            rec.stshcth := Convert( slices, 264 );
            rec.tentyp2 := Convert( slices, 265 );
            rec.tesscth := Convert( slices, 266 );
            rec.tuhhrent := Convert( slices, 267 );
            rec.tuwatsew := Convert( slices, 268 );
            rec.untrcth := Convert( slices, 269 );
            rec.watsewrt := Convert( slices, 270 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0708;


   procedure Create_Job_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.chvamt := Convert( slices, 22 );
            rec.chvpd := Convert( slices, 23 );
            rec.chvsac := Convert( slices, 24 );
            rec.chvuamt := Convert( slices, 25 );
            rec.chvupd := Convert( slices, 26 );
            rec.chvusu := Convert( slices, 27 );
            rec.dedoth := Convert( slices, 28 );
            rec.deduc1 := Convert( slices, 29 );
            rec.deduc2 := Convert( slices, 30 );
            rec.deduc3 := Convert( slices, 31 );
            rec.deduc4 := Convert( slices, 32 );
            rec.deduc5 := Convert( slices, 33 );
            rec.deduc6 := Convert( slices, 34 );
            rec.deduc7 := Convert( slices, 35 );
            rec.deduc8 := Convert( slices, 36 );
            rec.dirctr := Convert( slices, 37 );
            rec.dirni := Convert( slices, 38 );
            rec.dvtothru := Convert( slices, 39 );
            rec.dvushr := Convert( slices, 40 );
            rec.empany := Convert( slices, 41 );
            rec.empown := Convert( slices, 42 );
            rec.etype := Convert( slices, 43 );
            rec.everot := Convert( slices, 44 );
            rec.expben01 := Convert( slices, 45 );
            rec.expben02 := Convert( slices, 46 );
            rec.expben03 := Convert( slices, 47 );
            rec.expben04 := Convert( slices, 48 );
            rec.expben05 := Convert( slices, 49 );
            rec.expben06 := Convert( slices, 50 );
            rec.expben07 := Convert( slices, 51 );
            rec.expben08 := Convert( slices, 52 );
            rec.expben09 := Convert( slices, 53 );
            rec.expben10 := Convert( slices, 54 );
            rec.expben11 := Convert( slices, 55 );
            rec.expben12 := Convert( slices, 56 );
            rec.ftpt := Convert( slices, 57 );
            rec.grsofar := Convert( slices, 58 );
            rec.grwage := Convert( slices, 59 );
            rec.grwagpd := Convert( slices, 60 );
            rec.hha1 := Convert( slices, 61 );
            rec.hha2 := Convert( slices, 62 );
            rec.hha3 := Convert( slices, 63 );
            rec.hhc1 := Convert( slices, 64 );
            rec.hhc2 := Convert( slices, 65 );
            rec.hhc3 := Convert( slices, 66 );
            rec.hohinc := Convert( slices, 67 );
            rec.inclpay1 := Convert( slices, 68 );
            rec.inclpay2 := Convert( slices, 69 );
            rec.inclpay3 := Convert( slices, 70 );
            rec.inclpay4 := Convert( slices, 71 );
            rec.inclpay5 := Convert( slices, 72 );
            rec.inclpay6 := Convert( slices, 73 );
            rec.inclpay7 := Convert( slices, 74 );
            rec.instype1 := Convert( slices, 75 );
            rec.instype2 := Convert( slices, 76 );
            rec.jobbus := Convert( slices, 77 );
            rec.likehr := Convert( slices, 78 );
            rec.mademp := Convert( slices, 79 );
            rec.matemp := Convert( slices, 80 );
            rec.matstp := Convert( slices, 81 );
            rec.mileamt := Convert( slices, 82 );
            rec.motamt := Convert( slices, 83 );
            rec.natins := Convert( slices, 84 );
            rec.nature := Convert( slices, 85 );
            rec.nidamt := Convert( slices, 86 );
            rec.nidpd := Convert( slices, 87 );
            rec.nmchc := Convert( slices, 88 );
            rec.nmper := Convert( slices, 89 );
            rec.nomor1 := Convert( slices, 90 );
            rec.nomor2 := Convert( slices, 91 );
            rec.nomor3 := Convert( slices, 92 );
            rec.numemp := Convert( slices, 93 );
            rec.othded1 := Convert( slices, 94 );
            rec.othded2 := Convert( slices, 95 );
            rec.othded3 := Convert( slices, 96 );
            rec.othded4 := Convert( slices, 97 );
            rec.othded5 := Convert( slices, 98 );
            rec.othded6 := Convert( slices, 99 );
            rec.othded7 := Convert( slices, 100 );
            rec.othded8 := Convert( slices, 101 );
            rec.othded9 := Convert( slices, 102 );
            rec.ownamt := Convert( slices, 103 );
            rec.ownotamt := Convert( slices, 104 );
            rec.ownother := Convert( slices, 105 );
            rec.ownsum := Convert( slices, 106 );
            rec.paperiod := Convert( slices, 107 );
            rec.payamt := Convert( slices, 108 );
            rec.paydat := Convert( slices, 109 );
            rec.paye := Convert( slices, 110 );
            rec.paypd := Convert( slices, 111 );
            rec.payslip := Convert( slices, 112 );
            rec.payusl := Convert( slices, 113 );
            rec.pothr := Convert( slices, 114 );
            rec.ppperiod := Convert( slices, 115 );
            rec.prbefore := Convert( slices, 116 );
            rec.prevmth := Convert( slices, 117 );
            rec.prevyr := Convert( slices, 118 );
            rec.profdocs := Convert( slices, 119 );
            rec.profit1 := Convert( slices, 120 );
            rec.profit2 := Convert( slices, 121 );
            rec.profni := Convert( slices, 122 );
            rec.proftax := Convert( slices, 123 );
            rec.rspoth := Convert( slices, 124 );
            rec.salsac := Convert( slices, 125 );
            rec.sapamt := Convert( slices, 126 );
            rec.se1 := Convert( slices, 127 );
            rec.se2 := Convert( slices, 128 );
            rec.seend := Convert( slices, 129 );
            rec.seincamt := Convert( slices, 130 );
            rec.seincwm := Convert( slices, 131 );
            rec.selwks := Convert( slices, 132 );
            rec.seniiamt := Convert( slices, 133 );
            rec.seniinc := Convert( slices, 134 );
            rec.senilamt := Convert( slices, 135 );
            rec.senilump := Convert( slices, 136 );
            rec.seniramt := Convert( slices, 137 );
            rec.senireg := Convert( slices, 138 );
            rec.senirpd := Convert( slices, 139 );
            rec.setax := Convert( slices, 140 );
            rec.setaxamt := Convert( slices, 141 );
            rec.smpamt := Convert( slices, 142 );
            rec.smprate := Convert( slices, 143 );
            rec.sole := Convert( slices, 144 );
            rec.sppamt := Convert( slices, 145 );
            rec.sspamt := Convert( slices, 146 );
            rec.taxamt := Convert( slices, 147 );
            rec.taxdamt := Convert( slices, 148 );
            rec.taxdpd := Convert( slices, 149 );
            rec.totus1 := Convert( slices, 150 );
            rec.ubonamt := Convert( slices, 151 );
            rec.uboninc := Convert( slices, 152 );
            rec.udeduc1 := Convert( slices, 153 );
            rec.udeduc2 := Convert( slices, 154 );
            rec.udeduc3 := Convert( slices, 155 );
            rec.udeduc4 := Convert( slices, 156 );
            rec.udeduc5 := Convert( slices, 157 );
            rec.udeduc6 := Convert( slices, 158 );
            rec.udeduc7 := Convert( slices, 159 );
            rec.udeduc8 := Convert( slices, 160 );
            rec.ugross := Convert( slices, 161 );
            rec.uincpay1 := Convert( slices, 162 );
            rec.uincpay2 := Convert( slices, 163 );
            rec.uincpay3 := Convert( slices, 164 );
            rec.uincpay4 := Convert( slices, 165 );
            rec.uincpay5 := Convert( slices, 166 );
            rec.uincpay6 := Convert( slices, 167 );
            rec.uincpay7 := Convert( slices, 168 );
            rec.umileamt := Convert( slices, 169 );
            rec.umotamt := Convert( slices, 170 );
            rec.unett := Convert( slices, 171 );
            rec.uothded1 := Convert( slices, 172 );
            rec.uothded2 := Convert( slices, 173 );
            rec.uothded3 := Convert( slices, 174 );
            rec.uothded4 := Convert( slices, 175 );
            rec.uothded5 := Convert( slices, 176 );
            rec.uothded6 := Convert( slices, 177 );
            rec.uothded7 := Convert( slices, 178 );
            rec.uothded8 := Convert( slices, 179 );
            rec.uothded9 := Convert( slices, 180 );
            rec.uothdtot := Convert( slices, 181 );
            rec.uothr := Convert( slices, 182 );
            rec.upd := Convert( slices, 183 );
            rec.usapamt := Convert( slices, 184 );
            rec.usmpamt := Convert( slices, 185 );
            rec.usmprate := Convert( slices, 186 );
            rec.usppamt := Convert( slices, 187 );
            rec.usspamt := Convert( slices, 188 );
            rec.usuhr := Convert( slices, 189 );
            rec.utaxamt := Convert( slices, 190 );
            rec.watdid := Convert( slices, 191 );
            rec.watprev := Convert( slices, 192 );
            rec.where := Convert( slices, 193 );
            rec.whynopro := Convert( slices, 194 );
            rec.whynou01 := Convert( slices, 195 );
            rec.whynou02 := Convert( slices, 196 );
            rec.whynou03 := Convert( slices, 197 );
            rec.whynou04 := Convert( slices, 198 );
            rec.whynou05 := Convert( slices, 199 );
            rec.whynou06 := Convert( slices, 200 );
            rec.whynou07 := Convert( slices, 201 );
            rec.whynou08 := Convert( slices, 202 );
            rec.whynou09 := Convert( slices, 203 );
            rec.whynou10 := Convert( slices, 204 );
            rec.whynou11 := Convert( slices, 205 );
            rec.workacc := Convert( slices, 206 );
            rec.workmth := Convert( slices, 207 );
            rec.workyr := Convert( slices, 208 );
            rec.wrkprev := Convert( slices, 209 );
            rec.month := Convert( slices, 210 );
            rec.hdqhrs := Convert( slices, 211 );
            rec.jobhours := Convert( slices, 212 );
            rec.sspsmpfg := Convert( slices, 213 );
            rec.ugrspay := Convert( slices, 214 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0708;


   procedure Create_Maint_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.m := Convert( slices, 5 );
            rec.mrage := Convert( slices, 6 );
            rec.mramt := Convert( slices, 7 );
            rec.mrchwhy1 := Convert( slices, 8 );
            rec.mrchwhy2 := Convert( slices, 9 );
            rec.mrchwhy3 := Convert( slices, 10 );
            rec.mrchwhy4 := Convert( slices, 11 );
            rec.mrchwhy5 := Convert( slices, 12 );
            rec.mrchwhy6 := Convert( slices, 13 );
            rec.mrchwhy7 := Convert( slices, 14 );
            rec.mrchwhy8 := Convert( slices, 15 );
            rec.mrchwhy9 := Convert( slices, 16 );
            rec.mrct := Convert( slices, 17 );
            rec.mrkid := Convert( slices, 18 );
            rec.mrpd := Convert( slices, 19 );
            rec.mrr := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0708;


   procedure Create_MortCont_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.outsamt := Convert( slices, 4 );
            rec.outsincl := Convert( slices, 5 );
            rec.outspay := Convert( slices, 6 );
            rec.outspd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0708;


   procedure Create_Mortgage_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.loan2y := Convert( slices, 31 );
            rec.loanyear := Convert( slices, 32 );
            rec.menpol := Convert( slices, 33 );
            rec.morall := Convert( slices, 34 );
            rec.morflc := Convert( slices, 35 );
            rec.morinpay := Convert( slices, 36 );
            rec.morinpd := Convert( slices, 37 );
            rec.morinus := Convert( slices, 38 );
            rec.mortend := Convert( slices, 39 );
            rec.mortleft := Convert( slices, 40 );
            rec.mortprot := Convert( slices, 41 );
            rec.morttype := Convert( slices, 42 );
            rec.morupd := Convert( slices, 43 );
            rec.morus := Convert( slices, 44 );
            rec.mpcover1 := Convert( slices, 45 );
            rec.mpcover2 := Convert( slices, 46 );
            rec.mpcover3 := Convert( slices, 47 );
            rec.mpolno := Convert( slices, 48 );
            rec.outsmort := Convert( slices, 49 );
            rec.rentfrom := Convert( slices, 50 );
            rec.rmamt := Convert( slices, 51 );
            rec.rmort := Convert( slices, 52 );
            rec.rmortyr := Convert( slices, 53 );
            rec.rmpur001 := Convert( slices, 54 );
            rec.rmpur002 := Convert( slices, 55 );
            rec.rmpur003 := Convert( slices, 56 );
            rec.rmpur004 := Convert( slices, 57 );
            rec.rmpur005 := Convert( slices, 58 );
            rec.rmpur006 := Convert( slices, 59 );
            rec.rmpur007 := Convert( slices, 60 );
            rec.rmpur008 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0708;


   procedure Create_OddJob_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.ojamt := Convert( slices, 6 );
            rec.ojnow := Convert( slices, 7 );
            rec.ojreg := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0708;


   procedure Create_Owner_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.othmort1 := Convert( slices, 3 );
            rec.othmort2 := Convert( slices, 4 );
            rec.othmort3 := Convert( slices, 5 );
            rec.othpur1 := Convert( slices, 6 );
            rec.othpur2 := Convert( slices, 7 );
            rec.othpur3 := Convert( slices, 8 );
            rec.othpur31 := Convert( slices, 9 );
            rec.othpur32 := Convert( slices, 10 );
            rec.othpur33 := Convert( slices, 11 );
            rec.othpur34 := Convert( slices, 12 );
            rec.othpur35 := Convert( slices, 13 );
            rec.othpur36 := Convert( slices, 14 );
            rec.othpur37 := Convert( slices, 15 );
            rec.othpur4 := Convert( slices, 16 );
            rec.othpur5 := Convert( slices, 17 );
            rec.othpur6 := Convert( slices, 18 );
            rec.othpur7 := Convert( slices, 19 );
            rec.purcamt := Convert( slices, 20 );
            rec.purcloan := Convert( slices, 21 );
            rec.month := Convert( slices, 22 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0708;


   procedure Create_PenAmt_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.penq := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0708;


   procedure Create_PenProv_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppen := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eptype := Convert( slices, 6 );
            rec.penamt := Convert( slices, 7 );
            rec.penamtpd := Convert( slices, 8 );
            rec.pencon := Convert( slices, 9 );
            rec.pendat := Convert( slices, 10 );
            rec.pengov := Convert( slices, 11 );
            rec.penhelp := Convert( slices, 12 );
            rec.penmort := Convert( slices, 13 );
            rec.penreb := Convert( slices, 14 );
            rec.rebgov := Convert( slices, 15 );
            rec.spwho := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0708;


   procedure Create_Pension_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.penoth := Convert( slices, 6 );
            rec.penpay := Convert( slices, 7 );
            rec.penpd := Convert( slices, 8 );
            rec.pentax := Convert( slices, 9 );
            rec.pentype := Convert( slices, 10 );
            rec.poamt := Convert( slices, 11 );
            rec.poinc := Convert( slices, 12 );
            rec.posour := Convert( slices, 13 );
            rec.ptamt := Convert( slices, 14 );
            rec.ptinc := Convert( slices, 15 );
            rec.trights := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0708;


   procedure Create_RentCont_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0708;


   procedure Create_Renter_0708( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbweeks := Convert( slices, 28 );
            rec.hbyears := Convert( slices, 29 );
            rec.landlord := Convert( slices, 30 );
            rec.lowshort := Convert( slices, 31 );
            rec.niystart := Convert( slices, 32 );
            rec.othtype := Convert( slices, 33 );
            rec.rebate := Convert( slices, 34 );
            rec.rent := Convert( slices, 35 );
            rec.rentdk := Convert( slices, 36 );
            rec.rentdoc := Convert( slices, 37 );
            rec.rentfull := Convert( slices, 38 );
            rec.renthol := Convert( slices, 39 );
            rec.rentpd := Convert( slices, 40 );
            rec.resll := Convert( slices, 41 );
            rec.resll2 := Convert( slices, 42 );
            rec.serinc1 := Convert( slices, 43 );
            rec.serinc2 := Convert( slices, 44 );
            rec.serinc3 := Convert( slices, 45 );
            rec.serinc4 := Convert( slices, 46 );
            rec.serinc5 := Convert( slices, 47 );
            rec.tentype := Convert( slices, 48 );
            rec.weekhol := Convert( slices, 49 );
            rec.wsinc := Convert( slices, 50 );
            rec.wsincamt := Convert( slices, 51 );
            rec.ystartr := Convert( slices, 52 );
            rec.month := Convert( slices, 53 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0708;


   procedure Create_Account_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.issue := Convert( slices, 8 );
            rec.nsamt := Convert( slices, 9 );
            rec.month := Convert( slices, 10 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0809;


   procedure Create_Admin_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.lngdf01 := Convert( slices, 6 );
            rec.lngdf02 := Convert( slices, 7 );
            rec.lngdf03 := Convert( slices, 8 );
            rec.lngdf04 := Convert( slices, 9 );
            rec.lngdf05 := Convert( slices, 10 );
            rec.lngdf06 := Convert( slices, 11 );
            rec.lngdf07 := Convert( slices, 12 );
            rec.lngdf08 := Convert( slices, 13 );
            rec.lngdf09 := Convert( slices, 14 );
            rec.lngdf10 := Convert( slices, 15 );
            rec.ncr1 := Convert( slices, 16 );
            rec.ncr2 := Convert( slices, 17 );
            rec.ncr3 := Convert( slices, 18 );
            rec.ncr4 := Convert( slices, 19 );
            rec.ncr5 := Convert( slices, 20 );
            rec.ncr6 := Convert( slices, 21 );
            rec.ncr7 := Convert( slices, 22 );
            rec.nmtrans := Convert( slices, 23 );
            rec.noneng := Convert( slices, 24 );
            rec.refr01 := Convert( slices, 25 );
            rec.refr02 := Convert( slices, 26 );
            rec.refr03 := Convert( slices, 27 );
            rec.refr04 := Convert( slices, 28 );
            rec.refr05 := Convert( slices, 29 );
            rec.refr06 := Convert( slices, 30 );
            rec.refr07 := Convert( slices, 31 );
            rec.refr08 := Convert( slices, 32 );
            rec.refr09 := Convert( slices, 33 );
            rec.refr10 := Convert( slices, 34 );
            rec.refr11 := Convert( slices, 35 );
            rec.refr12 := Convert( slices, 36 );
            rec.refr13 := Convert( slices, 37 );
            rec.refr14 := Convert( slices, 38 );
            rec.refr15 := Convert( slices, 39 );
            rec.refr16 := Convert( slices, 40 );
            rec.refr17 := Convert( slices, 41 );
            rec.refr18 := Convert( slices, 42 );
            rec.tnc := Convert( slices, 43 );
            rec.version := Convert( slices, 44 );
            rec.whlang01 := Convert( slices, 45 );
            rec.whlang02 := Convert( slices, 46 );
            rec.whlang03 := Convert( slices, 47 );
            rec.whlang04 := Convert( slices, 48 );
            rec.whlang05 := Convert( slices, 49 );
            rec.whlang06 := Convert( slices, 50 );
            rec.whlang07 := Convert( slices, 51 );
            rec.whlang08 := Convert( slices, 52 );
            rec.whlang09 := Convert( slices, 53 );
            rec.whlang10 := Convert( slices, 54 );
            rec.whotran1 := Convert( slices, 55 );
            rec.whotran2 := Convert( slices, 56 );
            rec.whotran3 := Convert( slices, 57 );
            rec.whotran4 := Convert( slices, 58 );
            rec.whotran5 := Convert( slices, 59 );
            rec.month := Convert( slices, 60 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0809;


   procedure Create_Adult_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.allow1 := Convert( slices, 21 );
            rec.allow2 := Convert( slices, 22 );
            rec.allow3 := Convert( slices, 23 );
            rec.allow4 := Convert( slices, 24 );
            rec.allpay1 := Convert( slices, 25 );
            rec.allpay2 := Convert( slices, 26 );
            rec.allpay3 := Convert( slices, 27 );
            rec.allpay4 := Convert( slices, 28 );
            rec.allpd1 := Convert( slices, 29 );
            rec.allpd2 := Convert( slices, 30 );
            rec.allpd3 := Convert( slices, 31 );
            rec.allpd4 := Convert( slices, 32 );
            rec.anyacc := Convert( slices, 33 );
            rec.anyed := Convert( slices, 34 );
            rec.anymon := Convert( slices, 35 );
            rec.anypen1 := Convert( slices, 36 );
            rec.anypen2 := Convert( slices, 37 );
            rec.anypen3 := Convert( slices, 38 );
            rec.anypen4 := Convert( slices, 39 );
            rec.anypen5 := Convert( slices, 40 );
            rec.anypen6 := Convert( slices, 41 );
            rec.anypen7 := Convert( slices, 42 );
            rec.apamt := Convert( slices, 43 );
            rec.apdamt := Convert( slices, 44 );
            rec.apdir := Convert( slices, 45 );
            rec.apdpd := Convert( slices, 46 );
            rec.appd := Convert( slices, 47 );
            rec.b2qfut1 := Convert( slices, 48 );
            rec.b2qfut2 := Convert( slices, 49 );
            rec.b2qfut3 := Convert( slices, 50 );
            rec.b3qfut1 := Convert( slices, 51 );
            rec.b3qfut2 := Convert( slices, 52 );
            rec.b3qfut3 := Convert( slices, 53 );
            rec.b3qfut4 := Convert( slices, 54 );
            rec.b3qfut5 := Convert( slices, 55 );
            rec.b3qfut6 := Convert( slices, 56 );
            rec.b3qfut7 := Convert( slices, 57 );
            rec.ben1q1 := Convert( slices, 58 );
            rec.ben1q2 := Convert( slices, 59 );
            rec.ben1q3 := Convert( slices, 60 );
            rec.ben1q4 := Convert( slices, 61 );
            rec.ben1q5 := Convert( slices, 62 );
            rec.ben1q6 := Convert( slices, 63 );
            rec.ben1q7 := Convert( slices, 64 );
            rec.ben2q1 := Convert( slices, 65 );
            rec.ben2q2 := Convert( slices, 66 );
            rec.ben2q3 := Convert( slices, 67 );
            rec.ben3q1 := Convert( slices, 68 );
            rec.ben3q2 := Convert( slices, 69 );
            rec.ben3q3 := Convert( slices, 70 );
            rec.ben3q4 := Convert( slices, 71 );
            rec.ben3q5 := Convert( slices, 72 );
            rec.ben3q6 := Convert( slices, 73 );
            rec.ben3q7 := Convert( slices, 74 );
            rec.ben4q1 := Convert( slices, 75 );
            rec.ben4q2 := Convert( slices, 76 );
            rec.ben4q3 := Convert( slices, 77 );
            rec.ben5q1 := Convert( slices, 78 );
            rec.ben5q2 := Convert( slices, 79 );
            rec.ben5q3 := Convert( slices, 80 );
            rec.ben5q4 := Convert( slices, 81 );
            rec.ben5q5 := Convert( slices, 82 );
            rec.ben5q6 := Convert( slices, 83 );
            rec.ben5q7 := Convert( slices, 84 );
            rec.ben5q8 := Convert( slices, 85 );
            rec.ben5q9 := Convert( slices, 86 );
            rec.ben7q1 := Convert( slices, 87 );
            rec.ben7q2 := Convert( slices, 88 );
            rec.ben7q3 := Convert( slices, 89 );
            rec.ben7q4 := Convert( slices, 90 );
            rec.ben7q5 := Convert( slices, 91 );
            rec.ben7q6 := Convert( slices, 92 );
            rec.ben7q7 := Convert( slices, 93 );
            rec.ben7q8 := Convert( slices, 94 );
            rec.ben7q9 := Convert( slices, 95 );
            rec.camemt := Convert( slices, 96 );
            rec.cameyr := Convert( slices, 97 );
            rec.cameyr2 := Convert( slices, 98 );
            rec.chkdpn := Convert( slices, 99 );
            rec.chknop := Convert( slices, 100 );
            rec.claimant := Convert( slices, 101 );
            rec.cohabit := Convert( slices, 102 );
            rec.combid := Convert( slices, 103 );
            rec.contuk := Convert( slices, 104 );
            rec.convbl := Convert( slices, 105 );
            rec.corign := Convert( slices, 106 );
            rec.ctclum1 := Convert( slices, 107 );
            rec.ctclum2 := Convert( slices, 108 );
            rec.cupchk := Convert( slices, 109 );
            rec.cvht := Convert( slices, 110 );
            rec.cvpay := Convert( slices, 111 );
            rec.cvpd := Convert( slices, 112 );
            rec.ddaprog := Convert( slices, 113 );
            rec.ddatre := Convert( slices, 114 );
            rec.ddatrep := Convert( slices, 115 );
            rec.defrpen := Convert( slices, 116 );
            rec.depend := Convert( slices, 117 );
            rec.disdif1 := Convert( slices, 118 );
            rec.disdif2 := Convert( slices, 119 );
            rec.disdif3 := Convert( slices, 120 );
            rec.disdif4 := Convert( slices, 121 );
            rec.disdif5 := Convert( slices, 122 );
            rec.disdif6 := Convert( slices, 123 );
            rec.disdif7 := Convert( slices, 124 );
            rec.disdif8 := Convert( slices, 125 );
            rec.disdif9 := Convert( slices, 126 );
            rec.disdifp := Convert( slices, 127 );
            rec.dob := Convert( slices, 128 );
            rec.dvil03a := Convert( slices, 129 );
            rec.dvil04a := Convert( slices, 130 );
            rec.dvjb12ml := Convert( slices, 131 );
            rec.dvmardf := Convert( slices, 132 );
            rec.dvpens := Convert( slices, 133 );
            rec.ed1amt := Convert( slices, 134 );
            rec.ed1borr := Convert( slices, 135 );
            rec.ed1int := Convert( slices, 136 );
            rec.ed1monyr := Convert( slices, 137 );
            rec.ed1pd := Convert( slices, 138 );
            rec.ed1sum := Convert( slices, 139 );
            rec.ed2amt := Convert( slices, 140 );
            rec.ed2borr := Convert( slices, 141 );
            rec.ed2int := Convert( slices, 142 );
            rec.ed2monyr := Convert( slices, 143 );
            rec.ed2pd := Convert( slices, 144 );
            rec.ed2sum := Convert( slices, 145 );
            rec.edatt := Convert( slices, 146 );
            rec.edhr := Convert( slices, 147 );
            rec.edtime := Convert( slices, 148 );
            rec.edtyp := Convert( slices, 149 );
            rec.eligadlt := Convert( slices, 150 );
            rec.eligchld := Convert( slices, 151 );
            rec.eligschm := Convert( slices, 152 );
            rec.emparr := Convert( slices, 153 );
            rec.emppen := Convert( slices, 154 );
            rec.empschm := Convert( slices, 155 );
            rec.empstat := Convert( slices, 156 );
            rec.endyr := Convert( slices, 157 );
            rec.es2000 := Convert( slices, 158 );
            rec.ethgrp := Convert( slices, 159 );
            rec.everwrk := Convert( slices, 160 );
            rec.exthbct1 := Convert( slices, 161 );
            rec.exthbct2 := Convert( slices, 162 );
            rec.exthbct3 := Convert( slices, 163 );
            rec.followup := Convert( slices, 164 );
            rec.fted := Convert( slices, 165 );
            rec.ftwk := Convert( slices, 166 );
            rec.govpis := Convert( slices, 167 );
            rec.govpjsa := Convert( slices, 168 );
            rec.grant := Convert( slices, 169 );
            rec.grtamt1 := Convert( slices, 170 );
            rec.grtamt2 := Convert( slices, 171 );
            rec.grtdir1 := Convert( slices, 172 );
            rec.grtdir2 := Convert( slices, 173 );
            rec.grtnum := Convert( slices, 174 );
            rec.grtsce1 := Convert( slices, 175 );
            rec.grtsce2 := Convert( slices, 176 );
            rec.grtval1 := Convert( slices, 177 );
            rec.grtval2 := Convert( slices, 178 );
            rec.gta := Convert( slices, 179 );
            rec.hbolng := Convert( slices, 180 );
            rec.hbothamt := Convert( slices, 181 );
            rec.hbothbu := Convert( slices, 182 );
            rec.hbothpd := Convert( slices, 183 );
            rec.hbothwk := Convert( slices, 184 );
            rec.hbotwait := Convert( slices, 185 );
            rec.health := Convert( slices, 186 );
            rec.hholder := Convert( slices, 187 );
            rec.hi1qual1 := Convert( slices, 188 );
            rec.hi1qual2 := Convert( slices, 189 );
            rec.hi1qual3 := Convert( slices, 190 );
            rec.hi1qual4 := Convert( slices, 191 );
            rec.hi1qual5 := Convert( slices, 192 );
            rec.hi1qual6 := Convert( slices, 193 );
            rec.hi2qual := Convert( slices, 194 );
            rec.hlpgvn01 := Convert( slices, 195 );
            rec.hlpgvn02 := Convert( slices, 196 );
            rec.hlpgvn03 := Convert( slices, 197 );
            rec.hlpgvn04 := Convert( slices, 198 );
            rec.hlpgvn05 := Convert( slices, 199 );
            rec.hlpgvn06 := Convert( slices, 200 );
            rec.hlpgvn07 := Convert( slices, 201 );
            rec.hlpgvn08 := Convert( slices, 202 );
            rec.hlpgvn09 := Convert( slices, 203 );
            rec.hlpgvn10 := Convert( slices, 204 );
            rec.hlpgvn11 := Convert( slices, 205 );
            rec.hlprec01 := Convert( slices, 206 );
            rec.hlprec02 := Convert( slices, 207 );
            rec.hlprec03 := Convert( slices, 208 );
            rec.hlprec04 := Convert( slices, 209 );
            rec.hlprec05 := Convert( slices, 210 );
            rec.hlprec06 := Convert( slices, 211 );
            rec.hlprec07 := Convert( slices, 212 );
            rec.hlprec08 := Convert( slices, 213 );
            rec.hlprec09 := Convert( slices, 214 );
            rec.hlprec10 := Convert( slices, 215 );
            rec.hlprec11 := Convert( slices, 216 );
            rec.hprob := Convert( slices, 217 );
            rec.hrpid := Convert( slices, 218 );
            rec.incdur := Convert( slices, 219 );
            rec.injlong := Convert( slices, 220 );
            rec.injwk := Convert( slices, 221 );
            rec.invests := Convert( slices, 222 );
            rec.iout := Convert( slices, 223 );
            rec.isa1type := Convert( slices, 224 );
            rec.isa2type := Convert( slices, 225 );
            rec.issue := Convert( slices, 226 );
            rec.jobaway := Convert( slices, 227 );
            rec.lareg := Convert( slices, 228 );
            rec.likewk := Convert( slices, 229 );
            rec.lktime := Convert( slices, 230 );
            rec.ln1rpint := Convert( slices, 231 );
            rec.ln2rpint := Convert( slices, 232 );
            rec.lnkdwp := Convert( slices, 233 );
            rec.lnkref1 := Convert( slices, 234 );
            rec.lnkref2 := Convert( slices, 235 );
            rec.lnkref3 := Convert( slices, 236 );
            rec.lnkref4 := Convert( slices, 237 );
            rec.lnkref5 := Convert( slices, 238 );
            rec.lnkref6 := Convert( slices, 239 );
            rec.lnkref7 := Convert( slices, 240 );
            rec.lnkref8 := Convert( slices, 241 );
            rec.lnkref9 := Convert( slices, 242 );
            rec.loan := Convert( slices, 243 );
            rec.loangvn1 := Convert( slices, 244 );
            rec.loangvn2 := Convert( slices, 245 );
            rec.loangvn3 := Convert( slices, 246 );
            rec.loannum := Convert( slices, 247 );
            rec.loanrec1 := Convert( slices, 248 );
            rec.loanrec2 := Convert( slices, 249 );
            rec.loanrec3 := Convert( slices, 250 );
            rec.look := Convert( slices, 251 );
            rec.lookwk := Convert( slices, 252 );
            rec.lstwrk1 := Convert( slices, 253 );
            rec.lstwrk2 := Convert( slices, 254 );
            rec.lstyr := Convert( slices, 255 );
            rec.memschm := Convert( slices, 256 );
            rec.mntamt1 := Convert( slices, 257 );
            rec.mntamt2 := Convert( slices, 258 );
            rec.mntarr1 := Convert( slices, 259 );
            rec.mntarr2 := Convert( slices, 260 );
            rec.mntarr3 := Convert( slices, 261 );
            rec.mntarr4 := Convert( slices, 262 );
            rec.mntgov1 := Convert( slices, 263 );
            rec.mntgov2 := Convert( slices, 264 );
            rec.mntnrp := Convert( slices, 265 );
            rec.mntpay := Convert( slices, 266 );
            rec.mntpd1 := Convert( slices, 267 );
            rec.mntpd2 := Convert( slices, 268 );
            rec.mntrec := Convert( slices, 269 );
            rec.mntus1 := Convert( slices, 270 );
            rec.mntus2 := Convert( slices, 271 );
            rec.mntusam1 := Convert( slices, 272 );
            rec.mntusam2 := Convert( slices, 273 );
            rec.mntuspd1 := Convert( slices, 274 );
            rec.mntuspd2 := Convert( slices, 275 );
            rec.ms := Convert( slices, 276 );
            rec.natid1 := Convert( slices, 277 );
            rec.natid2 := Convert( slices, 278 );
            rec.natid3 := Convert( slices, 279 );
            rec.natid4 := Convert( slices, 280 );
            rec.natid5 := Convert( slices, 281 );
            rec.natid6 := Convert( slices, 282 );
            rec.ndeal := Convert( slices, 283 );
            rec.newdtype := Convert( slices, 284 );
            rec.niamt := Convert( slices, 285 );
            rec.niethgrp := Convert( slices, 286 );
            rec.niexthbb := Convert( slices, 287 );
            rec.ninatid1 := Convert( slices, 288 );
            rec.ninatid2 := Convert( slices, 289 );
            rec.ninatid3 := Convert( slices, 290 );
            rec.ninatid4 := Convert( slices, 291 );
            rec.ninatid5 := Convert( slices, 292 );
            rec.ninatid6 := Convert( slices, 293 );
            rec.ninatid7 := Convert( slices, 294 );
            rec.ninatid8 := Convert( slices, 295 );
            rec.nipd := Convert( slices, 296 );
            rec.nireg := Convert( slices, 297 );
            rec.nirel := Convert( slices, 298 );
            rec.nitrain := Convert( slices, 299 );
            rec.nlper := Convert( slices, 300 );
            rec.nolk1 := Convert( slices, 301 );
            rec.nolk2 := Convert( slices, 302 );
            rec.nolk3 := Convert( slices, 303 );
            rec.nolook := Convert( slices, 304 );
            rec.nowant := Convert( slices, 305 );
            rec.nssec := Convert( slices, 306 );
            rec.ntcdat := Convert( slices, 307 );
            rec.ntcinc := Convert( slices, 308 );
            rec.numjob := Convert( slices, 309 );
            rec.numjob2 := Convert( slices, 310 );
            rec.oddjob := Convert( slices, 311 );
            rec.oldstud := Convert( slices, 312 );
            rec.otabspar := Convert( slices, 313 );
            rec.otamt := Convert( slices, 314 );
            rec.otapamt := Convert( slices, 315 );
            rec.otappd := Convert( slices, 316 );
            rec.othqual1 := Convert( slices, 317 );
            rec.othqual2 := Convert( slices, 318 );
            rec.othqual3 := Convert( slices, 319 );
            rec.othtax := Convert( slices, 320 );
            rec.otinva := Convert( slices, 321 );
            rec.pareamt := Convert( slices, 322 );
            rec.parepd := Convert( slices, 323 );
            rec.penlump := Convert( slices, 324 );
            rec.perspen1 := Convert( slices, 325 );
            rec.perspen2 := Convert( slices, 326 );
            rec.ppnumc := Convert( slices, 327 );
            rec.practice := Convert( slices, 328 );
            rec.privpen := Convert( slices, 329 );
            rec.ptwk := Convert( slices, 330 );
            rec.r01 := Convert( slices, 331 );
            rec.r02 := Convert( slices, 332 );
            rec.r03 := Convert( slices, 333 );
            rec.r04 := Convert( slices, 334 );
            rec.r05 := Convert( slices, 335 );
            rec.r06 := Convert( slices, 336 );
            rec.r07 := Convert( slices, 337 );
            rec.r08 := Convert( slices, 338 );
            rec.r09 := Convert( slices, 339 );
            rec.r10 := Convert( slices, 340 );
            rec.r11 := Convert( slices, 341 );
            rec.r12 := Convert( slices, 342 );
            rec.r13 := Convert( slices, 343 );
            rec.r14 := Convert( slices, 344 );
            rec.redamt := Convert( slices, 345 );
            rec.redany := Convert( slices, 346 );
            rec.rentprof := Convert( slices, 347 );
            rec.retire := Convert( slices, 348 );
            rec.retire1 := Convert( slices, 349 );
            rec.retreas := Convert( slices, 350 );
            rec.royal1 := Convert( slices, 351 );
            rec.royal2 := Convert( slices, 352 );
            rec.royal3 := Convert( slices, 353 );
            rec.royal4 := Convert( slices, 354 );
            rec.royyr1 := Convert( slices, 355 );
            rec.royyr2 := Convert( slices, 356 );
            rec.royyr3 := Convert( slices, 357 );
            rec.royyr4 := Convert( slices, 358 );
            rec.rstrct := Convert( slices, 359 );
            rec.schchk := Convert( slices, 360 );
            rec.sex := Convert( slices, 361 );
            rec.sflntyp1 := Convert( slices, 362 );
            rec.sflntyp2 := Convert( slices, 363 );
            rec.sfrpis := Convert( slices, 364 );
            rec.sfrpjsa := Convert( slices, 365 );
            rec.sftype1 := Convert( slices, 366 );
            rec.sftype2 := Convert( slices, 367 );
            rec.sic := Convert( slices, 368 );
            rec.slrepamt := Convert( slices, 369 );
            rec.slrepay := Convert( slices, 370 );
            rec.slreppd := Convert( slices, 371 );
            rec.soc2000 := Convert( slices, 372 );
            rec.spcreg1 := Convert( slices, 373 );
            rec.spcreg2 := Convert( slices, 374 );
            rec.spcreg3 := Convert( slices, 375 );
            rec.spnumc := Convert( slices, 376 );
            rec.spout := Convert( slices, 377 );
            rec.srentamt := Convert( slices, 378 );
            rec.srentpd := Convert( slices, 379 );
            rec.stakep := Convert( slices, 380 );
            rec.start := Convert( slices, 381 );
            rec.startyr := Convert( slices, 382 );
            rec.taxcred1 := Convert( slices, 383 );
            rec.taxcred2 := Convert( slices, 384 );
            rec.taxfut := Convert( slices, 385 );
            rec.tcever1 := Convert( slices, 386 );
            rec.tcever2 := Convert( slices, 387 );
            rec.tcrepay1 := Convert( slices, 388 );
            rec.tcrepay2 := Convert( slices, 389 );
            rec.tcrepay3 := Convert( slices, 390 );
            rec.tcrepay4 := Convert( slices, 391 );
            rec.tcrepay5 := Convert( slices, 392 );
            rec.tcrepay6 := Convert( slices, 393 );
            rec.tcthsyr1 := Convert( slices, 394 );
            rec.tcthsyr2 := Convert( slices, 395 );
            rec.tdaywrk := Convert( slices, 396 );
            rec.tea := Convert( slices, 397 );
            rec.tea9697 := Convert( slices, 398 );
            rec.topupl := Convert( slices, 399 );
            rec.totint := Convert( slices, 400 );
            rec.train := Convert( slices, 401 );
            rec.trainee := Convert( slices, 402 );
            rec.tuborr := Convert( slices, 403 );
            rec.typeed := Convert( slices, 404 );
            rec.unpaid1 := Convert( slices, 405 );
            rec.unpaid2 := Convert( slices, 406 );
            rec.w1 := Convert( slices, 407 );
            rec.w2 := Convert( slices, 408 );
            rec.wait := Convert( slices, 409 );
            rec.war1 := Convert( slices, 410 );
            rec.war2 := Convert( slices, 411 );
            rec.whoresp := Convert( slices, 412 );
            rec.whosectb := Convert( slices, 413 );
            rec.wintfuel := Convert( slices, 414 );
            rec.wmkit := Convert( slices, 415 );
            rec.working := Convert( slices, 416 );
            rec.wpa := Convert( slices, 417 );
            rec.wpba := Convert( slices, 418 );
            rec.wtclum1 := Convert( slices, 419 );
            rec.wtclum2 := Convert( slices, 420 );
            rec.ystrtwk := Convert( slices, 421 );
            rec.month := Convert( slices, 422 );
            rec.able := Convert( slices, 423 );
            rec.actacci := Convert( slices, 424 );
            rec.addda := Convert( slices, 425 );
            rec.age80 := Convert( slices, 426 );
            rec.basacti := Convert( slices, 427 );
            rec.careab := Convert( slices, 428 );
            rec.careah := Convert( slices, 429 );
            rec.carecb := Convert( slices, 430 );
            rec.carech := Convert( slices, 431 );
            rec.carecl := Convert( slices, 432 );
            rec.carefl := Convert( slices, 433 );
            rec.carefr := Convert( slices, 434 );
            rec.careot := Convert( slices, 435 );
            rec.carere := Convert( slices, 436 );
            rec.chbflg := Convert( slices, 437 );
            rec.crunaci := Convert( slices, 438 );
            rec.curacti := Convert( slices, 439 );
            rec.currjobm := Convert( slices, 440 );
            rec.empoccp := Convert( slices, 441 );
            rec.empstatb := Convert( slices, 442 );
            rec.empstatc := Convert( slices, 443 );
            rec.empstati := Convert( slices, 444 );
            rec.enomorti := Convert( slices, 445 );
            rec.ethgr2 := Convert( slices, 446 );
            rec.fsbndcti := Convert( slices, 447 );
            rec.gebacti := Convert( slices, 448 );
            rec.giltcti := Convert( slices, 449 );
            rec.gross3 := Convert( slices, 450 );
            rec.hdage := Convert( slices, 451 );
            rec.hdben := Convert( slices, 452 );
            rec.hdindinc := Convert( slices, 453 );
            rec.heartval := Convert( slices, 454 );
            rec.hourab := Convert( slices, 455 );
            rec.hourah := Convert( slices, 456 );
            rec.hourcare := Convert( slices, 457 );
            rec.hourcb := Convert( slices, 458 );
            rec.hourch := Convert( slices, 459 );
            rec.hourcl := Convert( slices, 460 );
            rec.hourfr := Convert( slices, 461 );
            rec.hourot := Convert( slices, 462 );
            rec.hourre := Convert( slices, 463 );
            rec.hourtot := Convert( slices, 464 );
            rec.hperson := Convert( slices, 465 );
            rec.iagegr2 := Convert( slices, 466 );
            rec.iagegrp := Convert( slices, 469 );
            rec.incseo2 := Convert( slices, 470 );
            rec.indinc := Convert( slices, 471 );
            rec.indisben := Convert( slices, 472 );
            rec.inearns := Convert( slices, 473 );
            rec.ininv := Convert( slices, 474 );
            rec.inirben := Convert( slices, 475 );
            rec.innirben := Convert( slices, 476 );
            rec.inothben := Convert( slices, 477 );
            rec.inpeninc := Convert( slices, 478 );
            rec.inrinc := Convert( slices, 479 );
            rec.inrpinc := Convert( slices, 480 );
            rec.intvlic := Convert( slices, 481 );
            rec.intxcred := Convert( slices, 482 );
            rec.isacti := Convert( slices, 483 );
            rec.marital := Convert( slices, 484 );
            rec.nincseo2 := Convert( slices, 485 );
            rec.nindinc := Convert( slices, 486 );
            rec.ninearns := Convert( slices, 487 );
            rec.nininv := Convert( slices, 488 );
            rec.ninpenin := Convert( slices, 489 );
            rec.ninsein2 := Convert( slices, 490 );
            rec.nirel2 := Convert( slices, 491 );
            rec.nsbocti := Convert( slices, 492 );
            rec.occupnum := Convert( slices, 493 );
            rec.otbscti := Convert( slices, 494 );
            rec.pepscti := Convert( slices, 495 );
            rec.poaccti := Convert( slices, 496 );
            rec.pocardi := Convert( slices, 497 );
            rec.prbocti := Convert( slices, 498 );
            rec.prevjobm := Convert( slices, 499 );
            rec.relhrp := Convert( slices, 500 );
            rec.sapadj := Convert( slices, 501 );
            rec.sayecti := Convert( slices, 502 );
            rec.sclbcti := Convert( slices, 503 );
            rec.seincam2 := Convert( slices, 504 );
            rec.smpadj := Convert( slices, 505 );
            rec.sppadj := Convert( slices, 506 );
            rec.sscti := Convert( slices, 507 );
            rec.sspadj := Convert( slices, 508 );
            rec.stshcti := Convert( slices, 509 );
            rec.taxpayer := Convert( slices, 510 );
            rec.tesscti := Convert( slices, 511 );
            rec.totgrant := Convert( slices, 512 );
            rec.tothours := Convert( slices, 513 );
            rec.totoccp := Convert( slices, 514 );
            rec.untrcti := Convert( slices, 515 );
            rec.uperson := Convert( slices, 516 );
            rec.widoccp := Convert( slices, 517 );
            rec.xbonflag := Convert( slices, 518 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0809;


   procedure Create_Asset_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issue := Convert( slices, 14 );
            rec.issval := Convert( slices, 15 );
            rec.pd := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0809;


   procedure Create_Benefit_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.bookcard := Convert( slices, 10 );
            rec.cctc := Convert( slices, 11 );
            rec.combamt := Convert( slices, 12 );
            rec.combbk := Convert( slices, 13 );
            rec.combpd := Convert( slices, 14 );
            rec.howben := Convert( slices, 15 );
            rec.issue := Convert( slices, 16 );
            rec.notusamt := Convert( slices, 17 );
            rec.notuspd := Convert( slices, 18 );
            rec.numweeks := Convert( slices, 19 );
            rec.numyears := Convert( slices, 20 );
            rec.ordbkno := Convert( slices, 21 );
            rec.pres := Convert( slices, 22 );
            rec.usual := Convert( slices, 23 );
            rec.var1 := Convert( slices, 24 );
            rec.var2 := Convert( slices, 25 );
            rec.var3 := Convert( slices, 26 );
            rec.whorec1 := Convert( slices, 27 );
            rec.whorec2 := Convert( slices, 28 );
            rec.whorec3 := Convert( slices, 29 );
            rec.whorec4 := Convert( slices, 30 );
            rec.whorec5 := Convert( slices, 31 );
            rec.month := Convert( slices, 32 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0809;


   procedure Create_Benunit_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.billnt1 := Convert( slices, 13 );
            rec.billnt2 := Convert( slices, 14 );
            rec.billnt3 := Convert( slices, 15 );
            rec.billnt4 := Convert( slices, 16 );
            rec.billnt5 := Convert( slices, 17 );
            rec.billnt6 := Convert( slices, 18 );
            rec.billnt7 := Convert( slices, 19 );
            rec.billnt8 := Convert( slices, 20 );
            rec.cdelply := Convert( slices, 21 );
            rec.cdepbed := Convert( slices, 22 );
            rec.cdepcel := Convert( slices, 23 );
            rec.cdepeqp := Convert( slices, 24 );
            rec.cdephol := Convert( slices, 25 );
            rec.cdeples := Convert( slices, 26 );
            rec.cdepsum := Convert( slices, 27 );
            rec.cdeptea := Convert( slices, 28 );
            rec.cdeptrp := Convert( slices, 29 );
            rec.coatnt1 := Convert( slices, 30 );
            rec.coatnt2 := Convert( slices, 31 );
            rec.coatnt3 := Convert( slices, 32 );
            rec.coatnt4 := Convert( slices, 33 );
            rec.coatnt5 := Convert( slices, 34 );
            rec.coatnt6 := Convert( slices, 35 );
            rec.coatnt7 := Convert( slices, 36 );
            rec.coatnt8 := Convert( slices, 37 );
            rec.cooknt1 := Convert( slices, 38 );
            rec.cooknt2 := Convert( slices, 39 );
            rec.cooknt3 := Convert( slices, 40 );
            rec.cooknt4 := Convert( slices, 41 );
            rec.cooknt5 := Convert( slices, 42 );
            rec.cooknt6 := Convert( slices, 43 );
            rec.cooknt7 := Convert( slices, 44 );
            rec.cooknt8 := Convert( slices, 45 );
            rec.cplay := Convert( slices, 46 );
            rec.dampnt1 := Convert( slices, 47 );
            rec.dampnt2 := Convert( slices, 48 );
            rec.dampnt3 := Convert( slices, 49 );
            rec.dampnt4 := Convert( slices, 50 );
            rec.dampnt5 := Convert( slices, 51 );
            rec.dampnt6 := Convert( slices, 52 );
            rec.dampnt7 := Convert( slices, 53 );
            rec.dampnt8 := Convert( slices, 54 );
            rec.debt1 := Convert( slices, 55 );
            rec.debt2 := Convert( slices, 56 );
            rec.debt3 := Convert( slices, 57 );
            rec.debt4 := Convert( slices, 58 );
            rec.debt5 := Convert( slices, 59 );
            rec.debt6 := Convert( slices, 60 );
            rec.debt7 := Convert( slices, 61 );
            rec.debt8 := Convert( slices, 62 );
            rec.debt9 := Convert( slices, 63 );
            rec.frndnt1 := Convert( slices, 64 );
            rec.frndnt2 := Convert( slices, 65 );
            rec.frndnt3 := Convert( slices, 66 );
            rec.frndnt4 := Convert( slices, 67 );
            rec.frndnt5 := Convert( slices, 68 );
            rec.frndnt6 := Convert( slices, 69 );
            rec.frndnt7 := Convert( slices, 70 );
            rec.frndnt8 := Convert( slices, 71 );
            rec.hairnt1 := Convert( slices, 72 );
            rec.hairnt2 := Convert( slices, 73 );
            rec.hairnt3 := Convert( slices, 74 );
            rec.hairnt4 := Convert( slices, 75 );
            rec.hairnt5 := Convert( slices, 76 );
            rec.hairnt6 := Convert( slices, 77 );
            rec.hairnt7 := Convert( slices, 78 );
            rec.hairnt8 := Convert( slices, 79 );
            rec.heatnt1 := Convert( slices, 80 );
            rec.heatnt2 := Convert( slices, 81 );
            rec.heatnt3 := Convert( slices, 82 );
            rec.heatnt4 := Convert( slices, 83 );
            rec.heatnt5 := Convert( slices, 84 );
            rec.heatnt6 := Convert( slices, 85 );
            rec.heatnt7 := Convert( slices, 86 );
            rec.heatnt8 := Convert( slices, 87 );
            rec.holnt1 := Convert( slices, 88 );
            rec.holnt2 := Convert( slices, 89 );
            rec.holnt3 := Convert( slices, 90 );
            rec.holnt4 := Convert( slices, 91 );
            rec.holnt5 := Convert( slices, 92 );
            rec.holnt6 := Convert( slices, 93 );
            rec.holnt7 := Convert( slices, 94 );
            rec.holnt8 := Convert( slices, 95 );
            rec.homent1 := Convert( slices, 96 );
            rec.homent2 := Convert( slices, 97 );
            rec.homent3 := Convert( slices, 98 );
            rec.homent4 := Convert( slices, 99 );
            rec.homent5 := Convert( slices, 100 );
            rec.homent6 := Convert( slices, 101 );
            rec.homent7 := Convert( slices, 102 );
            rec.homent8 := Convert( slices, 103 );
            rec.houshe1 := Convert( slices, 104 );
            rec.incchnge := Convert( slices, 105 );
            rec.inchilow := Convert( slices, 106 );
            rec.incold := Convert( slices, 107 );
            rec.issue := Convert( slices, 108 );
            rec.kidinc := Convert( slices, 109 );
            rec.mealnt1 := Convert( slices, 110 );
            rec.mealnt2 := Convert( slices, 111 );
            rec.mealnt3 := Convert( slices, 112 );
            rec.mealnt4 := Convert( slices, 113 );
            rec.mealnt5 := Convert( slices, 114 );
            rec.mealnt6 := Convert( slices, 115 );
            rec.mealnt7 := Convert( slices, 116 );
            rec.mealnt8 := Convert( slices, 117 );
            rec.nhhchild := Convert( slices, 118 );
            rec.oabill := Convert( slices, 119 );
            rec.oacoat := Convert( slices, 120 );
            rec.oacook := Convert( slices, 121 );
            rec.oadamp := Convert( slices, 122 );
            rec.oaexpns := Convert( slices, 123 );
            rec.oafrnd := Convert( slices, 124 );
            rec.oahair := Convert( slices, 125 );
            rec.oaheat := Convert( slices, 126 );
            rec.oahol := Convert( slices, 127 );
            rec.oahome := Convert( slices, 128 );
            rec.oahowpy1 := Convert( slices, 129 );
            rec.oahowpy2 := Convert( slices, 130 );
            rec.oahowpy3 := Convert( slices, 131 );
            rec.oahowpy4 := Convert( slices, 132 );
            rec.oahowpy5 := Convert( slices, 133 );
            rec.oahowpy6 := Convert( slices, 134 );
            rec.oameal := Convert( slices, 135 );
            rec.oaout := Convert( slices, 136 );
            rec.oaphon := Convert( slices, 137 );
            rec.oataxi := Convert( slices, 138 );
            rec.oawarm := Convert( slices, 139 );
            rec.outnt1 := Convert( slices, 140 );
            rec.outnt2 := Convert( slices, 141 );
            rec.outnt3 := Convert( slices, 142 );
            rec.outnt4 := Convert( slices, 143 );
            rec.outnt5 := Convert( slices, 144 );
            rec.outnt6 := Convert( slices, 145 );
            rec.outnt7 := Convert( slices, 146 );
            rec.outnt8 := Convert( slices, 147 );
            rec.phonnt1 := Convert( slices, 148 );
            rec.phonnt2 := Convert( slices, 149 );
            rec.phonnt3 := Convert( slices, 150 );
            rec.phonnt4 := Convert( slices, 151 );
            rec.phonnt5 := Convert( slices, 152 );
            rec.phonnt6 := Convert( slices, 153 );
            rec.phonnt7 := Convert( slices, 154 );
            rec.phonnt8 := Convert( slices, 155 );
            rec.taxint1 := Convert( slices, 156 );
            rec.taxint2 := Convert( slices, 157 );
            rec.taxint3 := Convert( slices, 158 );
            rec.taxint4 := Convert( slices, 159 );
            rec.taxint5 := Convert( slices, 160 );
            rec.taxint6 := Convert( slices, 161 );
            rec.taxint7 := Convert( slices, 162 );
            rec.taxint8 := Convert( slices, 163 );
            rec.totsav := Convert( slices, 164 );
            rec.warmnt1 := Convert( slices, 165 );
            rec.warmnt2 := Convert( slices, 166 );
            rec.warmnt3 := Convert( slices, 167 );
            rec.warmnt4 := Convert( slices, 168 );
            rec.warmnt5 := Convert( slices, 169 );
            rec.warmnt6 := Convert( slices, 170 );
            rec.warmnt7 := Convert( slices, 171 );
            rec.warmnt8 := Convert( slices, 172 );
            rec.month := Convert( slices, 173 );
            rec.actaccb := Convert( slices, 174 );
            rec.adddabu := Convert( slices, 175 );
            rec.adultb := Convert( slices, 176 );
            rec.basactb := Convert( slices, 177 );
            rec.boarder := Convert( slices, 178 );
            rec.bpeninc := Convert( slices, 179 );
            rec.bseinc := Convert( slices, 180 );
            rec.buagegr2 := Convert( slices, 181 );
            rec.buagegrp := Convert( slices, 184 );
            rec.budisben := Convert( slices, 185 );
            rec.buearns := Convert( slices, 186 );
            rec.buethgr2 := Convert( slices, 187 );
            rec.buinc := Convert( slices, 188 );
            rec.buinv := Convert( slices, 189 );
            rec.buirben := Convert( slices, 190 );
            rec.bukids := Convert( slices, 191 );
            rec.bunirben := Convert( slices, 192 );
            rec.buothben := Convert( slices, 193 );
            rec.burent := Convert( slices, 194 );
            rec.burinc := Convert( slices, 195 );
            rec.burpinc := Convert( slices, 196 );
            rec.butvlic := Convert( slices, 197 );
            rec.butxcred := Convert( slices, 198 );
            rec.chddabu := Convert( slices, 199 );
            rec.crunacb := Convert( slices, 200 );
            rec.curactb := Convert( slices, 201 );
            rec.depchldb := Convert( slices, 202 );
            rec.depdeds := Convert( slices, 203 );
            rec.disindhb := Convert( slices, 204 );
            rec.ecotypbu := Convert( slices, 205 );
            rec.ecstatbu := Convert( slices, 206 );
            rec.enomortb := Convert( slices, 207 );
            rec.famtypbs := Convert( slices, 208 );
            rec.famtypbu := Convert( slices, 209 );
            rec.famtype := Convert( slices, 210 );
            rec.fsbndctb := Convert( slices, 211 );
            rec.fsmbu := Convert( slices, 212 );
            rec.fsmlkbu := Convert( slices, 213 );
            rec.gebactb := Convert( slices, 214 );
            rec.giltctb := Convert( slices, 215 );
            rec.gross3 := Convert( slices, 216 );
            rec.hbindbu := Convert( slices, 217 );
            rec.hbindbu2 := Convert( slices, 218 );
            rec.heartbu := Convert( slices, 219 );
            rec.isactb := Convert( slices, 220 );
            rec.kid04 := Convert( slices, 221 );
            rec.kid1115 := Convert( slices, 222 );
            rec.kid1619 := Convert( slices, 223 );
            rec.kid510 := Convert( slices, 224 );
            rec.lastwork := Convert( slices, 225 );
            rec.lodger := Convert( slices, 226 );
            rec.newfambu := Convert( slices, 227 );
            rec.nsboctb := Convert( slices, 228 );
            rec.otbsctb := Convert( slices, 229 );
            rec.pepsctb := Convert( slices, 230 );
            rec.poacctb := Convert( slices, 231 );
            rec.pocardb := Convert( slices, 232 );
            rec.prboctb := Convert( slices, 233 );
            rec.sayectb := Convert( slices, 234 );
            rec.sclbctb := Convert( slices, 235 );
            rec.ssctb := Convert( slices, 236 );
            rec.stshctb := Convert( slices, 237 );
            rec.subltamt := Convert( slices, 238 );
            rec.tessctb := Convert( slices, 239 );
            rec.totcapb2 := Convert( slices, 240 );
            rec.totsavbu := Convert( slices, 241 );
            rec.tuburent := Convert( slices, 242 );
            rec.untrctb := Convert( slices, 243 );
            rec.youngch := Convert( slices, 244 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0809;


   procedure Create_Care_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.issue := Convert( slices, 46 );
            rec.wholoo01 := Convert( slices, 47 );
            rec.wholoo02 := Convert( slices, 48 );
            rec.wholoo03 := Convert( slices, 49 );
            rec.wholoo04 := Convert( slices, 50 );
            rec.wholoo05 := Convert( slices, 51 );
            rec.wholoo06 := Convert( slices, 52 );
            rec.wholoo07 := Convert( slices, 53 );
            rec.wholoo08 := Convert( slices, 54 );
            rec.wholoo09 := Convert( slices, 55 );
            rec.wholoo10 := Convert( slices, 56 );
            rec.wholoo11 := Convert( slices, 57 );
            rec.wholoo12 := Convert( slices, 58 );
            rec.wholoo13 := Convert( slices, 59 );
            rec.wholoo14 := Convert( slices, 60 );
            rec.wholoo15 := Convert( slices, 61 );
            rec.wholoo16 := Convert( slices, 62 );
            rec.wholoo17 := Convert( slices, 63 );
            rec.wholoo18 := Convert( slices, 64 );
            rec.wholoo19 := Convert( slices, 65 );
            rec.wholoo20 := Convert( slices, 66 );
            rec.month := Convert( slices, 67 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0809;


   procedure Create_Child_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddaprg := Convert( slices, 7 );
            rec.cddatre := Convert( slices, 8 );
            rec.cddatrep := Convert( slices, 9 );
            rec.cdisdif1 := Convert( slices, 10 );
            rec.cdisdif2 := Convert( slices, 11 );
            rec.cdisdif3 := Convert( slices, 12 );
            rec.cdisdif4 := Convert( slices, 13 );
            rec.cdisdif5 := Convert( slices, 14 );
            rec.cdisdif6 := Convert( slices, 15 );
            rec.cdisdif7 := Convert( slices, 16 );
            rec.cdisdif8 := Convert( slices, 17 );
            rec.cdisdif9 := Convert( slices, 18 );
            rec.cdisdifp := Convert( slices, 19 );
            rec.cfund := Convert( slices, 20 );
            rec.cfundh := Convert( slices, 21 );
            rec.cfundtp := Convert( slices, 22 );
            rec.chamtern := Convert( slices, 23 );
            rec.chamttst := Convert( slices, 24 );
            rec.chdla1 := Convert( slices, 25 );
            rec.chdla2 := Convert( slices, 26 );
            rec.chealth := Convert( slices, 27 );
            rec.chearns1 := Convert( slices, 28 );
            rec.chearns2 := Convert( slices, 29 );
            rec.chema := Convert( slices, 30 );
            rec.chemaamt := Convert( slices, 31 );
            rec.chemapd := Convert( slices, 32 );
            rec.chpdern := Convert( slices, 33 );
            rec.chpdtst := Convert( slices, 34 );
            rec.chprob := Convert( slices, 35 );
            rec.chsave := Convert( slices, 36 );
            rec.chwkern := Convert( slices, 37 );
            rec.chwktst := Convert( slices, 38 );
            rec.chyrern := Convert( slices, 39 );
            rec.chyrtst := Convert( slices, 40 );
            rec.cohabit := Convert( slices, 41 );
            rec.convbl := Convert( slices, 42 );
            rec.cvht := Convert( slices, 43 );
            rec.cvpay := Convert( slices, 44 );
            rec.cvpd := Convert( slices, 45 );
            rec.depend := Convert( slices, 46 );
            rec.dob := Convert( slices, 47 );
            rec.eligadlt := Convert( slices, 48 );
            rec.eligchld := Convert( slices, 49 );
            rec.endyr := Convert( slices, 50 );
            rec.fted := Convert( slices, 51 );
            rec.fundamt1 := Convert( slices, 52 );
            rec.fundamt2 := Convert( slices, 53 );
            rec.fundamt3 := Convert( slices, 54 );
            rec.fundamt4 := Convert( slices, 55 );
            rec.fundamt5 := Convert( slices, 56 );
            rec.fundamt6 := Convert( slices, 57 );
            rec.givcfnd1 := Convert( slices, 58 );
            rec.givcfnd2 := Convert( slices, 59 );
            rec.givcfnd3 := Convert( slices, 60 );
            rec.givcfnd4 := Convert( slices, 61 );
            rec.givcfnd5 := Convert( slices, 62 );
            rec.givcfnd6 := Convert( slices, 63 );
            rec.grant := Convert( slices, 64 );
            rec.grtamt1 := Convert( slices, 65 );
            rec.grtamt2 := Convert( slices, 66 );
            rec.grtdir1 := Convert( slices, 67 );
            rec.grtdir2 := Convert( slices, 68 );
            rec.grtnum := Convert( slices, 69 );
            rec.grtsce1 := Convert( slices, 70 );
            rec.grtsce2 := Convert( slices, 71 );
            rec.grtval1 := Convert( slices, 72 );
            rec.grtval2 := Convert( slices, 73 );
            rec.hholder := Convert( slices, 74 );
            rec.issue := Convert( slices, 75 );
            rec.lareg := Convert( slices, 76 );
            rec.legdep := Convert( slices, 77 );
            rec.ms := Convert( slices, 78 );
            rec.parent1 := Convert( slices, 79 );
            rec.parent2 := Convert( slices, 80 );
            rec.r01 := Convert( slices, 81 );
            rec.r02 := Convert( slices, 82 );
            rec.r03 := Convert( slices, 83 );
            rec.r04 := Convert( slices, 84 );
            rec.r05 := Convert( slices, 85 );
            rec.r06 := Convert( slices, 86 );
            rec.r07 := Convert( slices, 87 );
            rec.r08 := Convert( slices, 88 );
            rec.r09 := Convert( slices, 89 );
            rec.r10 := Convert( slices, 90 );
            rec.r11 := Convert( slices, 91 );
            rec.r12 := Convert( slices, 92 );
            rec.r13 := Convert( slices, 93 );
            rec.r14 := Convert( slices, 94 );
            rec.schchk := Convert( slices, 95 );
            rec.sex := Convert( slices, 96 );
            rec.smkit := Convert( slices, 97 );
            rec.smlit := Convert( slices, 98 );
            rec.spcreg1 := Convert( slices, 99 );
            rec.spcreg2 := Convert( slices, 100 );
            rec.spcreg3 := Convert( slices, 101 );
            rec.spout := Convert( slices, 102 );
            rec.srentamt := Convert( slices, 103 );
            rec.srentpd := Convert( slices, 104 );
            rec.startyr := Convert( slices, 105 );
            rec.totsave := Convert( slices, 106 );
            rec.trainee := Convert( slices, 107 );
            rec.typeed := Convert( slices, 108 );
            rec.wmkit := Convert( slices, 109 );
            rec.month := Convert( slices, 110 );
            rec.careab := Convert( slices, 111 );
            rec.careah := Convert( slices, 112 );
            rec.carecb := Convert( slices, 113 );
            rec.carech := Convert( slices, 114 );
            rec.carecl := Convert( slices, 115 );
            rec.carefl := Convert( slices, 116 );
            rec.carefr := Convert( slices, 117 );
            rec.careot := Convert( slices, 118 );
            rec.carere := Convert( slices, 119 );
            rec.chdda := Convert( slices, 120 );
            rec.chearns := Convert( slices, 121 );
            rec.chincdv := Convert( slices, 122 );
            rec.chrinc := Convert( slices, 123 );
            rec.fsmlkval := Convert( slices, 124 );
            rec.fsmval := Convert( slices, 125 );
            rec.hdagech := Convert( slices, 126 );
            rec.heartval := Convert( slices, 127 );
            rec.hourab := Convert( slices, 128 );
            rec.hourah := Convert( slices, 129 );
            rec.hourcb := Convert( slices, 130 );
            rec.hourch := Convert( slices, 131 );
            rec.hourcl := Convert( slices, 132 );
            rec.hourfr := Convert( slices, 133 );
            rec.hourot := Convert( slices, 134 );
            rec.hourre := Convert( slices, 135 );
            rec.hourtot := Convert( slices, 136 );
            rec.hperson := Convert( slices, 137 );
            rec.iagegr2 := Convert( slices, 138 );
            rec.iagegrp := Convert( slices, 139 );
            rec.relhrp := Convert( slices, 140 );
            rec.totgntch := Convert( slices, 141 );
            rec.tuacam := Convert( slices, 142 );
            rec.uperson := Convert( slices, 143 );
            rec.xbonflag := Convert( slices, 144 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0809;


   procedure Create_ChildCare_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.benccdis := Convert( slices, 5 );
            rec.chamt := Convert( slices, 6 );
            rec.chhr := Convert( slices, 7 );
            rec.chpd := Convert( slices, 8 );
            rec.cost := Convert( slices, 9 );
            rec.ctrm := Convert( slices, 10 );
            rec.emplprov := Convert( slices, 11 );
            rec.issue := Convert( slices, 12 );
            rec.pmchk := Convert( slices, 13 );
            rec.registrd := Convert( slices, 14 );
            rec.month := Convert( slices, 15 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_0809;


   procedure Create_Endowment_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.menpolam := Convert( slices, 6 );
            rec.menpolpd := Convert( slices, 7 );
            rec.menstyr := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0809;


   procedure Create_ExtChild_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.nhhamt := Convert( slices, 5 );
            rec.nhhfee := Convert( slices, 6 );
            rec.nhhintro := Convert( slices, 7 );
            rec.nhhpd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0809;


   procedure Create_GovPay_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0809;


   procedure Create_Hbai_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.benunits := Convert( slices, 19 );
            rec.gvtregn := Convert( slices, 20 );
            rec.hhstat := Convert( slices, 21 );
            rec.tenure := Convert( slices, 22 );
            rec.adulth := Convert( slices, 23 );
            rec.depchldh := Convert( slices, 24 );
            rec.ptentyp2 := Convert( slices, 25 );
            rec.tentyp2 := Convert( slices, 26 );
            rec.watsewrt := Convert( slices, 27 );
            rec.sewerage := Convert( slices, 28 );
            rec.cwathh := Convert( slices, 29 );
            rec.totsthh := Convert( slices, 30 );
            rec.totstrhh := Convert( slices, 31 );
            rec.charghh := Convert( slices, 32 );
            rec.hbmort := Convert( slices, 33 );
            rec.hbxmort := Convert( slices, 34 );
            rec.hrenthh := Convert( slices, 35 );
            rec.erenthh := Convert( slices, 36 );
            rec.hbenhh := Convert( slices, 37 );
            rec.watsewhh := Convert( slices, 38 );
            rec.hhcost := Convert( slices, 39 );
            rec.ehcost := Convert( slices, 40 );
            rec.bhcdef := Convert( slices, 41 );
            rec.ahcdef := Convert( slices, 42 );
            rec.ctrebam1 := Convert( slices, 43 );
            rec.cwatadj := Convert( slices, 44 );
            rec.adultb := Convert( slices, 45 );
            rec.egrincbu := Convert( slices, 46 );
            rec.entincbu := Convert( slices, 47 );
            rec.hgrernhh := Convert( slices, 48 );
            rec.hnternhh := Convert( slices, 49 );
            rec.hgrinvhh := Convert( slices, 50 );
            rec.hntinvhh := Convert( slices, 51 );
            rec.hgrocchh := Convert( slices, 52 );
            rec.hntocchh := Convert( slices, 53 );
            rec.chbenhh := Convert( slices, 54 );
            rec.hbeninhh := Convert( slices, 55 );
            rec.hpribnhh := Convert( slices, 56 );
            rec.hmiscihh := Convert( slices, 57 );
            rec.sfrpahh := Convert( slices, 58 );
            rec.hgrinchh := Convert( slices, 59 );
            rec.hntinchh := Convert( slices, 60 );
            rec.inchilhh := Convert( slices, 61 );
            rec.sehhflg := Convert( slices, 62 );
            rec.ethgrphh := Convert( slices, 63 );
            rec.egrernhh := Convert( slices, 64 );
            rec.enternhh := Convert( slices, 65 );
            rec.ebeninhh := Convert( slices, 66 );
            rec.epribnhh := Convert( slices, 67 );
            rec.emiscihh := Convert( slices, 68 );
            rec.eothdehh := Convert( slices, 69 );
            rec.egrinchh := Convert( slices, 70 );
            rec.entinchh := Convert( slices, 71 );
            rec.tvlichh := Convert( slices, 72 );
            rec.g_newhh := Convert( slices, 73 );
            rec.gnewhhp := Convert( slices, 74 );
            rec.esgjobhh := Convert( slices, 75 );
            rec.esgrsehh := Convert( slices, 76 );
            rec.esginvhh := Convert( slices, 77 );
            rec.esgocchh := Convert( slices, 78 );
            rec.esmischh := Convert( slices, 79 );
            rec.espribhh := Convert( slices, 80 );
            rec.esbenihh := Convert( slices, 81 );
            rec.esothdhh := Convert( slices, 82 );
            rec.esginchh := Convert( slices, 83 );
            rec.esninchh := Convert( slices, 84 );
            rec.ericphh := Convert( slices, 85 );
            rec.ericnphh := Convert( slices, 86 );
            rec.gs_newhh := Convert( slices, 87 );
            rec.gs_newpph := Convert( slices, 88 );
            rec.es_hcost := Convert( slices, 89 );
            rec.esahchh := Convert( slices, 90 );
            rec.eahchh := Convert( slices, 91 );
            rec.benunit := Convert( slices, 92 );
            rec.depchldb := Convert( slices, 93 );
            rec.eqmcoup := Convert( slices, 94 );
            rec.eqmbhckd := Convert( slices, 95 );
            rec.eqmahckd := Convert( slices, 96 );
            rec.eqmbhchh := Convert( slices, 97 );
            rec.eqmahchh := Convert( slices, 98 );
            rec.over14 := Convert( slices, 99 );
            rec.under14 := Convert( slices, 100 );
            rec.eqobhchh := Convert( slices, 101 );
            rec.eqoahchh := Convert( slices, 102 );
            rec.mc_bhc := Convert( slices, 103 );
            rec.oe_bhc := Convert( slices, 104 );
            rec.mc_gro := Convert( slices, 105 );
            rec.oe_gro := Convert( slices, 106 );
            rec.mc_ahc := Convert( slices, 107 );
            rec.oe_ahc := Convert( slices, 108 );
            rec.s_mc_bhc := Convert( slices, 109 );
            rec.s_oe_bhc := Convert( slices, 110 );
            rec.s_mc_gro := Convert( slices, 111 );
            rec.s_oe_gro := Convert( slices, 112 );
            rec.s_mc_ahc := Convert( slices, 113 );
            rec.s_oe_ahc := Convert( slices, 114 );
            rec.fsmbu := Convert( slices, 115 );
            rec.fsmlkbu := Convert( slices, 116 );
            rec.hbenbu := Convert( slices, 117 );
            rec.ehbenbu := Convert( slices, 118 );
            rec.srentbu := Convert( slices, 119 );
            rec.rentbu := Convert( slices, 120 );
            rec.erentbu := Convert( slices, 121 );
            rec.insebu := Convert( slices, 122 );
            rec.ginsebu := Convert( slices, 123 );
            rec.chbenbu := Convert( slices, 124 );
            rec.hgrernbu := Convert( slices, 125 );
            rec.hnternbu := Convert( slices, 126 );
            rec.hgrinvbu := Convert( slices, 127 );
            rec.hntinvbu := Convert( slices, 128 );
            rec.hgroccbu := Convert( slices, 129 );
            rec.hntoccbu := Convert( slices, 130 );
            rec.hbeninbu := Convert( slices, 131 );
            rec.hpribnbu := Convert( slices, 132 );
            rec.hmiscibu := Convert( slices, 133 );
            rec.sfrpabu := Convert( slices, 134 );
            rec.hgrincbu := Convert( slices, 135 );
            rec.hntincbu := Convert( slices, 136 );
            rec.egrernbu := Convert( slices, 137 );
            rec.enternbu := Convert( slices, 138 );
            rec.ebeninbu := Convert( slices, 139 );
            rec.epribnbu := Convert( slices, 140 );
            rec.emiscibu := Convert( slices, 141 );
            rec.eothdebu := Convert( slices, 142 );
            rec.winpaybu := Convert( slices, 143 );
            rec.tvlicbu := Convert( slices, 144 );
            rec.ecobu := Convert( slices, 145 );
            rec.disabflg := Convert( slices, 146 );
            rec.fambu := Convert( slices, 147 );
            rec.newfambu := Convert( slices, 148 );
            rec.personhd := Convert( slices, 149 );
            rec.personsp := Convert( slices, 150 );
            rec.oldecobu := Convert( slices, 151 );
            rec.kidecobu := Convert( slices, 152 );
            rec.kid0_1 := Convert( slices, 153 );
            rec.kid2_4 := Convert( slices, 154 );
            rec.kid5_7 := Convert( slices, 155 );
            rec.kid8_10 := Convert( slices, 156 );
            rec.kid11_12 := Convert( slices, 157 );
            rec.kid13_15 := Convert( slices, 158 );
            rec.kid16_19 := Convert( slices, 159 );
            rec.boys := Convert( slices, 160 );
            rec.wtcbu := Convert( slices, 161 );
            rec.ctcbu := Convert( slices, 162 );
            rec.isbu := Convert( slices, 163 );
            rec.inchilbu := Convert( slices, 164 );
            rec.g_newbu := Convert( slices, 165 );
            rec.g_newpp := Convert( slices, 166 );
            rec.g_newch := Convert( slices, 167 );
            rec.g_newad := Convert( slices, 168 );
            rec.g_newpn := Convert( slices, 169 );
            rec.g_newwa := Convert( slices, 170 );
            rec.esgjobbu := Convert( slices, 171 );
            rec.esgrsebu := Convert( slices, 172 );
            rec.esginvbu := Convert( slices, 173 );
            rec.esgoccbu := Convert( slices, 174 );
            rec.esmiscbu := Convert( slices, 175 );
            rec.espribbu := Convert( slices, 176 );
            rec.esbenibu := Convert( slices, 177 );
            rec.esothdbu := Convert( slices, 178 );
            rec.esgincbu := Convert( slices, 179 );
            rec.esnincbu := Convert( slices, 180 );
            rec.ericpbu := Convert( slices, 181 );
            rec.ericnpbu := Convert( slices, 182 );
            rec.gs_newbu := Convert( slices, 183 );
            rec.gs_newpp := Convert( slices, 184 );
            rec.gs_newch := Convert( slices, 185 );
            rec.gs_newad := Convert( slices, 186 );
            rec.gs_newpn := Convert( slices, 187 );
            rec.gs_newwa := Convert( slices, 188 );
            rec.mbhcdec := Convert( slices, 189 );
            rec.mqinbhc := Convert( slices, 190 );
            rec.obhcdec := Convert( slices, 191 );
            rec.oqinbhc := Convert( slices, 192 );
            rec.mahcdec := Convert( slices, 193 );
            rec.mqinahc := Convert( slices, 194 );
            rec.oahcdec := Convert( slices, 195 );
            rec.oqinahc := Convert( slices, 196 );
            rec.mbhcdecx := Convert( slices, 197 );
            rec.mqinbhcx := Convert( slices, 198 );
            rec.obhcdecx := Convert( slices, 199 );
            rec.oqinbhcx := Convert( slices, 200 );
            rec.mahcdecx := Convert( slices, 201 );
            rec.mqinahcx := Convert( slices, 202 );
            rec.oahcdecx := Convert( slices, 203 );
            rec.oqinahcx := Convert( slices, 204 );
            rec.agehd := Convert( slices, 205 );
            rec.sexhd := Convert( slices, 206 );
            rec.esbenihd := Convert( slices, 207 );
            rec.esgjobhd := Convert( slices, 209 );
            rec.esgocchd := Convert( slices, 210 );
            rec.esgrsehd := Convert( slices, 211 );
            rec.esmischd := Convert( slices, 212 );
            rec.espribhd := Convert( slices, 213 );
            rec.winpayhd := Convert( slices, 214 );
            rec.agesp := Convert( slices, 215 );
            rec.sexsp := Convert( slices, 216 );
            rec.esbenisp := Convert( slices, 217 );
            rec.esginvsp := Convert( slices, 218 );
            rec.esgjobsp := Convert( slices, 219 );
            rec.esgoccsp := Convert( slices, 220 );
            rec.esgrsesp := Convert( slices, 221 );
            rec.esmiscsp := Convert( slices, 222 );
            rec.espribsp := Convert( slices, 223 );
            rec.winpaysp := Convert( slices, 224 );
            rec.low50bhc := Convert( slices, 225 );
            rec.low60bhc := Convert( slices, 226 );
            rec.low70bhc := Convert( slices, 227 );
            rec.low50ahc := Convert( slices, 228 );
            rec.low60ahc := Convert( slices, 229 );
            rec.low70ahc := Convert( slices, 230 );
            rec.mdscorech := Convert( slices, 231 );
            rec.mdch := Convert( slices, 232 );
            rec.lowincmdch := Convert( slices, 233 );
            rec.lowincmdchsev := Convert( slices, 234 );
            rec.oldkidecobu := Convert( slices, 235 );
            rec.oldsehhflg := Convert( slices, 236 );
            rec.lowmcbhc := Convert( slices, 237 );
            rec.lowmcahc := Convert( slices, 238 );
            rec.sernum := Convert( slices, 239 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0809;


   procedure Create_Household_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.bedroom := Convert( slices, 2 );
            rec.benunits := Convert( slices, 3 );
            rec.billrate := Convert( slices, 4 );
            rec.brma := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.charge1 := Convert( slices, 7 );
            rec.charge2 := Convert( slices, 8 );
            rec.charge3 := Convert( slices, 9 );
            rec.charge4 := Convert( slices, 10 );
            rec.charge5 := Convert( slices, 11 );
            rec.charge6 := Convert( slices, 12 );
            rec.charge7 := Convert( slices, 13 );
            rec.charge8 := Convert( slices, 14 );
            rec.charge9 := Convert( slices, 15 );
            rec.chins := Convert( slices, 16 );
            rec.chrgamt1 := Convert( slices, 17 );
            rec.chrgamt2 := Convert( slices, 18 );
            rec.chrgamt3 := Convert( slices, 19 );
            rec.chrgamt4 := Convert( slices, 20 );
            rec.chrgamt5 := Convert( slices, 21 );
            rec.chrgamt6 := Convert( slices, 22 );
            rec.chrgamt7 := Convert( slices, 23 );
            rec.chrgamt8 := Convert( slices, 24 );
            rec.chrgamt9 := Convert( slices, 25 );
            rec.chrgpd1 := Convert( slices, 26 );
            rec.chrgpd2 := Convert( slices, 27 );
            rec.chrgpd3 := Convert( slices, 28 );
            rec.chrgpd4 := Convert( slices, 29 );
            rec.chrgpd5 := Convert( slices, 30 );
            rec.chrgpd6 := Convert( slices, 31 );
            rec.chrgpd7 := Convert( slices, 32 );
            rec.chrgpd8 := Convert( slices, 33 );
            rec.chrgpd9 := Convert( slices, 34 );
            rec.covoths := Convert( slices, 35 );
            rec.csewamt := Convert( slices, 36 );
            rec.csewamt1 := Convert( slices, 37 );
            rec.ct25d50d := Convert( slices, 38 );
            rec.ctamt := Convert( slices, 39 );
            rec.ctannual := Convert( slices, 40 );
            rec.ctband := Convert( slices, 41 );
            rec.ctbwait := Convert( slices, 42 );
            rec.ctcondoc := Convert( slices, 43 );
            rec.ctdisc := Convert( slices, 44 );
            rec.ctinstal := Convert( slices, 45 );
            rec.ctlvband := Convert( slices, 46 );
            rec.ctlvchk := Convert( slices, 47 );
            rec.ctreb := Convert( slices, 48 );
            rec.ctrebamt := Convert( slices, 49 );
            rec.ctrebpd := Convert( slices, 50 );
            rec.cttime := Convert( slices, 51 );
            rec.cwatamt := Convert( slices, 52 );
            rec.cwatamt1 := Convert( slices, 53 );
            rec.datyrago := Convert( slices, 54 );
            rec.dvadulth := Convert( slices, 55 );
            rec.dvtotad := Convert( slices, 56 );
            rec.entry1 := Convert( slices, 57 );
            rec.entry2 := Convert( slices, 58 );
            rec.entry3 := Convert( slices, 59 );
            rec.entry4 := Convert( slices, 60 );
            rec.entry5 := Convert( slices, 61 );
            rec.entry6 := Convert( slices, 62 );
            rec.floor := Convert( slices, 63 );
            rec.givehelp := Convert( slices, 64 );
            rec.gvtregn := Convert( slices, 65 );
            rec.hhldr01 := Convert( slices, 66 );
            rec.hhldr02 := Convert( slices, 67 );
            rec.hhldr03 := Convert( slices, 68 );
            rec.hhldr04 := Convert( slices, 69 );
            rec.hhldr05 := Convert( slices, 70 );
            rec.hhldr06 := Convert( slices, 71 );
            rec.hhldr07 := Convert( slices, 72 );
            rec.hhldr08 := Convert( slices, 73 );
            rec.hhldr09 := Convert( slices, 74 );
            rec.hhldr10 := Convert( slices, 75 );
            rec.hhldr11 := Convert( slices, 76 );
            rec.hhldr12 := Convert( slices, 77 );
            rec.hhldr13 := Convert( slices, 78 );
            rec.hhldr14 := Convert( slices, 79 );
            rec.hhldr97 := Convert( slices, 80 );
            rec.hhstat := Convert( slices, 81 );
            rec.hrpnum := Convert( slices, 82 );
            rec.imd_e := Convert( slices, 83 );
            rec.imd_s := Convert( slices, 84 );
            rec.imd_w := Convert( slices, 85 );
            rec.intdate := Convert( slices, 86 );
            rec.issue := Convert( slices, 87 );
            rec.lac := Convert( slices, 88 );
            rec.mainacc := Convert( slices, 89 );
            rec.migrq1 := Convert( slices, 90 );
            rec.migrq2 := Convert( slices, 91 );
            rec.mnthcode := Convert( slices, 92 );
            rec.monlive := Convert( slices, 93 );
            rec.needhelp := Convert( slices, 94 );
            rec.nicoun := Convert( slices, 95 );
            rec.ninrv := Convert( slices, 96 );
            rec.nirate := Convert( slices, 97 );
            rec.norate := Convert( slices, 98 );
            rec.numtv1 := Convert( slices, 99 );
            rec.numtv2 := Convert( slices, 100 );
            rec.oac := Convert( slices, 101 );
            rec.onbsroom := Convert( slices, 102 );
            rec.orgsewam := Convert( slices, 103 );
            rec.orgwatam := Convert( slices, 104 );
            rec.payrate := Convert( slices, 105 );
            rec.ptbsroom := Convert( slices, 106 );
            rec.rooms := Convert( slices, 107 );
            rec.roomshar := Convert( slices, 108 );
            rec.rtannual := Convert( slices, 109 );
            rec.rtcondoc := Convert( slices, 110 );
            rec.rtdeduc := Convert( slices, 111 );
            rec.rtinstal := Convert( slices, 112 );
            rec.rtreb := Convert( slices, 113 );
            rec.rtrebamt := Convert( slices, 114 );
            rec.rtrebpd := Convert( slices, 115 );
            rec.rttime := Convert( slices, 116 );
            rec.sampqtr := Convert( slices, 117 );
            rec.schmeal := Convert( slices, 118 );
            rec.schmilk := Convert( slices, 119 );
            rec.sewamt := Convert( slices, 120 );
            rec.sewanul := Convert( slices, 121 );
            rec.sewerpay := Convert( slices, 122 );
            rec.sewsep := Convert( slices, 123 );
            rec.sewtime := Convert( slices, 124 );
            rec.shelter := Convert( slices, 125 );
            rec.sobuy := Convert( slices, 126 );
            rec.sstrtreg := Convert( slices, 127 );
            rec.stramt1 := Convert( slices, 128 );
            rec.stramt2 := Convert( slices, 129 );
            rec.strcov := Convert( slices, 130 );
            rec.strmort := Convert( slices, 131 );
            rec.stroths := Convert( slices, 132 );
            rec.strpd1 := Convert( slices, 133 );
            rec.strpd2 := Convert( slices, 134 );
            rec.suballow := Convert( slices, 135 );
            rec.sublet := Convert( slices, 136 );
            rec.sublety := Convert( slices, 137 );
            rec.subrent := Convert( slices, 138 );
            rec.tenure := Convert( slices, 139 );
            rec.totchild := Convert( slices, 140 );
            rec.totdepdk := Convert( slices, 141 );
            rec.tvlic := Convert( slices, 142 );
            rec.typeacc := Convert( slices, 143 );
            rec.urindew := Convert( slices, 144 );
            rec.urinds := Convert( slices, 145 );
            rec.watamt := Convert( slices, 146 );
            rec.watanul := Convert( slices, 147 );
            rec.watermet := Convert( slices, 148 );
            rec.waterpay := Convert( slices, 149 );
            rec.watrb := Convert( slices, 150 );
            rec.wattime := Convert( slices, 151 );
            rec.welfmilk := Convert( slices, 152 );
            rec.whoctb01 := Convert( slices, 153 );
            rec.whoctb02 := Convert( slices, 154 );
            rec.whoctb03 := Convert( slices, 155 );
            rec.whoctb04 := Convert( slices, 156 );
            rec.whoctb05 := Convert( slices, 157 );
            rec.whoctb06 := Convert( slices, 158 );
            rec.whoctb07 := Convert( slices, 159 );
            rec.whoctb08 := Convert( slices, 160 );
            rec.whoctb09 := Convert( slices, 161 );
            rec.whoctb10 := Convert( slices, 162 );
            rec.whoctb11 := Convert( slices, 163 );
            rec.whoctb12 := Convert( slices, 164 );
            rec.whoctb13 := Convert( slices, 165 );
            rec.whoctb14 := Convert( slices, 166 );
            rec.whoctbns := Convert( slices, 167 );
            rec.whoctbot := Convert( slices, 168 );
            rec.whorsp01 := Convert( slices, 169 );
            rec.whorsp02 := Convert( slices, 170 );
            rec.whorsp03 := Convert( slices, 171 );
            rec.whorsp04 := Convert( slices, 172 );
            rec.whorsp05 := Convert( slices, 173 );
            rec.whorsp06 := Convert( slices, 174 );
            rec.whorsp07 := Convert( slices, 175 );
            rec.whorsp08 := Convert( slices, 176 );
            rec.whorsp09 := Convert( slices, 177 );
            rec.whorsp10 := Convert( slices, 178 );
            rec.whorsp11 := Convert( slices, 179 );
            rec.whorsp12 := Convert( slices, 180 );
            rec.whorsp13 := Convert( slices, 181 );
            rec.whorsp14 := Convert( slices, 182 );
            rec.whynoct := Convert( slices, 183 );
            rec.wmintro := Convert( slices, 184 );
            rec.wsewamt := Convert( slices, 185 );
            rec.wsewanul := Convert( slices, 186 );
            rec.wsewtime := Convert( slices, 187 );
            rec.yearcode := Convert( slices, 188 );
            rec.yearlive := Convert( slices, 189 );
            rec.month := Convert( slices, 190 );
            rec.actacch := Convert( slices, 191 );
            rec.adddahh := Convert( slices, 192 );
            rec.adulth := Convert( slices, 193 );
            rec.basacth := Convert( slices, 194 );
            rec.chddahh := Convert( slices, 196 );
            rec.country := Convert( slices, 197 );
            rec.crunach := Convert( slices, 198 );
            rec.curacth := Convert( slices, 199 );
            rec.cwatamtd := Convert( slices, 200 );
            rec.depchldh := Convert( slices, 201 );
            rec.emp := Convert( slices, 202 );
            rec.emphrp := Convert( slices, 203 );
            rec.endowpay := Convert( slices, 204 );
            rec.enomorth := Convert( slices, 205 );
            rec.fsbndcth := Convert( slices, 206 );
            rec.gbhscost := Convert( slices, 207 );
            rec.gebacth := Convert( slices, 208 );
            rec.giltcth := Convert( slices, 209 );
            rec.gross3 := Convert( slices, 210 );
            rec.grossct := Convert( slices, 211 );
            rec.hbeninc := Convert( slices, 212 );
            rec.hbindhh := Convert( slices, 213 );
            rec.hbindhh2 := Convert( slices, 214 );
            rec.hcband := Convert( slices, 215 );
            rec.hdhhinc := Convert( slices, 216 );
            rec.hdtax := Convert( slices, 217 );
            rec.hearns := Convert( slices, 218 );
            rec.hhagegr2 := Convert( slices, 219 );
            rec.hhagegrp := Convert( slices, 222 );
            rec.hhcomp := Convert( slices, 223 );
            rec.hhcomps := Convert( slices, 224 );
            rec.hhdisben := Convert( slices, 225 );
            rec.hhethgr2 := Convert( slices, 226 );
            rec.hhinc := Convert( slices, 227 );
            rec.hhincbnd := Convert( slices, 228 );
            rec.hhinv := Convert( slices, 229 );
            rec.hhirben := Convert( slices, 230 );
            rec.hhkids := Convert( slices, 231 );
            rec.hhnirben := Convert( slices, 232 );
            rec.hhothben := Convert( slices, 233 );
            rec.hhrent := Convert( slices, 234 );
            rec.hhrinc := Convert( slices, 235 );
            rec.hhrpinc := Convert( slices, 236 );
            rec.hhsize := Convert( slices, 237 );
            rec.hhtvlic := Convert( slices, 238 );
            rec.hhtxcred := Convert( slices, 239 );
            rec.hothinc := Convert( slices, 240 );
            rec.hpeninc := Convert( slices, 241 );
            rec.hrband := Convert( slices, 242 );
            rec.hseinc := Convert( slices, 243 );
            rec.isacth := Convert( slices, 244 );
            rec.london := Convert( slices, 245 );
            rec.mortcost := Convert( slices, 246 );
            rec.mortint := Convert( slices, 247 );
            rec.mortpay := Convert( slices, 248 );
            rec.nddctb := Convert( slices, 249 );
            rec.nddishc := Convert( slices, 250 );
            rec.nihscost := Convert( slices, 251 );
            rec.nsbocth := Convert( slices, 252 );
            rec.otbscth := Convert( slices, 253 );
            rec.pacctype := Convert( slices, 254 );
            rec.penage := Convert( slices, 255 );
            rec.penhrp := Convert( slices, 256 );
            rec.pepscth := Convert( slices, 257 );
            rec.poaccth := Convert( slices, 258 );
            rec.pocardh := Convert( slices, 259 );
            rec.prbocth := Convert( slices, 260 );
            rec.ptentyp2 := Convert( slices, 261 );
            rec.sayecth := Convert( slices, 263 );
            rec.sclbcth := Convert( slices, 264 );
            rec.servpay := Convert( slices, 265 );
            rec.sick := Convert( slices, 266 );
            rec.sickhrp := Convert( slices, 267 );
            rec.sscth := Convert( slices, 268 );
            rec.struins := Convert( slices, 269 );
            rec.stshcth := Convert( slices, 270 );
            rec.tentyp2 := Convert( slices, 271 );
            rec.tesscth := Convert( slices, 272 );
            rec.tuhhrent := Convert( slices, 273 );
            rec.tuwatsew := Convert( slices, 274 );
            rec.untrcth := Convert( slices, 275 );
            rec.watsewrt := Convert( slices, 276 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0809;


   procedure Create_Job_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.chvamt := Convert( slices, 22 );
            rec.chvpd := Convert( slices, 23 );
            rec.chvsac := Convert( slices, 24 );
            rec.chvuamt := Convert( slices, 25 );
            rec.chvupd := Convert( slices, 26 );
            rec.chvusu := Convert( slices, 27 );
            rec.dedoth := Convert( slices, 28 );
            rec.deduc1 := Convert( slices, 29 );
            rec.deduc2 := Convert( slices, 30 );
            rec.deduc3 := Convert( slices, 31 );
            rec.deduc4 := Convert( slices, 32 );
            rec.deduc5 := Convert( slices, 33 );
            rec.deduc6 := Convert( slices, 34 );
            rec.deduc7 := Convert( slices, 35 );
            rec.deduc8 := Convert( slices, 36 );
            rec.dirctr := Convert( slices, 37 );
            rec.dirni := Convert( slices, 38 );
            rec.dvtothru := Convert( slices, 39 );
            rec.dvushr := Convert( slices, 40 );
            rec.empany := Convert( slices, 41 );
            rec.empown := Convert( slices, 42 );
            rec.etype := Convert( slices, 43 );
            rec.everot := Convert( slices, 44 );
            rec.expben01 := Convert( slices, 45 );
            rec.expben02 := Convert( slices, 46 );
            rec.expben03 := Convert( slices, 47 );
            rec.expben04 := Convert( slices, 48 );
            rec.expben05 := Convert( slices, 49 );
            rec.expben06 := Convert( slices, 50 );
            rec.expben07 := Convert( slices, 51 );
            rec.expben08 := Convert( slices, 52 );
            rec.expben09 := Convert( slices, 53 );
            rec.expben10 := Convert( slices, 54 );
            rec.expben11 := Convert( slices, 55 );
            rec.expben12 := Convert( slices, 56 );
            rec.ftpt := Convert( slices, 57 );
            rec.grsofar := Convert( slices, 58 );
            rec.grwage := Convert( slices, 59 );
            rec.grwagpd := Convert( slices, 60 );
            rec.hha1 := Convert( slices, 61 );
            rec.hha2 := Convert( slices, 62 );
            rec.hha3 := Convert( slices, 63 );
            rec.hhc1 := Convert( slices, 64 );
            rec.hhc2 := Convert( slices, 65 );
            rec.hhc3 := Convert( slices, 66 );
            rec.hohinc := Convert( slices, 67 );
            rec.inclpay1 := Convert( slices, 68 );
            rec.inclpay2 := Convert( slices, 69 );
            rec.inclpay3 := Convert( slices, 70 );
            rec.inclpay4 := Convert( slices, 71 );
            rec.inclpay5 := Convert( slices, 72 );
            rec.inclpay6 := Convert( slices, 73 );
            rec.inclpay7 := Convert( slices, 74 );
            rec.instype1 := Convert( slices, 75 );
            rec.instype2 := Convert( slices, 76 );
            rec.issue := Convert( slices, 77 );
            rec.jobbus := Convert( slices, 78 );
            rec.likehr := Convert( slices, 79 );
            rec.mademp := Convert( slices, 80 );
            rec.matemp := Convert( slices, 81 );
            rec.matstp := Convert( slices, 82 );
            rec.mileamt := Convert( slices, 83 );
            rec.motamt := Convert( slices, 84 );
            rec.natins := Convert( slices, 85 );
            rec.nature := Convert( slices, 86 );
            rec.nidamt := Convert( slices, 87 );
            rec.nidpd := Convert( slices, 88 );
            rec.nmchc := Convert( slices, 89 );
            rec.nmper := Convert( slices, 90 );
            rec.nomor1 := Convert( slices, 91 );
            rec.nomor2 := Convert( slices, 92 );
            rec.nomor3 := Convert( slices, 93 );
            rec.numemp := Convert( slices, 94 );
            rec.othded1 := Convert( slices, 95 );
            rec.othded2 := Convert( slices, 96 );
            rec.othded3 := Convert( slices, 97 );
            rec.othded4 := Convert( slices, 98 );
            rec.othded5 := Convert( slices, 99 );
            rec.othded6 := Convert( slices, 100 );
            rec.othded7 := Convert( slices, 101 );
            rec.othded8 := Convert( slices, 102 );
            rec.othded9 := Convert( slices, 103 );
            rec.ownamt := Convert( slices, 104 );
            rec.ownotamt := Convert( slices, 105 );
            rec.ownother := Convert( slices, 106 );
            rec.ownsum := Convert( slices, 107 );
            rec.paperiod := Convert( slices, 108 );
            rec.payamt := Convert( slices, 109 );
            rec.paydat := Convert( slices, 110 );
            rec.paye := Convert( slices, 111 );
            rec.paypd := Convert( slices, 112 );
            rec.payslip := Convert( slices, 113 );
            rec.payusl := Convert( slices, 114 );
            rec.pothr := Convert( slices, 115 );
            rec.ppperiod := Convert( slices, 116 );
            rec.prbefore := Convert( slices, 117 );
            rec.prevmth := Convert( slices, 118 );
            rec.prevyr := Convert( slices, 119 );
            rec.profdocs := Convert( slices, 120 );
            rec.profit1 := Convert( slices, 121 );
            rec.profit2 := Convert( slices, 122 );
            rec.profni := Convert( slices, 123 );
            rec.proftax := Convert( slices, 124 );
            rec.rspoth := Convert( slices, 125 );
            rec.salsac := Convert( slices, 126 );
            rec.sapamt := Convert( slices, 127 );
            rec.se1 := Convert( slices, 128 );
            rec.se2 := Convert( slices, 129 );
            rec.seend := Convert( slices, 130 );
            rec.seincamt := Convert( slices, 131 );
            rec.seincwm := Convert( slices, 132 );
            rec.selwks := Convert( slices, 133 );
            rec.seniiamt := Convert( slices, 134 );
            rec.seniinc := Convert( slices, 135 );
            rec.senilamt := Convert( slices, 136 );
            rec.senilump := Convert( slices, 137 );
            rec.seniramt := Convert( slices, 138 );
            rec.senireg := Convert( slices, 139 );
            rec.senirpd := Convert( slices, 140 );
            rec.setax := Convert( slices, 141 );
            rec.setaxamt := Convert( slices, 142 );
            rec.smpamt := Convert( slices, 143 );
            rec.smprate := Convert( slices, 144 );
            rec.sole := Convert( slices, 145 );
            rec.sppamt := Convert( slices, 146 );
            rec.sspamt := Convert( slices, 147 );
            rec.taxamt := Convert( slices, 148 );
            rec.taxdamt := Convert( slices, 149 );
            rec.taxdpd := Convert( slices, 150 );
            rec.totus1 := Convert( slices, 151 );
            rec.ubonamt := Convert( slices, 152 );
            rec.uboninc := Convert( slices, 153 );
            rec.udeduc1 := Convert( slices, 154 );
            rec.udeduc2 := Convert( slices, 155 );
            rec.udeduc3 := Convert( slices, 156 );
            rec.udeduc4 := Convert( slices, 157 );
            rec.udeduc5 := Convert( slices, 158 );
            rec.udeduc6 := Convert( slices, 159 );
            rec.udeduc7 := Convert( slices, 160 );
            rec.udeduc8 := Convert( slices, 161 );
            rec.ugross := Convert( slices, 162 );
            rec.uincpay1 := Convert( slices, 163 );
            rec.uincpay2 := Convert( slices, 164 );
            rec.uincpay3 := Convert( slices, 165 );
            rec.uincpay4 := Convert( slices, 166 );
            rec.uincpay5 := Convert( slices, 167 );
            rec.uincpay6 := Convert( slices, 168 );
            rec.uincpay7 := Convert( slices, 169 );
            rec.umileamt := Convert( slices, 170 );
            rec.umotamt := Convert( slices, 171 );
            rec.unett := Convert( slices, 172 );
            rec.uothded1 := Convert( slices, 173 );
            rec.uothded2 := Convert( slices, 174 );
            rec.uothded3 := Convert( slices, 175 );
            rec.uothded4 := Convert( slices, 176 );
            rec.uothded5 := Convert( slices, 177 );
            rec.uothded6 := Convert( slices, 178 );
            rec.uothded7 := Convert( slices, 179 );
            rec.uothded8 := Convert( slices, 180 );
            rec.uothded9 := Convert( slices, 181 );
            rec.uothdtot := Convert( slices, 182 );
            rec.uothr := Convert( slices, 183 );
            rec.upd := Convert( slices, 184 );
            rec.usapamt := Convert( slices, 185 );
            rec.usmpamt := Convert( slices, 186 );
            rec.usmprate := Convert( slices, 187 );
            rec.usppamt := Convert( slices, 188 );
            rec.usspamt := Convert( slices, 189 );
            rec.usuhr := Convert( slices, 190 );
            rec.utaxamt := Convert( slices, 191 );
            rec.watdid := Convert( slices, 192 );
            rec.watprev := Convert( slices, 193 );
            rec.where := Convert( slices, 194 );
            rec.whynopro := Convert( slices, 195 );
            rec.whynou01 := Convert( slices, 196 );
            rec.whynou02 := Convert( slices, 197 );
            rec.whynou03 := Convert( slices, 198 );
            rec.whynou04 := Convert( slices, 199 );
            rec.whynou05 := Convert( slices, 200 );
            rec.whynou06 := Convert( slices, 201 );
            rec.whynou07 := Convert( slices, 202 );
            rec.whynou08 := Convert( slices, 203 );
            rec.whynou09 := Convert( slices, 204 );
            rec.whynou10 := Convert( slices, 205 );
            rec.whynou11 := Convert( slices, 206 );
            rec.workacc := Convert( slices, 207 );
            rec.workmth := Convert( slices, 208 );
            rec.workyr := Convert( slices, 209 );
            rec.wrkprev := Convert( slices, 210 );
            rec.month := Convert( slices, 211 );
            rec.hdqhrs := Convert( slices, 212 );
            rec.jobhours := Convert( slices, 213 );
            rec.sspsmpfg := Convert( slices, 214 );
            rec.ugrspay := Convert( slices, 215 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0809;


   procedure Create_Maint_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.m := Convert( slices, 6 );
            rec.mrage := Convert( slices, 7 );
            rec.mramt := Convert( slices, 8 );
            rec.mrchwhy1 := Convert( slices, 9 );
            rec.mrchwhy2 := Convert( slices, 10 );
            rec.mrchwhy3 := Convert( slices, 11 );
            rec.mrchwhy4 := Convert( slices, 12 );
            rec.mrchwhy5 := Convert( slices, 13 );
            rec.mrchwhy6 := Convert( slices, 14 );
            rec.mrchwhy7 := Convert( slices, 15 );
            rec.mrchwhy8 := Convert( slices, 16 );
            rec.mrchwhy9 := Convert( slices, 17 );
            rec.mrct := Convert( slices, 18 );
            rec.mrkid := Convert( slices, 19 );
            rec.mrpd := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0809;


   procedure Create_MortCont_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.outsamt := Convert( slices, 5 );
            rec.outsincl := Convert( slices, 6 );
            rec.outspay := Convert( slices, 7 );
            rec.outspd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0809;


   procedure Create_Mortgage_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.issue := Convert( slices, 31 );
            rec.loan2y := Convert( slices, 32 );
            rec.loanyear := Convert( slices, 33 );
            rec.menpol := Convert( slices, 34 );
            rec.morall := Convert( slices, 35 );
            rec.morflc := Convert( slices, 36 );
            rec.morinpay := Convert( slices, 37 );
            rec.morinpd := Convert( slices, 38 );
            rec.morinus := Convert( slices, 39 );
            rec.mortend := Convert( slices, 40 );
            rec.mortleft := Convert( slices, 41 );
            rec.mortprot := Convert( slices, 42 );
            rec.morttype := Convert( slices, 43 );
            rec.morupd := Convert( slices, 44 );
            rec.morus := Convert( slices, 45 );
            rec.mpcover1 := Convert( slices, 46 );
            rec.mpcover2 := Convert( slices, 47 );
            rec.mpcover3 := Convert( slices, 48 );
            rec.mpolno := Convert( slices, 49 );
            rec.outsmort := Convert( slices, 50 );
            rec.rentfrom := Convert( slices, 51 );
            rec.rmamt := Convert( slices, 52 );
            rec.rmort := Convert( slices, 53 );
            rec.rmortyr := Convert( slices, 54 );
            rec.rmpur001 := Convert( slices, 55 );
            rec.rmpur002 := Convert( slices, 56 );
            rec.rmpur003 := Convert( slices, 57 );
            rec.rmpur004 := Convert( slices, 58 );
            rec.rmpur005 := Convert( slices, 59 );
            rec.rmpur006 := Convert( slices, 60 );
            rec.rmpur007 := Convert( slices, 61 );
            rec.rmpur008 := Convert( slices, 62 );
            rec.month := Convert( slices, 63 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0809;


   procedure Create_Nimigr_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Nimigr_IO.File_Type;
      rec         : Nimigr_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Nimigr_IO.Create (bin_file, Nimigr_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.miper := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.miage := Convert( slices, 4 );
            rec.misex := Convert( slices, 5 );
            rec.mnthleft := Convert( slices, 6 );
            rec.more1yr := Convert( slices, 7 );
            rec.wherenow := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( NimigrRec ).startPos = 0 ) then
               index.pointers( NimigrRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( NimigrRec ).counter := index.pointers( NimigrRec ).counter + 1;
            Put_Index( index_map, index );
            Nimigr_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Nimigr_IO.Close( bin_file );
   end Create_Nimigr_0809;


   procedure Create_OddJob_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.ojamt := Convert( slices, 7 );
            rec.ojnow := Convert( slices, 8 );
            rec.ojreg := Convert( slices, 9 );
            rec.month := Convert( slices, 10 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0809;


   procedure Create_Owner_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.othmort1 := Convert( slices, 4 );
            rec.othmort2 := Convert( slices, 5 );
            rec.othmort3 := Convert( slices, 6 );
            rec.othpur1 := Convert( slices, 7 );
            rec.othpur2 := Convert( slices, 8 );
            rec.othpur3 := Convert( slices, 9 );
            rec.othpur31 := Convert( slices, 10 );
            rec.othpur32 := Convert( slices, 11 );
            rec.othpur33 := Convert( slices, 12 );
            rec.othpur34 := Convert( slices, 13 );
            rec.othpur35 := Convert( slices, 14 );
            rec.othpur36 := Convert( slices, 15 );
            rec.othpur37 := Convert( slices, 16 );
            rec.othpur4 := Convert( slices, 17 );
            rec.othpur5 := Convert( slices, 18 );
            rec.othpur6 := Convert( slices, 19 );
            rec.othpur7 := Convert( slices, 20 );
            rec.purcamt := Convert( slices, 21 );
            rec.purcloan := Convert( slices, 22 );
            rec.month := Convert( slices, 23 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0809;


   procedure Create_PenAmt_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.penq := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0809;


   procedure Create_PenProv_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppen := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eptype := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.penamt := Convert( slices, 8 );
            rec.penamtpd := Convert( slices, 9 );
            rec.pencon := Convert( slices, 10 );
            rec.pendat := Convert( slices, 11 );
            rec.pengov := Convert( slices, 12 );
            rec.penhelp := Convert( slices, 13 );
            rec.penmort := Convert( slices, 14 );
            rec.penreb := Convert( slices, 15 );
            rec.rebgov := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0809;


   procedure Create_Pension_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.penoth := Convert( slices, 7 );
            rec.penpay := Convert( slices, 8 );
            rec.penpd := Convert( slices, 9 );
            rec.pentax := Convert( slices, 10 );
            rec.pentype := Convert( slices, 11 );
            rec.poamt := Convert( slices, 12 );
            rec.poinc := Convert( slices, 13 );
            rec.posour := Convert( slices, 14 );
            rec.ptamt := Convert( slices, 15 );
            rec.ptinc := Convert( slices, 16 );
            rec.trights := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0809;


   procedure Create_RentCont_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0809;


   procedure Create_Renter_0809( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbmnth := Convert( slices, 28 );
            rec.hbweeks := Convert( slices, 29 );
            rec.hbyear := Convert( slices, 30 );
            rec.hbyears := Convert( slices, 31 );
            rec.issue := Convert( slices, 32 );
            rec.landlord := Convert( slices, 33 );
            rec.lowshort := Convert( slices, 34 );
            rec.niystart := Convert( slices, 35 );
            rec.othtype := Convert( slices, 36 );
            rec.rebate := Convert( slices, 37 );
            rec.rent := Convert( slices, 38 );
            rec.rentdk := Convert( slices, 39 );
            rec.rentdoc := Convert( slices, 40 );
            rec.rentfull := Convert( slices, 41 );
            rec.renthol := Convert( slices, 42 );
            rec.rentpd := Convert( slices, 43 );
            rec.resll := Convert( slices, 44 );
            rec.resll2 := Convert( slices, 45 );
            rec.serinc1 := Convert( slices, 46 );
            rec.serinc2 := Convert( slices, 47 );
            rec.serinc3 := Convert( slices, 48 );
            rec.serinc4 := Convert( slices, 49 );
            rec.serinc5 := Convert( slices, 50 );
            rec.tentype := Convert( slices, 51 );
            rec.weekhol := Convert( slices, 52 );
            rec.wsinc := Convert( slices, 53 );
            rec.wsincamt := Convert( slices, 54 );
            rec.ystartr := Convert( slices, 55 );
            rec.month := Convert( slices, 56 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0809;


   procedure Create_Account_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.invtax := Convert( slices, 7 );
            rec.issue := Convert( slices, 8 );
            rec.nsamt := Convert( slices, 9 );
            rec.month := Convert( slices, 10 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_0910;


   procedure Create_Admin_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.lngdf01 := Convert( slices, 6 );
            rec.lngdf02 := Convert( slices, 7 );
            rec.lngdf03 := Convert( slices, 8 );
            rec.lngdf04 := Convert( slices, 9 );
            rec.lngdf05 := Convert( slices, 10 );
            rec.lngdf06 := Convert( slices, 11 );
            rec.lngdf07 := Convert( slices, 12 );
            rec.lngdf08 := Convert( slices, 13 );
            rec.lngdf09 := Convert( slices, 14 );
            rec.lngdf10 := Convert( slices, 15 );
            rec.lngdf11 := Convert( slices, 16 );
            rec.ncr1 := Convert( slices, 17 );
            rec.ncr2 := Convert( slices, 18 );
            rec.ncr3 := Convert( slices, 19 );
            rec.ncr4 := Convert( slices, 20 );
            rec.ncr5 := Convert( slices, 21 );
            rec.ncr6 := Convert( slices, 22 );
            rec.ncr7 := Convert( slices, 23 );
            rec.nmtrans := Convert( slices, 24 );
            rec.noneng := Convert( slices, 25 );
            rec.refr01 := Convert( slices, 26 );
            rec.refr02 := Convert( slices, 27 );
            rec.refr03 := Convert( slices, 28 );
            rec.refr04 := Convert( slices, 29 );
            rec.refr05 := Convert( slices, 30 );
            rec.refr06 := Convert( slices, 31 );
            rec.refr07 := Convert( slices, 32 );
            rec.refr08 := Convert( slices, 33 );
            rec.refr09 := Convert( slices, 34 );
            rec.refr10 := Convert( slices, 35 );
            rec.refr11 := Convert( slices, 36 );
            rec.refr12 := Convert( slices, 37 );
            rec.refr13 := Convert( slices, 38 );
            rec.refr14 := Convert( slices, 39 );
            rec.refr15 := Convert( slices, 40 );
            rec.refr16 := Convert( slices, 41 );
            rec.refr17 := Convert( slices, 42 );
            rec.refr18 := Convert( slices, 43 );
            rec.tnc := Convert( slices, 44 );
            rec.version := Convert( slices, 45 );
            rec.whlang01 := Convert( slices, 46 );
            rec.whlang02 := Convert( slices, 47 );
            rec.whlang03 := Convert( slices, 48 );
            rec.whlang04 := Convert( slices, 49 );
            rec.whlang05 := Convert( slices, 50 );
            rec.whlang06 := Convert( slices, 51 );
            rec.whlang07 := Convert( slices, 52 );
            rec.whlang08 := Convert( slices, 53 );
            rec.whlang09 := Convert( slices, 54 );
            rec.whlang10 := Convert( slices, 55 );
            rec.whlang11 := Convert( slices, 56 );
            rec.whotran1 := Convert( slices, 57 );
            rec.whotran2 := Convert( slices, 58 );
            rec.whotran3 := Convert( slices, 59 );
            rec.whotran4 := Convert( slices, 60 );
            rec.whotran5 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_0910;


   procedure Create_Adult_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.alg := Convert( slices, 21 );
            rec.algamt := Convert( slices, 22 );
            rec.algpd := Convert( slices, 23 );
            rec.allow1 := Convert( slices, 24 );
            rec.allow2 := Convert( slices, 25 );
            rec.allow3 := Convert( slices, 26 );
            rec.allow4 := Convert( slices, 27 );
            rec.allpay1 := Convert( slices, 28 );
            rec.allpay2 := Convert( slices, 29 );
            rec.allpay3 := Convert( slices, 30 );
            rec.allpay4 := Convert( slices, 31 );
            rec.allpd1 := Convert( slices, 32 );
            rec.allpd2 := Convert( slices, 33 );
            rec.allpd3 := Convert( slices, 34 );
            rec.allpd4 := Convert( slices, 35 );
            rec.anyacc := Convert( slices, 36 );
            rec.anyed := Convert( slices, 37 );
            rec.anymon := Convert( slices, 38 );
            rec.anypen1 := Convert( slices, 39 );
            rec.anypen2 := Convert( slices, 40 );
            rec.anypen3 := Convert( slices, 41 );
            rec.anypen4 := Convert( slices, 42 );
            rec.anypen5 := Convert( slices, 43 );
            rec.anypen6 := Convert( slices, 44 );
            rec.anypen7 := Convert( slices, 45 );
            rec.apamt := Convert( slices, 46 );
            rec.apdamt := Convert( slices, 47 );
            rec.apdir := Convert( slices, 48 );
            rec.apdpd := Convert( slices, 49 );
            rec.appd := Convert( slices, 50 );
            rec.b2qfut1 := Convert( slices, 51 );
            rec.b2qfut2 := Convert( slices, 52 );
            rec.b2qfut3 := Convert( slices, 53 );
            rec.b3qfut1 := Convert( slices, 54 );
            rec.b3qfut2 := Convert( slices, 55 );
            rec.b3qfut3 := Convert( slices, 56 );
            rec.b3qfut4 := Convert( slices, 57 );
            rec.b3qfut5 := Convert( slices, 58 );
            rec.b3qfut6 := Convert( slices, 59 );
            rec.b3qfut7 := Convert( slices, 60 );
            rec.ben1q1 := Convert( slices, 61 );
            rec.ben1q2 := Convert( slices, 62 );
            rec.ben1q3 := Convert( slices, 63 );
            rec.ben1q4 := Convert( slices, 64 );
            rec.ben1q5 := Convert( slices, 65 );
            rec.ben1q6 := Convert( slices, 66 );
            rec.ben1q7 := Convert( slices, 67 );
            rec.ben2q1 := Convert( slices, 68 );
            rec.ben2q2 := Convert( slices, 69 );
            rec.ben2q3 := Convert( slices, 70 );
            rec.ben3q1 := Convert( slices, 71 );
            rec.ben3q2 := Convert( slices, 72 );
            rec.ben3q3 := Convert( slices, 73 );
            rec.ben3q4 := Convert( slices, 74 );
            rec.ben3q5 := Convert( slices, 75 );
            rec.ben3q6 := Convert( slices, 76 );
            rec.ben3q7 := Convert( slices, 77 );
            rec.ben4q1 := Convert( slices, 78 );
            rec.ben4q2 := Convert( slices, 79 );
            rec.ben4q3 := Convert( slices, 80 );
            rec.ben4q4 := Convert( slices, 81 );
            rec.ben5q1 := Convert( slices, 82 );
            rec.ben5q2 := Convert( slices, 83 );
            rec.ben5q3 := Convert( slices, 84 );
            rec.ben5q4 := Convert( slices, 85 );
            rec.ben5q5 := Convert( slices, 86 );
            rec.ben5q6 := Convert( slices, 87 );
            rec.ben5q7 := Convert( slices, 88 );
            rec.ben5q8 := Convert( slices, 89 );
            rec.ben5q9 := Convert( slices, 90 );
            rec.ben7q1 := Convert( slices, 91 );
            rec.ben7q2 := Convert( slices, 92 );
            rec.ben7q3 := Convert( slices, 93 );
            rec.ben7q4 := Convert( slices, 94 );
            rec.ben7q5 := Convert( slices, 95 );
            rec.ben7q6 := Convert( slices, 96 );
            rec.ben7q7 := Convert( slices, 97 );
            rec.ben7q8 := Convert( slices, 98 );
            rec.ben7q9 := Convert( slices, 99 );
            rec.camemt := Convert( slices, 100 );
            rec.cameyr := Convert( slices, 101 );
            rec.cameyr2 := Convert( slices, 102 );
            rec.chkctc := Convert( slices, 103 );
            rec.chkdpco1 := Convert( slices, 104 );
            rec.chkdpco2 := Convert( slices, 105 );
            rec.chkdpco3 := Convert( slices, 106 );
            rec.chkdpn := Convert( slices, 107 );
            rec.chkdsco1 := Convert( slices, 108 );
            rec.chkdsco2 := Convert( slices, 109 );
            rec.chkdsco3 := Convert( slices, 110 );
            rec.chknop := Convert( slices, 111 );
            rec.claimant := Convert( slices, 112 );
            rec.cohabit := Convert( slices, 113 );
            rec.combid := Convert( slices, 114 );
            rec.contuk := Convert( slices, 115 );
            rec.convbl := Convert( slices, 116 );
            rec.corign := Convert( slices, 117 );
            rec.ctclum1 := Convert( slices, 118 );
            rec.ctclum2 := Convert( slices, 119 );
            rec.cupchk := Convert( slices, 120 );
            rec.cvht := Convert( slices, 121 );
            rec.cvpay := Convert( slices, 122 );
            rec.cvpd := Convert( slices, 123 );
            rec.ddaprog := Convert( slices, 124 );
            rec.ddatre := Convert( slices, 125 );
            rec.ddatrep := Convert( slices, 126 );
            rec.defrpen := Convert( slices, 127 );
            rec.depend := Convert( slices, 128 );
            rec.disdif1 := Convert( slices, 129 );
            rec.disdif2 := Convert( slices, 130 );
            rec.disdif3 := Convert( slices, 131 );
            rec.disdif4 := Convert( slices, 132 );
            rec.disdif5 := Convert( slices, 133 );
            rec.disdif6 := Convert( slices, 134 );
            rec.disdif7 := Convert( slices, 135 );
            rec.disdif8 := Convert( slices, 136 );
            rec.disdif9 := Convert( slices, 137 );
            rec.disdifp := Convert( slices, 138 );
            rec.dob := Convert( slices, 139 );
            rec.dv09pens := Convert( slices, 140 );
            rec.dvil03a := Convert( slices, 141 );
            rec.dvil04a := Convert( slices, 142 );
            rec.dvjb12ml := Convert( slices, 143 );
            rec.dvmardf := Convert( slices, 144 );
            rec.ed1amt := Convert( slices, 145 );
            rec.ed1borr := Convert( slices, 146 );
            rec.ed1int := Convert( slices, 147 );
            rec.ed1monyr := Convert( slices, 148 );
            rec.ed1pd := Convert( slices, 149 );
            rec.ed1sum := Convert( slices, 150 );
            rec.ed2amt := Convert( slices, 151 );
            rec.ed2borr := Convert( slices, 152 );
            rec.ed2int := Convert( slices, 153 );
            rec.ed2monyr := Convert( slices, 154 );
            rec.ed2pd := Convert( slices, 155 );
            rec.ed2sum := Convert( slices, 156 );
            rec.edatt := Convert( slices, 157 );
            rec.edhr := Convert( slices, 158 );
            rec.edtime := Convert( slices, 159 );
            rec.edtyp := Convert( slices, 160 );
            rec.eligadlt := Convert( slices, 161 );
            rec.eligchld := Convert( slices, 162 );
            rec.eligschm := Convert( slices, 163 );
            rec.emparr := Convert( slices, 164 );
            rec.emppen := Convert( slices, 165 );
            rec.empschm := Convert( slices, 166 );
            rec.empstat := Convert( slices, 167 );
            rec.endyr := Convert( slices, 168 );
            rec.es2000 := Convert( slices, 169 );
            rec.ethgrp := Convert( slices, 170 );
            rec.everwrk := Convert( slices, 171 );
            rec.exthbct1 := Convert( slices, 172 );
            rec.exthbct2 := Convert( slices, 173 );
            rec.exthbct3 := Convert( slices, 174 );
            rec.followup := Convert( slices, 175 );
            rec.fted := Convert( slices, 176 );
            rec.ftwk := Convert( slices, 177 );
            rec.govpis := Convert( slices, 178 );
            rec.govpjsa := Convert( slices, 179 );
            rec.grant := Convert( slices, 180 );
            rec.grtamt1 := Convert( slices, 181 );
            rec.grtamt2 := Convert( slices, 182 );
            rec.grtdir1 := Convert( slices, 183 );
            rec.grtdir2 := Convert( slices, 184 );
            rec.grtnum := Convert( slices, 185 );
            rec.grtsce1 := Convert( slices, 186 );
            rec.grtsce2 := Convert( slices, 187 );
            rec.grtval1 := Convert( slices, 188 );
            rec.grtval2 := Convert( slices, 189 );
            rec.gta := Convert( slices, 190 );
            rec.health := Convert( slices, 191 );
            rec.hholder := Convert( slices, 192 );
            rec.hi1qual1 := Convert( slices, 193 );
            rec.hi1qual2 := Convert( slices, 194 );
            rec.hi1qual3 := Convert( slices, 195 );
            rec.hi1qual4 := Convert( slices, 196 );
            rec.hi1qual5 := Convert( slices, 197 );
            rec.hi1qual6 := Convert( slices, 198 );
            rec.hi2qual := Convert( slices, 199 );
            rec.hprob := Convert( slices, 200 );
            rec.hrpid := Convert( slices, 201 );
            rec.incdur := Convert( slices, 202 );
            rec.injlong := Convert( slices, 203 );
            rec.injwk := Convert( slices, 204 );
            rec.invests := Convert( slices, 205 );
            rec.iout := Convert( slices, 206 );
            rec.isa1type := Convert( slices, 207 );
            rec.isa2type := Convert( slices, 208 );
            rec.issue := Convert( slices, 209 );
            rec.jobaway := Convert( slices, 210 );
            rec.lareg := Convert( slices, 211 );
            rec.likewk := Convert( slices, 212 );
            rec.lktime := Convert( slices, 213 );
            rec.ln1rpint := Convert( slices, 214 );
            rec.ln2rpint := Convert( slices, 215 );
            rec.lnkdwp := Convert( slices, 216 );
            rec.lnkref01 := Convert( slices, 217 );
            rec.lnkref02 := Convert( slices, 218 );
            rec.lnkref03 := Convert( slices, 219 );
            rec.lnkref04 := Convert( slices, 220 );
            rec.lnkref05 := Convert( slices, 221 );
            rec.lnkref06 := Convert( slices, 222 );
            rec.lnkref07 := Convert( slices, 223 );
            rec.lnkref08 := Convert( slices, 224 );
            rec.lnkref09 := Convert( slices, 225 );
            rec.lnkref10 := Convert( slices, 226 );
            rec.lnkref11 := Convert( slices, 227 );
            rec.loan := Convert( slices, 228 );
            rec.loannum := Convert( slices, 229 );
            rec.look := Convert( slices, 230 );
            rec.lookwk := Convert( slices, 231 );
            rec.lstwrk1 := Convert( slices, 232 );
            rec.lstwrk2 := Convert( slices, 233 );
            rec.lstyr := Convert( slices, 234 );
            rec.memschm := Convert( slices, 235 );
            rec.mntamt1 := Convert( slices, 236 );
            rec.mntamt2 := Convert( slices, 237 );
            rec.mntarr1 := Convert( slices, 238 );
            rec.mntarr2 := Convert( slices, 239 );
            rec.mntarr3 := Convert( slices, 240 );
            rec.mntarr4 := Convert( slices, 241 );
            rec.mntgov1 := Convert( slices, 242 );
            rec.mntgov2 := Convert( slices, 243 );
            rec.mntnrp := Convert( slices, 244 );
            rec.mntpay := Convert( slices, 245 );
            rec.mntpd1 := Convert( slices, 246 );
            rec.mntpd2 := Convert( slices, 247 );
            rec.mntrec := Convert( slices, 248 );
            rec.mntus1 := Convert( slices, 249 );
            rec.mntus2 := Convert( slices, 250 );
            rec.mntusam1 := Convert( slices, 251 );
            rec.mntusam2 := Convert( slices, 252 );
            rec.mntuspd1 := Convert( slices, 253 );
            rec.mntuspd2 := Convert( slices, 254 );
            rec.ms := Convert( slices, 255 );
            rec.natid1 := Convert( slices, 256 );
            rec.natid2 := Convert( slices, 257 );
            rec.natid3 := Convert( slices, 258 );
            rec.natid4 := Convert( slices, 259 );
            rec.natid5 := Convert( slices, 260 );
            rec.natid6 := Convert( slices, 261 );
            rec.ndeal := Convert( slices, 262 );
            rec.newdtype := Convert( slices, 263 );
            rec.niamt := Convert( slices, 264 );
            rec.niethgrp := Convert( slices, 265 );
            rec.niexthbb := Convert( slices, 266 );
            rec.ninatid1 := Convert( slices, 267 );
            rec.ninatid2 := Convert( slices, 268 );
            rec.ninatid3 := Convert( slices, 269 );
            rec.ninatid4 := Convert( slices, 270 );
            rec.ninatid5 := Convert( slices, 271 );
            rec.ninatid6 := Convert( slices, 272 );
            rec.ninatid7 := Convert( slices, 273 );
            rec.ninatid8 := Convert( slices, 274 );
            rec.nipd := Convert( slices, 275 );
            rec.nireg := Convert( slices, 276 );
            rec.nirel := Convert( slices, 277 );
            rec.nitrain := Convert( slices, 278 );
            rec.nlper := Convert( slices, 279 );
            rec.nolk1 := Convert( slices, 280 );
            rec.nolk2 := Convert( slices, 281 );
            rec.nolk3 := Convert( slices, 282 );
            rec.nolook := Convert( slices, 283 );
            rec.nowant := Convert( slices, 284 );
            rec.nssec := Convert( slices, 285 );
            rec.ntcdat := Convert( slices, 286 );
            rec.ntcinc := Convert( slices, 287 );
            rec.numjob := Convert( slices, 288 );
            rec.numjob2 := Convert( slices, 289 );
            rec.oddjob := Convert( slices, 290 );
            rec.oldstud := Convert( slices, 291 );
            rec.otabspar := Convert( slices, 292 );
            rec.otamt := Convert( slices, 293 );
            rec.otapamt := Convert( slices, 294 );
            rec.otappd := Convert( slices, 295 );
            rec.othqual1 := Convert( slices, 296 );
            rec.othqual2 := Convert( slices, 297 );
            rec.othqual3 := Convert( slices, 298 );
            rec.othtax := Convert( slices, 299 );
            rec.otinva := Convert( slices, 300 );
            rec.pareamt := Convert( slices, 301 );
            rec.parepd := Convert( slices, 302 );
            rec.penlump := Convert( slices, 303 );
            rec.perspen1 := Convert( slices, 304 );
            rec.perspen2 := Convert( slices, 305 );
            rec.ppnumc := Convert( slices, 306 );
            rec.practice := Convert( slices, 307 );
            rec.privpen := Convert( slices, 308 );
            rec.ptwk := Convert( slices, 309 );
            rec.r01 := Convert( slices, 310 );
            rec.r02 := Convert( slices, 311 );
            rec.r03 := Convert( slices, 312 );
            rec.r04 := Convert( slices, 313 );
            rec.r05 := Convert( slices, 314 );
            rec.r06 := Convert( slices, 315 );
            rec.r07 := Convert( slices, 316 );
            rec.r08 := Convert( slices, 317 );
            rec.r09 := Convert( slices, 318 );
            rec.r10 := Convert( slices, 319 );
            rec.r11 := Convert( slices, 320 );
            rec.r12 := Convert( slices, 321 );
            rec.r13 := Convert( slices, 322 );
            rec.r14 := Convert( slices, 323 );
            rec.redamt := Convert( slices, 324 );
            rec.redany := Convert( slices, 325 );
            rec.rentprof := Convert( slices, 326 );
            rec.retire := Convert( slices, 327 );
            rec.retire1 := Convert( slices, 328 );
            rec.retreas := Convert( slices, 329 );
            rec.royal1 := Convert( slices, 330 );
            rec.royal2 := Convert( slices, 331 );
            rec.royal3 := Convert( slices, 332 );
            rec.royal4 := Convert( slices, 333 );
            rec.royyr1 := Convert( slices, 334 );
            rec.royyr2 := Convert( slices, 335 );
            rec.royyr3 := Convert( slices, 336 );
            rec.royyr4 := Convert( slices, 337 );
            rec.rstrct := Convert( slices, 338 );
            rec.schchk := Convert( slices, 339 );
            rec.sex := Convert( slices, 340 );
            rec.sflntyp1 := Convert( slices, 341 );
            rec.sflntyp2 := Convert( slices, 342 );
            rec.sfrpis := Convert( slices, 343 );
            rec.sfrpjsa := Convert( slices, 344 );
            rec.sftype1 := Convert( slices, 345 );
            rec.sftype2 := Convert( slices, 346 );
            rec.sic := Convert( slices, 347 );
            rec.slrepamt := Convert( slices, 348 );
            rec.slrepay := Convert( slices, 349 );
            rec.slreppd := Convert( slices, 350 );
            rec.soc2000 := Convert( slices, 351 );
            rec.spcreg1 := Convert( slices, 352 );
            rec.spcreg2 := Convert( slices, 353 );
            rec.spcreg3 := Convert( slices, 354 );
            rec.spnumc := Convert( slices, 355 );
            rec.spout := Convert( slices, 356 );
            rec.spyrot := Convert( slices, 357 );
            rec.srentamt := Convert( slices, 358 );
            rec.srentpd := Convert( slices, 359 );
            rec.stakep := Convert( slices, 360 );
            rec.start := Convert( slices, 361 );
            rec.startyr := Convert( slices, 362 );
            rec.taxcred1 := Convert( slices, 363 );
            rec.taxcred2 := Convert( slices, 364 );
            rec.taxfut := Convert( slices, 365 );
            rec.tcever1 := Convert( slices, 366 );
            rec.tcever2 := Convert( slices, 367 );
            rec.tcrepay1 := Convert( slices, 368 );
            rec.tcrepay2 := Convert( slices, 369 );
            rec.tcrepay3 := Convert( slices, 370 );
            rec.tcrepay4 := Convert( slices, 371 );
            rec.tcrepay5 := Convert( slices, 372 );
            rec.tcrepay6 := Convert( slices, 373 );
            rec.tcthsyr1 := Convert( slices, 374 );
            rec.tcthsyr2 := Convert( slices, 375 );
            rec.tdaywrk := Convert( slices, 376 );
            rec.tea := Convert( slices, 377 );
            rec.tea9697 := Convert( slices, 378 );
            rec.topupl := Convert( slices, 379 );
            rec.totint := Convert( slices, 380 );
            rec.train := Convert( slices, 381 );
            rec.trainee := Convert( slices, 382 );
            rec.tuborr := Convert( slices, 383 );
            rec.typeed := Convert( slices, 384 );
            rec.unpaid1 := Convert( slices, 385 );
            rec.unpaid2 := Convert( slices, 386 );
            rec.w1 := Convert( slices, 387 );
            rec.w2 := Convert( slices, 388 );
            rec.wait := Convert( slices, 389 );
            rec.war1 := Convert( slices, 390 );
            rec.war2 := Convert( slices, 391 );
            rec.whoresp := Convert( slices, 392 );
            rec.whosectb := Convert( slices, 393 );
            rec.wintfuel := Convert( slices, 394 );
            rec.wmkit := Convert( slices, 395 );
            rec.working := Convert( slices, 396 );
            rec.wpa := Convert( slices, 397 );
            rec.wpba := Convert( slices, 398 );
            rec.wtclum1 := Convert( slices, 399 );
            rec.wtclum2 := Convert( slices, 400 );
            rec.ystrtwk := Convert( slices, 401 );
            rec.month := Convert( slices, 402 );
            rec.able := Convert( slices, 403 );
            rec.actacci := Convert( slices, 404 );
            rec.addda := Convert( slices, 405 );
            rec.age80 := Convert( slices, 406 );
            rec.basacti := Convert( slices, 407 );
            rec.careab := Convert( slices, 408 );
            rec.careah := Convert( slices, 409 );
            rec.carecb := Convert( slices, 410 );
            rec.carech := Convert( slices, 411 );
            rec.carecl := Convert( slices, 412 );
            rec.carefl := Convert( slices, 413 );
            rec.carefr := Convert( slices, 414 );
            rec.careot := Convert( slices, 415 );
            rec.carere := Convert( slices, 416 );
            rec.chbflg := Convert( slices, 417 );
            rec.curacti := Convert( slices, 418 );
            rec.currjobm := Convert( slices, 419 );
            rec.disdifad := Convert( slices, 420 );
            rec.empoccp := Convert( slices, 421 );
            rec.empstatb := Convert( slices, 422 );
            rec.empstatc := Convert( slices, 423 );
            rec.empstati := Convert( slices, 424 );
            rec.ethgr2 := Convert( slices, 425 );
            rec.gebacti := Convert( slices, 426 );
            rec.giltcti := Convert( slices, 427 );
            rec.gross3 := Convert( slices, 428 );
            rec.gross3_x := Convert( slices, 429 );
            rec.hdage := Convert( slices, 430 );
            rec.hdben := Convert( slices, 431 );
            rec.hdindinc := Convert( slices, 432 );
            rec.heartval := Convert( slices, 433 );
            rec.hourab := Convert( slices, 434 );
            rec.hourah := Convert( slices, 435 );
            rec.hourcare := Convert( slices, 436 );
            rec.hourcb := Convert( slices, 437 );
            rec.hourch := Convert( slices, 438 );
            rec.hourcl := Convert( slices, 439 );
            rec.hourfr := Convert( slices, 440 );
            rec.hourot := Convert( slices, 441 );
            rec.hourre := Convert( slices, 442 );
            rec.hourtot := Convert( slices, 443 );
            rec.hperson := Convert( slices, 444 );
            rec.iagegr2 := Convert( slices, 445 );
            rec.iagegr3 := Convert( slices, 446 );
            rec.iagegr4 := Convert( slices, 447 );
            rec.iagegrp := Convert( slices, 448 );
            rec.incseo2 := Convert( slices, 449 );
            rec.indinc := Convert( slices, 450 );
            rec.indisben := Convert( slices, 451 );
            rec.inearns := Convert( slices, 452 );
            rec.ininv := Convert( slices, 453 );
            rec.inirben := Convert( slices, 454 );
            rec.innirben := Convert( slices, 455 );
            rec.inothben := Convert( slices, 456 );
            rec.inpeninc := Convert( slices, 457 );
            rec.inrinc := Convert( slices, 458 );
            rec.inrpinc := Convert( slices, 459 );
            rec.intvlic := Convert( slices, 460 );
            rec.intxcred := Convert( slices, 461 );
            rec.isacti := Convert( slices, 462 );
            rec.marital := Convert( slices, 463 );
            rec.nincseo2 := Convert( slices, 464 );
            rec.nindinc := Convert( slices, 465 );
            rec.ninearns := Convert( slices, 466 );
            rec.nininv := Convert( slices, 467 );
            rec.ninpenin := Convert( slices, 468 );
            rec.ninsein2 := Convert( slices, 469 );
            rec.nirel2 := Convert( slices, 470 );
            rec.occupnum := Convert( slices, 471 );
            rec.pepscti := Convert( slices, 472 );
            rec.poaccti := Convert( slices, 473 );
            rec.pocardi := Convert( slices, 474 );
            rec.prevjobm := Convert( slices, 475 );
            rec.relhrp := Convert( slices, 476 );
            rec.sapadj := Convert( slices, 477 );
            rec.seincam2 := Convert( slices, 478 );
            rec.smpadj := Convert( slices, 479 );
            rec.sppadj := Convert( slices, 480 );
            rec.sspadj := Convert( slices, 481 );
            rec.stshcti := Convert( slices, 482 );
            rec.taxpayer := Convert( slices, 483 );
            rec.tesscti := Convert( slices, 484 );
            rec.totgrant := Convert( slices, 485 );
            rec.tothours := Convert( slices, 486 );
            rec.totoccp := Convert( slices, 487 );
            rec.untrcti := Convert( slices, 488 );
            rec.uperson := Convert( slices, 489 );
            rec.widoccp := Convert( slices, 490 );
            rec.xbonflag := Convert( slices, 491 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_0910;


   procedure Create_Asset_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issdate := Convert( slices, 13 );
            rec.issue := Convert( slices, 14 );
            rec.issval := Convert( slices, 15 );
            rec.pd := Convert( slices, 16 );
            rec.month := Convert( slices, 17 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_0910;


   procedure Create_Benefit_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.cctc := Convert( slices, 10 );
            rec.combamt := Convert( slices, 11 );
            rec.combpd := Convert( slices, 12 );
            rec.howben := Convert( slices, 13 );
            rec.issue := Convert( slices, 14 );
            rec.notusamt := Convert( slices, 15 );
            rec.notuspd := Convert( slices, 16 );
            rec.numweeks := Convert( slices, 17 );
            rec.numyears := Convert( slices, 18 );
            rec.pres := Convert( slices, 19 );
            rec.ttbprx := Convert( slices, 20 );
            rec.usual := Convert( slices, 21 );
            rec.var1 := Convert( slices, 22 );
            rec.var2 := Convert( slices, 23 );
            rec.var3 := Convert( slices, 24 );
            rec.whorec1 := Convert( slices, 25 );
            rec.whorec2 := Convert( slices, 26 );
            rec.whorec3 := Convert( slices, 27 );
            rec.whorec4 := Convert( slices, 28 );
            rec.whorec5 := Convert( slices, 29 );
            rec.month := Convert( slices, 30 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_0910;


   procedure Create_Benunit_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adddec := Convert( slices, 3 );
            rec.addeples := Convert( slices, 4 );
            rec.addhol := Convert( slices, 5 );
            rec.addins := Convert( slices, 6 );
            rec.addmel := Convert( slices, 7 );
            rec.addmon := Convert( slices, 8 );
            rec.addshoe := Convert( slices, 9 );
            rec.adepfur := Convert( slices, 10 );
            rec.af1 := Convert( slices, 11 );
            rec.afdep2 := Convert( slices, 12 );
            rec.billnt1 := Convert( slices, 13 );
            rec.billnt2 := Convert( slices, 14 );
            rec.billnt3 := Convert( slices, 15 );
            rec.billnt4 := Convert( slices, 16 );
            rec.billnt5 := Convert( slices, 17 );
            rec.billnt6 := Convert( slices, 18 );
            rec.billnt7 := Convert( slices, 19 );
            rec.billnt8 := Convert( slices, 20 );
            rec.billnt9 := Convert( slices, 21 );
            rec.cbaamt1 := Convert( slices, 22 );
            rec.cbaamt2 := Convert( slices, 23 );
            rec.cdelply := Convert( slices, 24 );
            rec.cdepbed := Convert( slices, 25 );
            rec.cdepcel := Convert( slices, 26 );
            rec.cdepeqp := Convert( slices, 27 );
            rec.cdephol := Convert( slices, 28 );
            rec.cdeples := Convert( slices, 29 );
            rec.cdepsum := Convert( slices, 30 );
            rec.cdeptea := Convert( slices, 31 );
            rec.cdeptrp := Convert( slices, 32 );
            rec.coatnt1 := Convert( slices, 33 );
            rec.coatnt2 := Convert( slices, 34 );
            rec.coatnt3 := Convert( slices, 35 );
            rec.coatnt4 := Convert( slices, 36 );
            rec.coatnt5 := Convert( slices, 37 );
            rec.coatnt6 := Convert( slices, 38 );
            rec.coatnt7 := Convert( slices, 39 );
            rec.coatnt8 := Convert( slices, 40 );
            rec.coatnt9 := Convert( slices, 41 );
            rec.cooknt1 := Convert( slices, 42 );
            rec.cooknt2 := Convert( slices, 43 );
            rec.cooknt3 := Convert( slices, 44 );
            rec.cooknt4 := Convert( slices, 45 );
            rec.cooknt5 := Convert( slices, 46 );
            rec.cooknt6 := Convert( slices, 47 );
            rec.cooknt7 := Convert( slices, 48 );
            rec.cooknt8 := Convert( slices, 49 );
            rec.cooknt9 := Convert( slices, 50 );
            rec.cplay := Convert( slices, 51 );
            rec.dampnt1 := Convert( slices, 52 );
            rec.dampnt2 := Convert( slices, 53 );
            rec.dampnt3 := Convert( slices, 54 );
            rec.dampnt4 := Convert( slices, 55 );
            rec.dampnt5 := Convert( slices, 56 );
            rec.dampnt6 := Convert( slices, 57 );
            rec.dampnt7 := Convert( slices, 58 );
            rec.dampnt8 := Convert( slices, 59 );
            rec.dampnt9 := Convert( slices, 60 );
            rec.debt1 := Convert( slices, 61 );
            rec.debt2 := Convert( slices, 62 );
            rec.debt3 := Convert( slices, 63 );
            rec.debt4 := Convert( slices, 64 );
            rec.debt5 := Convert( slices, 65 );
            rec.debt6 := Convert( slices, 66 );
            rec.debt7 := Convert( slices, 67 );
            rec.debt8 := Convert( slices, 68 );
            rec.debt9 := Convert( slices, 69 );
            rec.frndnt1 := Convert( slices, 70 );
            rec.frndnt2 := Convert( slices, 71 );
            rec.frndnt3 := Convert( slices, 72 );
            rec.frndnt4 := Convert( slices, 73 );
            rec.frndnt5 := Convert( slices, 74 );
            rec.frndnt6 := Convert( slices, 75 );
            rec.frndnt7 := Convert( slices, 76 );
            rec.frndnt8 := Convert( slices, 77 );
            rec.frndnt9 := Convert( slices, 78 );
            rec.hairnt1 := Convert( slices, 79 );
            rec.hairnt2 := Convert( slices, 80 );
            rec.hairnt3 := Convert( slices, 81 );
            rec.hairnt4 := Convert( slices, 82 );
            rec.hairnt5 := Convert( slices, 83 );
            rec.hairnt6 := Convert( slices, 84 );
            rec.hairnt7 := Convert( slices, 85 );
            rec.hairnt8 := Convert( slices, 86 );
            rec.hairnt9 := Convert( slices, 87 );
            rec.hbolng := Convert( slices, 88 );
            rec.hbothamt := Convert( slices, 89 );
            rec.hbothbu := Convert( slices, 90 );
            rec.hbothmn := Convert( slices, 91 );
            rec.hbothpd := Convert( slices, 92 );
            rec.hbothwk := Convert( slices, 93 );
            rec.hbothyr := Convert( slices, 94 );
            rec.hbotwait := Convert( slices, 95 );
            rec.heatnt1 := Convert( slices, 96 );
            rec.heatnt2 := Convert( slices, 97 );
            rec.heatnt3 := Convert( slices, 98 );
            rec.heatnt4 := Convert( slices, 99 );
            rec.heatnt5 := Convert( slices, 100 );
            rec.heatnt6 := Convert( slices, 101 );
            rec.heatnt7 := Convert( slices, 102 );
            rec.heatnt8 := Convert( slices, 103 );
            rec.heatnt9 := Convert( slices, 104 );
            rec.helpgv01 := Convert( slices, 105 );
            rec.helpgv02 := Convert( slices, 106 );
            rec.helpgv03 := Convert( slices, 107 );
            rec.helpgv04 := Convert( slices, 108 );
            rec.helpgv05 := Convert( slices, 109 );
            rec.helpgv06 := Convert( slices, 110 );
            rec.helpgv07 := Convert( slices, 111 );
            rec.helpgv08 := Convert( slices, 112 );
            rec.helpgv09 := Convert( slices, 113 );
            rec.helpgv10 := Convert( slices, 114 );
            rec.helpgv11 := Convert( slices, 115 );
            rec.helprc01 := Convert( slices, 116 );
            rec.helprc02 := Convert( slices, 117 );
            rec.helprc03 := Convert( slices, 118 );
            rec.helprc04 := Convert( slices, 119 );
            rec.helprc05 := Convert( slices, 120 );
            rec.helprc06 := Convert( slices, 121 );
            rec.helprc07 := Convert( slices, 122 );
            rec.helprc08 := Convert( slices, 123 );
            rec.helprc09 := Convert( slices, 124 );
            rec.helprc10 := Convert( slices, 125 );
            rec.helprc11 := Convert( slices, 126 );
            rec.holnt1 := Convert( slices, 127 );
            rec.holnt2 := Convert( slices, 128 );
            rec.holnt3 := Convert( slices, 129 );
            rec.holnt4 := Convert( slices, 130 );
            rec.holnt5 := Convert( slices, 131 );
            rec.holnt6 := Convert( slices, 132 );
            rec.holnt7 := Convert( slices, 133 );
            rec.holnt8 := Convert( slices, 134 );
            rec.holnt9 := Convert( slices, 135 );
            rec.homent1 := Convert( slices, 136 );
            rec.homent2 := Convert( slices, 137 );
            rec.homent3 := Convert( slices, 138 );
            rec.homent4 := Convert( slices, 139 );
            rec.homent5 := Convert( slices, 140 );
            rec.homent6 := Convert( slices, 141 );
            rec.homent7 := Convert( slices, 142 );
            rec.homent8 := Convert( slices, 143 );
            rec.homent9 := Convert( slices, 144 );
            rec.houshe1 := Convert( slices, 145 );
            rec.incchnge := Convert( slices, 146 );
            rec.inchilow := Convert( slices, 147 );
            rec.incold := Convert( slices, 148 );
            rec.issue := Convert( slices, 149 );
            rec.kidinc := Convert( slices, 150 );
            rec.loangvn1 := Convert( slices, 151 );
            rec.loangvn2 := Convert( slices, 152 );
            rec.loangvn3 := Convert( slices, 153 );
            rec.loanrec1 := Convert( slices, 154 );
            rec.loanrec2 := Convert( slices, 155 );
            rec.loanrec3 := Convert( slices, 156 );
            rec.mealnt1 := Convert( slices, 157 );
            rec.mealnt2 := Convert( slices, 158 );
            rec.mealnt3 := Convert( slices, 159 );
            rec.mealnt4 := Convert( slices, 160 );
            rec.mealnt5 := Convert( slices, 161 );
            rec.mealnt6 := Convert( slices, 162 );
            rec.mealnt7 := Convert( slices, 163 );
            rec.mealnt8 := Convert( slices, 164 );
            rec.mealnt9 := Convert( slices, 165 );
            rec.nhhchild := Convert( slices, 166 );
            rec.oabill := Convert( slices, 167 );
            rec.oacoat := Convert( slices, 168 );
            rec.oacook := Convert( slices, 169 );
            rec.oadamp := Convert( slices, 170 );
            rec.oaexpns := Convert( slices, 171 );
            rec.oafrnd := Convert( slices, 172 );
            rec.oahair := Convert( slices, 173 );
            rec.oaheat := Convert( slices, 174 );
            rec.oahol := Convert( slices, 175 );
            rec.oahome := Convert( slices, 176 );
            rec.oahowpy1 := Convert( slices, 177 );
            rec.oahowpy2 := Convert( slices, 178 );
            rec.oahowpy3 := Convert( slices, 179 );
            rec.oahowpy4 := Convert( slices, 180 );
            rec.oahowpy5 := Convert( slices, 181 );
            rec.oahowpy6 := Convert( slices, 182 );
            rec.oameal := Convert( slices, 183 );
            rec.oaout := Convert( slices, 184 );
            rec.oaphon := Convert( slices, 185 );
            rec.oataxi := Convert( slices, 186 );
            rec.oawarm := Convert( slices, 187 );
            rec.outnt1 := Convert( slices, 188 );
            rec.outnt2 := Convert( slices, 189 );
            rec.outnt3 := Convert( slices, 190 );
            rec.outnt4 := Convert( slices, 191 );
            rec.outnt5 := Convert( slices, 192 );
            rec.outnt6 := Convert( slices, 193 );
            rec.outnt7 := Convert( slices, 194 );
            rec.outnt8 := Convert( slices, 195 );
            rec.outnt9 := Convert( slices, 196 );
            rec.phonnt1 := Convert( slices, 197 );
            rec.phonnt2 := Convert( slices, 198 );
            rec.phonnt3 := Convert( slices, 199 );
            rec.phonnt4 := Convert( slices, 200 );
            rec.phonnt5 := Convert( slices, 201 );
            rec.phonnt6 := Convert( slices, 202 );
            rec.phonnt7 := Convert( slices, 203 );
            rec.phonnt8 := Convert( slices, 204 );
            rec.phonnt9 := Convert( slices, 205 );
            rec.taxint1 := Convert( slices, 206 );
            rec.taxint2 := Convert( slices, 207 );
            rec.taxint3 := Convert( slices, 208 );
            rec.taxint4 := Convert( slices, 209 );
            rec.taxint5 := Convert( slices, 210 );
            rec.taxint6 := Convert( slices, 211 );
            rec.taxint7 := Convert( slices, 212 );
            rec.taxint8 := Convert( slices, 213 );
            rec.taxint9 := Convert( slices, 214 );
            rec.totsav := Convert( slices, 215 );
            rec.warmnt1 := Convert( slices, 216 );
            rec.warmnt2 := Convert( slices, 217 );
            rec.warmnt3 := Convert( slices, 218 );
            rec.warmnt4 := Convert( slices, 219 );
            rec.warmnt5 := Convert( slices, 220 );
            rec.warmnt6 := Convert( slices, 221 );
            rec.warmnt7 := Convert( slices, 222 );
            rec.warmnt8 := Convert( slices, 223 );
            rec.warmnt9 := Convert( slices, 224 );
            rec.month := Convert( slices, 225 );
            rec.adddabu := Convert( slices, 226 );
            rec.adultb := Convert( slices, 227 );
            rec.boarder := Convert( slices, 228 );
            rec.bpeninc := Convert( slices, 229 );
            rec.bseinc := Convert( slices, 230 );
            rec.buagegr2 := Convert( slices, 231 );
            rec.buagegr3 := Convert( slices, 232 );
            rec.buagegr4 := Convert( slices, 233 );
            rec.buagegrp := Convert( slices, 234 );
            rec.budisben := Convert( slices, 235 );
            rec.buearns := Convert( slices, 236 );
            rec.buethgr2 := Convert( slices, 237 );
            rec.buinc := Convert( slices, 238 );
            rec.buinv := Convert( slices, 239 );
            rec.buirben := Convert( slices, 240 );
            rec.bukids := Convert( slices, 241 );
            rec.bunirben := Convert( slices, 242 );
            rec.buothben := Convert( slices, 243 );
            rec.burent := Convert( slices, 244 );
            rec.burinc := Convert( slices, 245 );
            rec.burpinc := Convert( slices, 246 );
            rec.butvlic := Convert( slices, 247 );
            rec.butxcred := Convert( slices, 248 );
            rec.chddabu := Convert( slices, 249 );
            rec.depchldb := Convert( slices, 250 );
            rec.disindhb := Convert( slices, 251 );
            rec.ecostabu := Convert( slices, 252 );
            rec.ecstatbu := Convert( slices, 253 );
            rec.famtypb2 := Convert( slices, 254 );
            rec.famtypbs := Convert( slices, 255 );
            rec.famtypbu := Convert( slices, 256 );
            rec.fsmbu := Convert( slices, 257 );
            rec.fsmlkbu := Convert( slices, 258 );
            rec.gross3 := Convert( slices, 259 );
            rec.gross3_x := Convert( slices, 260 );
            rec.hbindbu := Convert( slices, 261 );
            rec.hbindbu2 := Convert( slices, 262 );
            rec.heartbu := Convert( slices, 263 );
            rec.kid04 := Convert( slices, 264 );
            rec.kid1115 := Convert( slices, 265 );
            rec.kid1619 := Convert( slices, 266 );
            rec.kid510 := Convert( slices, 267 );
            rec.lodger := Convert( slices, 268 );
            rec.newfamb2 := Convert( slices, 269 );
            rec.newfambu := Convert( slices, 270 );
            rec.oabilimp := Convert( slices, 271 );
            rec.oacoaimp := Convert( slices, 272 );
            rec.oacooimp := Convert( slices, 273 );
            rec.oadamimp := Convert( slices, 274 );
            rec.oaexpimp := Convert( slices, 275 );
            rec.oafrnimp := Convert( slices, 276 );
            rec.oahaiimp := Convert( slices, 277 );
            rec.oaheaimp := Convert( slices, 278 );
            rec.oaholimp := Convert( slices, 279 );
            rec.oahomimp := Convert( slices, 280 );
            rec.oameaimp := Convert( slices, 281 );
            rec.oaoutimp := Convert( slices, 282 );
            rec.oaphoimp := Convert( slices, 283 );
            rec.oataximp := Convert( slices, 284 );
            rec.oawarimp := Convert( slices, 285 );
            rec.subltamt := Convert( slices, 286 );
            rec.totcapb2 := Convert( slices, 287 );
            rec.totcapb3 := Convert( slices, 288 );
            rec.totsavbu := Convert( slices, 289 );
            rec.tuburent := Convert( slices, 290 );
            rec.youngch := Convert( slices, 291 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_0910;


   procedure Create_Care_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.issue := Convert( slices, 46 );
            rec.wholoo01 := Convert( slices, 47 );
            rec.wholoo02 := Convert( slices, 48 );
            rec.wholoo03 := Convert( slices, 49 );
            rec.wholoo04 := Convert( slices, 50 );
            rec.wholoo05 := Convert( slices, 51 );
            rec.wholoo06 := Convert( slices, 52 );
            rec.wholoo07 := Convert( slices, 53 );
            rec.wholoo08 := Convert( slices, 54 );
            rec.wholoo09 := Convert( slices, 55 );
            rec.wholoo10 := Convert( slices, 56 );
            rec.wholoo11 := Convert( slices, 57 );
            rec.wholoo12 := Convert( slices, 58 );
            rec.wholoo13 := Convert( slices, 59 );
            rec.wholoo14 := Convert( slices, 60 );
            rec.wholoo15 := Convert( slices, 61 );
            rec.wholoo16 := Convert( slices, 62 );
            rec.wholoo17 := Convert( slices, 63 );
            rec.wholoo18 := Convert( slices, 64 );
            rec.wholoo19 := Convert( slices, 65 );
            rec.wholoo20 := Convert( slices, 66 );
            rec.month := Convert( slices, 67 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_0910;


   procedure Create_Child_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddaprg := Convert( slices, 7 );
            rec.cddatre := Convert( slices, 8 );
            rec.cddatrep := Convert( slices, 9 );
            rec.cdisdif1 := Convert( slices, 10 );
            rec.cdisdif2 := Convert( slices, 11 );
            rec.cdisdif3 := Convert( slices, 12 );
            rec.cdisdif4 := Convert( slices, 13 );
            rec.cdisdif5 := Convert( slices, 14 );
            rec.cdisdif6 := Convert( slices, 15 );
            rec.cdisdif7 := Convert( slices, 16 );
            rec.cdisdif8 := Convert( slices, 17 );
            rec.cdisdif9 := Convert( slices, 18 );
            rec.cdisdifp := Convert( slices, 19 );
            rec.cfund := Convert( slices, 20 );
            rec.cfundh := Convert( slices, 21 );
            rec.cfundtp := Convert( slices, 22 );
            rec.chamtern := Convert( slices, 23 );
            rec.chamttst := Convert( slices, 24 );
            rec.chca := Convert( slices, 25 );
            rec.chdla1 := Convert( slices, 26 );
            rec.chdla2 := Convert( slices, 27 );
            rec.chealth := Convert( slices, 28 );
            rec.chearns1 := Convert( slices, 29 );
            rec.chearns2 := Convert( slices, 30 );
            rec.chema := Convert( slices, 31 );
            rec.chemaamt := Convert( slices, 32 );
            rec.chemapd := Convert( slices, 33 );
            rec.chpdern := Convert( slices, 34 );
            rec.chpdtst := Convert( slices, 35 );
            rec.chprob := Convert( slices, 36 );
            rec.chsave := Convert( slices, 37 );
            rec.chwkern := Convert( slices, 38 );
            rec.chwktst := Convert( slices, 39 );
            rec.chyrern := Convert( slices, 40 );
            rec.chyrtst := Convert( slices, 41 );
            rec.cohabit := Convert( slices, 42 );
            rec.convbl := Convert( slices, 43 );
            rec.cvht := Convert( slices, 44 );
            rec.cvpay := Convert( slices, 45 );
            rec.cvpd := Convert( slices, 46 );
            rec.depend := Convert( slices, 47 );
            rec.dob := Convert( slices, 48 );
            rec.eligadlt := Convert( slices, 49 );
            rec.eligchld := Convert( slices, 50 );
            rec.endyr := Convert( slices, 51 );
            rec.fted := Convert( slices, 52 );
            rec.fundamt1 := Convert( slices, 53 );
            rec.fundamt2 := Convert( slices, 54 );
            rec.fundamt3 := Convert( slices, 55 );
            rec.fundamt4 := Convert( slices, 56 );
            rec.fundamt5 := Convert( slices, 57 );
            rec.fundamt6 := Convert( slices, 58 );
            rec.givcfnd1 := Convert( slices, 59 );
            rec.givcfnd2 := Convert( slices, 60 );
            rec.givcfnd3 := Convert( slices, 61 );
            rec.givcfnd4 := Convert( slices, 62 );
            rec.givcfnd5 := Convert( slices, 63 );
            rec.givcfnd6 := Convert( slices, 64 );
            rec.grant := Convert( slices, 65 );
            rec.grtamt1 := Convert( slices, 66 );
            rec.grtamt2 := Convert( slices, 67 );
            rec.grtdir1 := Convert( slices, 68 );
            rec.grtdir2 := Convert( slices, 69 );
            rec.grtnum := Convert( slices, 70 );
            rec.grtsce1 := Convert( slices, 71 );
            rec.grtsce2 := Convert( slices, 72 );
            rec.grtval1 := Convert( slices, 73 );
            rec.grtval2 := Convert( slices, 74 );
            rec.hholder := Convert( slices, 75 );
            rec.issue := Convert( slices, 76 );
            rec.lareg := Convert( slices, 77 );
            rec.legdep := Convert( slices, 78 );
            rec.ms := Convert( slices, 79 );
            rec.parent1 := Convert( slices, 80 );
            rec.parent2 := Convert( slices, 81 );
            rec.r01 := Convert( slices, 82 );
            rec.r02 := Convert( slices, 83 );
            rec.r03 := Convert( slices, 84 );
            rec.r04 := Convert( slices, 85 );
            rec.r05 := Convert( slices, 86 );
            rec.r06 := Convert( slices, 87 );
            rec.r07 := Convert( slices, 88 );
            rec.r08 := Convert( slices, 89 );
            rec.r09 := Convert( slices, 90 );
            rec.r10 := Convert( slices, 91 );
            rec.r11 := Convert( slices, 92 );
            rec.r12 := Convert( slices, 93 );
            rec.r13 := Convert( slices, 94 );
            rec.r14 := Convert( slices, 95 );
            rec.schchk := Convert( slices, 96 );
            rec.sex := Convert( slices, 97 );
            rec.smkit := Convert( slices, 98 );
            rec.smlit := Convert( slices, 99 );
            rec.spcreg1 := Convert( slices, 100 );
            rec.spcreg2 := Convert( slices, 101 );
            rec.spcreg3 := Convert( slices, 102 );
            rec.spout := Convert( slices, 103 );
            rec.srentamt := Convert( slices, 104 );
            rec.srentpd := Convert( slices, 105 );
            rec.startyr := Convert( slices, 106 );
            rec.totsave := Convert( slices, 107 );
            rec.trainee := Convert( slices, 108 );
            rec.typeed := Convert( slices, 109 );
            rec.wmkit := Convert( slices, 110 );
            rec.month := Convert( slices, 111 );
            rec.careab := Convert( slices, 112 );
            rec.careah := Convert( slices, 113 );
            rec.carecb := Convert( slices, 114 );
            rec.carech := Convert( slices, 115 );
            rec.carecl := Convert( slices, 116 );
            rec.carefl := Convert( slices, 117 );
            rec.carefr := Convert( slices, 118 );
            rec.careot := Convert( slices, 119 );
            rec.carere := Convert( slices, 120 );
            rec.chdda := Convert( slices, 121 );
            rec.chearns := Convert( slices, 122 );
            rec.chincdv := Convert( slices, 123 );
            rec.chrinc := Convert( slices, 124 );
            rec.disdifch := Convert( slices, 125 );
            rec.fsmlkval := Convert( slices, 126 );
            rec.fsmval := Convert( slices, 127 );
            rec.hdagech := Convert( slices, 128 );
            rec.heartval := Convert( slices, 129 );
            rec.hourab := Convert( slices, 130 );
            rec.hourah := Convert( slices, 131 );
            rec.hourcb := Convert( slices, 132 );
            rec.hourch := Convert( slices, 133 );
            rec.hourcl := Convert( slices, 134 );
            rec.hourfr := Convert( slices, 135 );
            rec.hourot := Convert( slices, 136 );
            rec.hourre := Convert( slices, 137 );
            rec.hourtot := Convert( slices, 138 );
            rec.hperson := Convert( slices, 139 );
            rec.iagegr2 := Convert( slices, 140 );
            rec.iagegrp := Convert( slices, 141 );
            rec.relhrp := Convert( slices, 142 );
            rec.totgntch := Convert( slices, 143 );
            rec.tuacam := Convert( slices, 144 );
            rec.uperson := Convert( slices, 145 );
            rec.xbonflag := Convert( slices, 146 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_0910;


   procedure Create_ChildCare_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.benccdis := Convert( slices, 5 );
            rec.chamt := Convert( slices, 6 );
            rec.chhr := Convert( slices, 7 );
            rec.chpd := Convert( slices, 8 );
            rec.cost := Convert( slices, 9 );
            rec.ctrm := Convert( slices, 10 );
            rec.emplprov := Convert( slices, 11 );
            rec.hourly := Convert( slices, 12 );
            rec.issue := Convert( slices, 13 );
            rec.pmchk := Convert( slices, 14 );
            rec.registrd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_0910;


   procedure Create_Endowment_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.menpolam := Convert( slices, 6 );
            rec.menpolpd := Convert( slices, 7 );
            rec.menstyr := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_0910;


   procedure Create_ExtChild_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.nhhamt := Convert( slices, 5 );
            rec.nhhfee := Convert( slices, 6 );
            rec.nhhintro := Convert( slices, 7 );
            rec.nhhpd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_0910;


   procedure Create_GovPay_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_0910;


   procedure Create_Hbai_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.benunits := Convert( slices, 19 );
            rec.gvtregn := Convert( slices, 20 );
            rec.hhstat := Convert( slices, 21 );
            rec.tenure := Convert( slices, 22 );
            rec.adulth := Convert( slices, 23 );
            rec.depchldh := Convert( slices, 24 );
            rec.ptentyp2 := Convert( slices, 25 );
            rec.tentyp2 := Convert( slices, 26 );
            rec.watsewrt := Convert( slices, 27 );
            rec.sewerage := Convert( slices, 28 );
            rec.cwathh := Convert( slices, 29 );
            rec.totsthh := Convert( slices, 30 );
            rec.totstrhh := Convert( slices, 31 );
            rec.charghh := Convert( slices, 32 );
            rec.hbmort := Convert( slices, 33 );
            rec.hbxmort := Convert( slices, 34 );
            rec.hrenthh := Convert( slices, 35 );
            rec.erenthh := Convert( slices, 36 );
            rec.hbenhh := Convert( slices, 37 );
            rec.watsewhh := Convert( slices, 38 );
            rec.hhcost := Convert( slices, 39 );
            rec.ehcost := Convert( slices, 40 );
            rec.bhcdef := Convert( slices, 41 );
            rec.ahcdef := Convert( slices, 42 );
            rec.ctrebam1 := Convert( slices, 43 );
            rec.cwatadj := Convert( slices, 44 );
            rec.adultb := Convert( slices, 45 );
            rec.egrincbu := Convert( slices, 46 );
            rec.entincbu := Convert( slices, 47 );
            rec.hgrernhh := Convert( slices, 48 );
            rec.hnternhh := Convert( slices, 49 );
            rec.hgrinvhh := Convert( slices, 50 );
            rec.hntinvhh := Convert( slices, 51 );
            rec.hgrocchh := Convert( slices, 52 );
            rec.hntocchh := Convert( slices, 53 );
            rec.chbenhh := Convert( slices, 54 );
            rec.hbeninhh := Convert( slices, 55 );
            rec.hpribnhh := Convert( slices, 56 );
            rec.hmiscihh := Convert( slices, 57 );
            rec.sfrpahh := Convert( slices, 58 );
            rec.hgrinchh := Convert( slices, 59 );
            rec.hntinchh := Convert( slices, 60 );
            rec.inchilhh := Convert( slices, 61 );
            rec.sehhflg := Convert( slices, 62 );
            rec.ethgrphh := Convert( slices, 63 );
            rec.egrernhh := Convert( slices, 64 );
            rec.enternhh := Convert( slices, 65 );
            rec.ebeninhh := Convert( slices, 66 );
            rec.epribnhh := Convert( slices, 67 );
            rec.emiscihh := Convert( slices, 68 );
            rec.eothdehh := Convert( slices, 69 );
            rec.egrinchh := Convert( slices, 70 );
            rec.entinchh := Convert( slices, 71 );
            rec.tvlichh := Convert( slices, 72 );
            rec.g_newhh := Convert( slices, 73 );
            rec.gnewhhp := Convert( slices, 74 );
            rec.esgjobhh := Convert( slices, 75 );
            rec.esgrsehh := Convert( slices, 76 );
            rec.esginvhh := Convert( slices, 77 );
            rec.esgocchh := Convert( slices, 78 );
            rec.esmischh := Convert( slices, 79 );
            rec.espribhh := Convert( slices, 80 );
            rec.esbenihh := Convert( slices, 81 );
            rec.esothdhh := Convert( slices, 82 );
            rec.esginchh := Convert( slices, 83 );
            rec.esninchh := Convert( slices, 84 );
            rec.ericphh := Convert( slices, 85 );
            rec.ericnphh := Convert( slices, 86 );
            rec.gs_newhh := Convert( slices, 87 );
            rec.gs_newpph := Convert( slices, 88 );
            rec.es_hcost := Convert( slices, 89 );
            rec.esahchh := Convert( slices, 90 );
            rec.eahchh := Convert( slices, 91 );
            rec.benunit := Convert( slices, 92 );
            rec.depchldb := Convert( slices, 93 );
            rec.eqmcoup := Convert( slices, 94 );
            rec.eqmbhckd := Convert( slices, 95 );
            rec.eqmahckd := Convert( slices, 96 );
            rec.eqmbhchh := Convert( slices, 97 );
            rec.eqmahchh := Convert( slices, 98 );
            rec.over14 := Convert( slices, 99 );
            rec.under14 := Convert( slices, 100 );
            rec.eqobhchh := Convert( slices, 101 );
            rec.eqoahchh := Convert( slices, 102 );
            rec.mc_bhc := Convert( slices, 103 );
            rec.oe_bhc := Convert( slices, 104 );
            rec.mc_gro := Convert( slices, 105 );
            rec.oe_gro := Convert( slices, 106 );
            rec.mc_ahc := Convert( slices, 107 );
            rec.oe_ahc := Convert( slices, 108 );
            rec.s_mc_bhc := Convert( slices, 109 );
            rec.s_oe_bhc := Convert( slices, 110 );
            rec.s_mc_gro := Convert( slices, 111 );
            rec.s_oe_gro := Convert( slices, 112 );
            rec.s_mc_ahc := Convert( slices, 113 );
            rec.s_oe_ahc := Convert( slices, 114 );
            rec.fsmbu := Convert( slices, 115 );
            rec.fsmlkbu := Convert( slices, 116 );
            rec.hbenbu := Convert( slices, 117 );
            rec.ehbenbu := Convert( slices, 118 );
            rec.srentbu := Convert( slices, 119 );
            rec.rentbu := Convert( slices, 120 );
            rec.erentbu := Convert( slices, 121 );
            rec.insebu := Convert( slices, 122 );
            rec.ginsebu := Convert( slices, 123 );
            rec.chbenbu := Convert( slices, 124 );
            rec.hgrernbu := Convert( slices, 125 );
            rec.hnternbu := Convert( slices, 126 );
            rec.hgrinvbu := Convert( slices, 127 );
            rec.hntinvbu := Convert( slices, 128 );
            rec.hgroccbu := Convert( slices, 129 );
            rec.hntoccbu := Convert( slices, 130 );
            rec.hbeninbu := Convert( slices, 131 );
            rec.hpribnbu := Convert( slices, 132 );
            rec.hmiscibu := Convert( slices, 133 );
            rec.sfrpabu := Convert( slices, 134 );
            rec.hgrincbu := Convert( slices, 135 );
            rec.hntincbu := Convert( slices, 136 );
            rec.egrernbu := Convert( slices, 137 );
            rec.enternbu := Convert( slices, 138 );
            rec.ebeninbu := Convert( slices, 139 );
            rec.epribnbu := Convert( slices, 140 );
            rec.emiscibu := Convert( slices, 141 );
            rec.eothdebu := Convert( slices, 142 );
            rec.winpaybu := Convert( slices, 143 );
            rec.tvlicbu := Convert( slices, 144 );
            rec.ecobu := Convert( slices, 145 );
            rec.oldecobu := Convert( slices, 146 );
            rec.disabflg := Convert( slices, 147 );
            rec.fambu := Convert( slices, 148 );
            rec.newfambu := Convert( slices, 149 );
            rec.personhd := Convert( slices, 150 );
            rec.personsp := Convert( slices, 151 );
            rec.kidecobu := Convert( slices, 152 );
            rec.oldkidecobu := Convert( slices, 153 );
            rec.kid0_1 := Convert( slices, 154 );
            rec.kid2_4 := Convert( slices, 155 );
            rec.kid5_7 := Convert( slices, 156 );
            rec.kid8_10 := Convert( slices, 157 );
            rec.kid11_12 := Convert( slices, 158 );
            rec.kid13_15 := Convert( slices, 159 );
            rec.kid16_19 := Convert( slices, 160 );
            rec.boys := Convert( slices, 161 );
            rec.wtcbu := Convert( slices, 162 );
            rec.ctcbu := Convert( slices, 163 );
            rec.isbu := Convert( slices, 164 );
            rec.inchilbu := Convert( slices, 165 );
            rec.g_newbu := Convert( slices, 166 );
            rec.g_newpp := Convert( slices, 167 );
            rec.g_newch := Convert( slices, 168 );
            rec.g_newad := Convert( slices, 169 );
            rec.g_newpn := Convert( slices, 170 );
            rec.g_newwa := Convert( slices, 171 );
            rec.esgjobbu := Convert( slices, 172 );
            rec.esgrsebu := Convert( slices, 173 );
            rec.esginvbu := Convert( slices, 174 );
            rec.esgoccbu := Convert( slices, 175 );
            rec.esmiscbu := Convert( slices, 176 );
            rec.espribbu := Convert( slices, 177 );
            rec.esbenibu := Convert( slices, 178 );
            rec.esothdbu := Convert( slices, 179 );
            rec.esgincbu := Convert( slices, 180 );
            rec.esnincbu := Convert( slices, 181 );
            rec.ericpbu := Convert( slices, 182 );
            rec.ericnpbu := Convert( slices, 183 );
            rec.gs_newbu := Convert( slices, 184 );
            rec.gs_newpp := Convert( slices, 185 );
            rec.gs_newch := Convert( slices, 186 );
            rec.gs_newad := Convert( slices, 187 );
            rec.gs_newpn := Convert( slices, 188 );
            rec.gs_newwa := Convert( slices, 189 );
            rec.mbhcdec := Convert( slices, 190 );
            rec.mqinbhc := Convert( slices, 191 );
            rec.obhcdec := Convert( slices, 192 );
            rec.oqinbhc := Convert( slices, 193 );
            rec.mahcdec := Convert( slices, 194 );
            rec.mqinahc := Convert( slices, 195 );
            rec.oahcdec := Convert( slices, 196 );
            rec.oqinahc := Convert( slices, 197 );
            rec.mbhcdecx := Convert( slices, 198 );
            rec.mqinbhcx := Convert( slices, 199 );
            rec.obhcdecx := Convert( slices, 200 );
            rec.oqinbhcx := Convert( slices, 201 );
            rec.mahcdecx := Convert( slices, 202 );
            rec.mqinahcx := Convert( slices, 203 );
            rec.oahcdecx := Convert( slices, 204 );
            rec.oqinahcx := Convert( slices, 205 );
            rec.agehd := Convert( slices, 206 );
            rec.sexhd := Convert( slices, 207 );
            rec.esbenihd := Convert( slices, 208 );
            rec.esgjobhd := Convert( slices, 210 );
            rec.esgocchd := Convert( slices, 211 );
            rec.esgrsehd := Convert( slices, 212 );
            rec.esmischd := Convert( slices, 213 );
            rec.espribhd := Convert( slices, 214 );
            rec.winpayhd := Convert( slices, 215 );
            rec.agesp := Convert( slices, 216 );
            rec.sexsp := Convert( slices, 217 );
            rec.esbenisp := Convert( slices, 218 );
            rec.esginvsp := Convert( slices, 219 );
            rec.esgjobsp := Convert( slices, 220 );
            rec.esgoccsp := Convert( slices, 221 );
            rec.esgrsesp := Convert( slices, 222 );
            rec.esmiscsp := Convert( slices, 223 );
            rec.espribsp := Convert( slices, 224 );
            rec.winpaysp := Convert( slices, 225 );
            rec.mdscorech := Convert( slices, 226 );
            rec.mdch := Convert( slices, 227 );
            rec.mdscorepn := Convert( slices, 228 );
            rec.mdpn := Convert( slices, 229 );
            rec.low50bhc := Convert( slices, 230 );
            rec.low60bhc := Convert( slices, 231 );
            rec.low70bhc := Convert( slices, 232 );
            rec.low50ahc := Convert( slices, 233 );
            rec.low60ahc := Convert( slices, 234 );
            rec.low70ahc := Convert( slices, 235 );
            rec.lowincmdch := Convert( slices, 236 );
            rec.lowincmdchsev := Convert( slices, 237 );
            rec.oldsehhflg := Convert( slices, 238 );
            rec.lowmcbhc := Convert( slices, 239 );
            rec.lowmcahc := Convert( slices, 240 );
            rec.sernum := Convert( slices, 241 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_0910;


   procedure Create_Household_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.bedroom := Convert( slices, 2 );
            rec.benunits := Convert( slices, 3 );
            rec.billrate := Convert( slices, 4 );
            rec.brma := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.capval := Convert( slices, 7 );
            rec.charge1 := Convert( slices, 8 );
            rec.charge2 := Convert( slices, 9 );
            rec.charge3 := Convert( slices, 10 );
            rec.charge4 := Convert( slices, 11 );
            rec.charge5 := Convert( slices, 12 );
            rec.charge6 := Convert( slices, 13 );
            rec.charge7 := Convert( slices, 14 );
            rec.charge8 := Convert( slices, 15 );
            rec.charge9 := Convert( slices, 16 );
            rec.chins := Convert( slices, 17 );
            rec.chrgamt1 := Convert( slices, 18 );
            rec.chrgamt2 := Convert( slices, 19 );
            rec.chrgamt3 := Convert( slices, 20 );
            rec.chrgamt4 := Convert( slices, 21 );
            rec.chrgamt5 := Convert( slices, 22 );
            rec.chrgamt6 := Convert( slices, 23 );
            rec.chrgamt7 := Convert( slices, 24 );
            rec.chrgamt8 := Convert( slices, 25 );
            rec.chrgamt9 := Convert( slices, 26 );
            rec.chrgpd1 := Convert( slices, 27 );
            rec.chrgpd2 := Convert( slices, 28 );
            rec.chrgpd3 := Convert( slices, 29 );
            rec.chrgpd4 := Convert( slices, 30 );
            rec.chrgpd5 := Convert( slices, 31 );
            rec.chrgpd6 := Convert( slices, 32 );
            rec.chrgpd7 := Convert( slices, 33 );
            rec.chrgpd8 := Convert( slices, 34 );
            rec.chrgpd9 := Convert( slices, 35 );
            rec.covoths := Convert( slices, 36 );
            rec.csewamt := Convert( slices, 37 );
            rec.csewamt1 := Convert( slices, 38 );
            rec.ct25d50d := Convert( slices, 39 );
            rec.ctamt := Convert( slices, 40 );
            rec.ctannual := Convert( slices, 41 );
            rec.ctband := Convert( slices, 42 );
            rec.ctbwait := Convert( slices, 43 );
            rec.ctcondoc := Convert( slices, 44 );
            rec.ctdisc := Convert( slices, 45 );
            rec.ctinstal := Convert( slices, 46 );
            rec.ctlvband := Convert( slices, 47 );
            rec.ctlvchk := Convert( slices, 48 );
            rec.ctreb := Convert( slices, 49 );
            rec.ctrebamt := Convert( slices, 50 );
            rec.ctrebpd := Convert( slices, 51 );
            rec.cttime := Convert( slices, 52 );
            rec.cwatamt := Convert( slices, 53 );
            rec.cwatamt1 := Convert( slices, 54 );
            rec.datyrago := Convert( slices, 55 );
            rec.dvadulth := Convert( slices, 56 );
            rec.dvtotad := Convert( slices, 57 );
            rec.entry1 := Convert( slices, 58 );
            rec.entry2 := Convert( slices, 59 );
            rec.entry3 := Convert( slices, 60 );
            rec.entry4 := Convert( slices, 61 );
            rec.entry5 := Convert( slices, 62 );
            rec.entry6 := Convert( slices, 63 );
            rec.floor := Convert( slices, 64 );
            rec.givehelp := Convert( slices, 65 );
            rec.gvtregn := Convert( slices, 66 );
            rec.hhldr01 := Convert( slices, 67 );
            rec.hhldr02 := Convert( slices, 68 );
            rec.hhldr03 := Convert( slices, 69 );
            rec.hhldr04 := Convert( slices, 70 );
            rec.hhldr05 := Convert( slices, 71 );
            rec.hhldr06 := Convert( slices, 72 );
            rec.hhldr07 := Convert( slices, 73 );
            rec.hhldr08 := Convert( slices, 74 );
            rec.hhldr09 := Convert( slices, 75 );
            rec.hhldr10 := Convert( slices, 76 );
            rec.hhldr11 := Convert( slices, 77 );
            rec.hhldr12 := Convert( slices, 78 );
            rec.hhldr13 := Convert( slices, 79 );
            rec.hhldr14 := Convert( slices, 80 );
            rec.hhldr97 := Convert( slices, 81 );
            rec.hhstat := Convert( slices, 82 );
            rec.hrpnum := Convert( slices, 83 );
            rec.imd_e := Convert( slices, 84 );
            rec.imd_s := Convert( slices, 85 );
            rec.imd_w := Convert( slices, 86 );
            rec.intdate := Convert( slices, 87 );
            rec.issue := Convert( slices, 88 );
            rec.lac := Convert( slices, 89 );
            rec.mainacc := Convert( slices, 90 );
            rec.migrq1 := Convert( slices, 91 );
            rec.migrq2 := Convert( slices, 92 );
            rec.mnthcode := Convert( slices, 93 );
            rec.monlive := Convert( slices, 94 );
            rec.needhelp := Convert( slices, 95 );
            rec.nicoun := Convert( slices, 96 );
            rec.nidpnd := Convert( slices, 97 );
            rec.ninrv := Convert( slices, 98 );
            rec.nirate := Convert( slices, 99 );
            rec.nochcr1 := Convert( slices, 100 );
            rec.nochcr2 := Convert( slices, 101 );
            rec.nochcr3 := Convert( slices, 102 );
            rec.nochcr4 := Convert( slices, 103 );
            rec.nochcr5 := Convert( slices, 104 );
            rec.norate := Convert( slices, 105 );
            rec.numtv1 := Convert( slices, 106 );
            rec.numtv2 := Convert( slices, 107 );
            rec.oac := Convert( slices, 108 );
            rec.onbsroom := Convert( slices, 109 );
            rec.orgsewam := Convert( slices, 110 );
            rec.orgwatam := Convert( slices, 111 );
            rec.payrate := Convert( slices, 112 );
            rec.ptbsroom := Convert( slices, 113 );
            rec.rooms := Convert( slices, 114 );
            rec.roomshar := Convert( slices, 115 );
            rec.rt2rebam := Convert( slices, 116 );
            rec.rt2rebpd := Convert( slices, 117 );
            rec.rtannual := Convert( slices, 118 );
            rec.rtcondoc := Convert( slices, 119 );
            rec.rtdpa := Convert( slices, 120 );
            rec.rtdpaamt := Convert( slices, 121 );
            rec.rtdpapd := Convert( slices, 122 );
            rec.rtinstal := Convert( slices, 123 );
            rec.rtlpa := Convert( slices, 124 );
            rec.rtlpaamt := Convert( slices, 125 );
            rec.rtlpapd := Convert( slices, 126 );
            rec.rtothamt := Convert( slices, 127 );
            rec.rtother := Convert( slices, 128 );
            rec.rtothpd := Convert( slices, 129 );
            rec.rtreb := Convert( slices, 130 );
            rec.rtrebamt := Convert( slices, 131 );
            rec.rtrebpd := Convert( slices, 132 );
            rec.rtrtr := Convert( slices, 133 );
            rec.rtrtramt := Convert( slices, 134 );
            rec.rtrtrpd := Convert( slices, 135 );
            rec.rttimepd := Convert( slices, 136 );
            rec.sampqtr := Convert( slices, 137 );
            rec.schmeal := Convert( slices, 138 );
            rec.schmilk := Convert( slices, 139 );
            rec.sewamt := Convert( slices, 140 );
            rec.sewanul := Convert( slices, 141 );
            rec.sewerpay := Convert( slices, 142 );
            rec.sewsep := Convert( slices, 143 );
            rec.sewtime := Convert( slices, 144 );
            rec.shelter := Convert( slices, 145 );
            rec.sobuy := Convert( slices, 146 );
            rec.sstrtreg := Convert( slices, 147 );
            rec.stramt1 := Convert( slices, 148 );
            rec.stramt2 := Convert( slices, 149 );
            rec.strcov := Convert( slices, 150 );
            rec.strmort := Convert( slices, 151 );
            rec.stroths := Convert( slices, 152 );
            rec.strpd1 := Convert( slices, 153 );
            rec.strpd2 := Convert( slices, 154 );
            rec.suballow := Convert( slices, 155 );
            rec.sublet := Convert( slices, 156 );
            rec.sublety := Convert( slices, 157 );
            rec.subrent := Convert( slices, 158 );
            rec.tenure := Convert( slices, 159 );
            rec.totchild := Convert( slices, 160 );
            rec.totdepdk := Convert( slices, 161 );
            rec.tvlic := Convert( slices, 162 );
            rec.typeacc := Convert( slices, 163 );
            rec.urindew := Convert( slices, 164 );
            rec.urinds := Convert( slices, 165 );
            rec.watamt := Convert( slices, 166 );
            rec.watanul := Convert( slices, 167 );
            rec.watermet := Convert( slices, 168 );
            rec.waterpay := Convert( slices, 169 );
            rec.watrb := Convert( slices, 170 );
            rec.wattime := Convert( slices, 171 );
            rec.welfmilk := Convert( slices, 172 );
            rec.whoctb01 := Convert( slices, 173 );
            rec.whoctb02 := Convert( slices, 174 );
            rec.whoctb03 := Convert( slices, 175 );
            rec.whoctb04 := Convert( slices, 176 );
            rec.whoctb05 := Convert( slices, 177 );
            rec.whoctb06 := Convert( slices, 178 );
            rec.whoctb07 := Convert( slices, 179 );
            rec.whoctb08 := Convert( slices, 180 );
            rec.whoctb09 := Convert( slices, 181 );
            rec.whoctb10 := Convert( slices, 182 );
            rec.whoctb11 := Convert( slices, 183 );
            rec.whoctb12 := Convert( slices, 184 );
            rec.whoctb13 := Convert( slices, 185 );
            rec.whoctb14 := Convert( slices, 186 );
            rec.whoctbns := Convert( slices, 187 );
            rec.whoctbot := Convert( slices, 188 );
            rec.whorsp01 := Convert( slices, 189 );
            rec.whorsp02 := Convert( slices, 190 );
            rec.whorsp03 := Convert( slices, 191 );
            rec.whorsp04 := Convert( slices, 192 );
            rec.whorsp05 := Convert( slices, 193 );
            rec.whorsp06 := Convert( slices, 194 );
            rec.whorsp07 := Convert( slices, 195 );
            rec.whorsp08 := Convert( slices, 196 );
            rec.whorsp09 := Convert( slices, 197 );
            rec.whorsp10 := Convert( slices, 198 );
            rec.whorsp11 := Convert( slices, 199 );
            rec.whorsp12 := Convert( slices, 200 );
            rec.whorsp13 := Convert( slices, 201 );
            rec.whorsp14 := Convert( slices, 202 );
            rec.whynoct := Convert( slices, 203 );
            rec.wmintro := Convert( slices, 204 );
            rec.wsewamt := Convert( slices, 205 );
            rec.wsewanul := Convert( slices, 206 );
            rec.wsewtime := Convert( slices, 207 );
            rec.yearcode := Convert( slices, 208 );
            rec.yearlive := Convert( slices, 209 );
            rec.yrlvchk := Convert( slices, 210 );
            rec.month := Convert( slices, 211 );
            rec.adddahh := Convert( slices, 212 );
            rec.adulth := Convert( slices, 213 );
            rec.bedroom6 := Convert( slices, 214 );
            rec.chddahh := Convert( slices, 215 );
            rec.country := Convert( slices, 216 );
            rec.cwatamtd := Convert( slices, 217 );
            rec.depchldh := Convert( slices, 218 );
            rec.emp := Convert( slices, 219 );
            rec.emphrp := Convert( slices, 220 );
            rec.endowpay := Convert( slices, 221 );
            rec.gbhscost := Convert( slices, 222 );
            rec.gross3 := Convert( slices, 223 );
            rec.gross3_x := Convert( slices, 224 );
            rec.grossct := Convert( slices, 225 );
            rec.hbeninc := Convert( slices, 226 );
            rec.hbindhh := Convert( slices, 227 );
            rec.hbindhh2 := Convert( slices, 228 );
            rec.hdhhinc := Convert( slices, 229 );
            rec.hdtax := Convert( slices, 230 );
            rec.hearns := Convert( slices, 231 );
            rec.hhagegr2 := Convert( slices, 232 );
            rec.hhagegr3 := Convert( slices, 233 );
            rec.hhagegr4 := Convert( slices, 234 );
            rec.hhagegrp := Convert( slices, 235 );
            rec.hhcomps := Convert( slices, 236 );
            rec.hhdisben := Convert( slices, 237 );
            rec.hhinc := Convert( slices, 238 );
            rec.hhincbnd := Convert( slices, 239 );
            rec.hhinv := Convert( slices, 240 );
            rec.hhirben := Convert( slices, 241 );
            rec.hhnirben := Convert( slices, 242 );
            rec.hhothben := Convert( slices, 243 );
            rec.hhrent := Convert( slices, 244 );
            rec.hhrinc := Convert( slices, 245 );
            rec.hhrpinc := Convert( slices, 246 );
            rec.hhtvlic := Convert( slices, 247 );
            rec.hhtxcred := Convert( slices, 248 );
            rec.hothinc := Convert( slices, 249 );
            rec.hpeninc := Convert( slices, 250 );
            rec.hseinc := Convert( slices, 251 );
            rec.london := Convert( slices, 252 );
            rec.mortcost := Convert( slices, 253 );
            rec.mortint := Convert( slices, 254 );
            rec.mortpay := Convert( slices, 255 );
            rec.nihscost := Convert( slices, 256 );
            rec.penage := Convert( slices, 257 );
            rec.penhrp := Convert( slices, 258 );
            rec.ptentyp2 := Convert( slices, 259 );
            rec.rooms10 := Convert( slices, 260 );
            rec.servpay := Convert( slices, 261 );
            rec.struins := Convert( slices, 262 );
            rec.tentyp2 := Convert( slices, 263 );
            rec.tuhhrent := Convert( slices, 264 );
            rec.tuwatsew := Convert( slices, 265 );
            rec.watsewrt := Convert( slices, 266 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_0910;


   procedure Create_Job_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.checktax := Convert( slices, 20 );
            rec.chkincom := Convert( slices, 21 );
            rec.chvamt := Convert( slices, 22 );
            rec.chvpd := Convert( slices, 23 );
            rec.chvsac := Convert( slices, 24 );
            rec.chvuamt := Convert( slices, 25 );
            rec.chvupd := Convert( slices, 26 );
            rec.chvusu := Convert( slices, 27 );
            rec.dedoth := Convert( slices, 28 );
            rec.deduc1 := Convert( slices, 29 );
            rec.deduc2 := Convert( slices, 30 );
            rec.deduc3 := Convert( slices, 31 );
            rec.deduc4 := Convert( slices, 32 );
            rec.deduc5 := Convert( slices, 33 );
            rec.deduc6 := Convert( slices, 34 );
            rec.deduc7 := Convert( slices, 35 );
            rec.deduc8 := Convert( slices, 36 );
            rec.dirctr := Convert( slices, 37 );
            rec.dirni := Convert( slices, 38 );
            rec.dvtothru := Convert( slices, 39 );
            rec.dvushr := Convert( slices, 40 );
            rec.empany := Convert( slices, 41 );
            rec.empown := Convert( slices, 42 );
            rec.etype := Convert( slices, 43 );
            rec.everot := Convert( slices, 44 );
            rec.expben01 := Convert( slices, 45 );
            rec.expben02 := Convert( slices, 46 );
            rec.expben03 := Convert( slices, 47 );
            rec.expben04 := Convert( slices, 48 );
            rec.expben05 := Convert( slices, 49 );
            rec.expben06 := Convert( slices, 50 );
            rec.expben07 := Convert( slices, 51 );
            rec.expben08 := Convert( slices, 52 );
            rec.expben09 := Convert( slices, 53 );
            rec.expben10 := Convert( slices, 54 );
            rec.expben11 := Convert( slices, 55 );
            rec.expben12 := Convert( slices, 56 );
            rec.ftpt := Convert( slices, 57 );
            rec.fuelamt := Convert( slices, 58 );
            rec.fuelbn := Convert( slices, 59 );
            rec.fuelpd := Convert( slices, 60 );
            rec.fueluamt := Convert( slices, 61 );
            rec.fuelupd := Convert( slices, 62 );
            rec.fuelusu := Convert( slices, 63 );
            rec.grsofar := Convert( slices, 64 );
            rec.grwage := Convert( slices, 65 );
            rec.grwagpd := Convert( slices, 66 );
            rec.hha1 := Convert( slices, 67 );
            rec.hha2 := Convert( slices, 68 );
            rec.hha3 := Convert( slices, 69 );
            rec.hhc1 := Convert( slices, 70 );
            rec.hhc2 := Convert( slices, 71 );
            rec.hhc3 := Convert( slices, 72 );
            rec.hohinc := Convert( slices, 73 );
            rec.inclpay1 := Convert( slices, 74 );
            rec.inclpay2 := Convert( slices, 75 );
            rec.inclpay3 := Convert( slices, 76 );
            rec.inclpay4 := Convert( slices, 77 );
            rec.inclpay5 := Convert( slices, 78 );
            rec.inclpay6 := Convert( slices, 79 );
            rec.inclpay7 := Convert( slices, 80 );
            rec.instype1 := Convert( slices, 81 );
            rec.instype2 := Convert( slices, 82 );
            rec.issue := Convert( slices, 83 );
            rec.jobbus := Convert( slices, 84 );
            rec.likehr := Convert( slices, 85 );
            rec.mademp := Convert( slices, 86 );
            rec.matemp := Convert( slices, 87 );
            rec.matstp := Convert( slices, 88 );
            rec.mileamt := Convert( slices, 89 );
            rec.motamt := Convert( slices, 90 );
            rec.natins := Convert( slices, 91 );
            rec.nature := Convert( slices, 92 );
            rec.nidamt := Convert( slices, 93 );
            rec.nidpd := Convert( slices, 94 );
            rec.nmchc := Convert( slices, 95 );
            rec.nmper := Convert( slices, 96 );
            rec.nomor1 := Convert( slices, 97 );
            rec.nomor2 := Convert( slices, 98 );
            rec.nomor3 := Convert( slices, 99 );
            rec.numemp := Convert( slices, 100 );
            rec.othded1 := Convert( slices, 101 );
            rec.othded2 := Convert( slices, 102 );
            rec.othded3 := Convert( slices, 103 );
            rec.othded4 := Convert( slices, 104 );
            rec.othded5 := Convert( slices, 105 );
            rec.othded6 := Convert( slices, 106 );
            rec.othded7 := Convert( slices, 107 );
            rec.othded8 := Convert( slices, 108 );
            rec.othded9 := Convert( slices, 109 );
            rec.ownamt := Convert( slices, 110 );
            rec.ownotamt := Convert( slices, 111 );
            rec.ownother := Convert( slices, 112 );
            rec.ownsum := Convert( slices, 113 );
            rec.paperiod := Convert( slices, 114 );
            rec.payamt := Convert( slices, 115 );
            rec.paydat := Convert( slices, 116 );
            rec.paye := Convert( slices, 117 );
            rec.paypd := Convert( slices, 118 );
            rec.payslip := Convert( slices, 119 );
            rec.payusl := Convert( slices, 120 );
            rec.pothr := Convert( slices, 121 );
            rec.ppperiod := Convert( slices, 122 );
            rec.prbefore := Convert( slices, 123 );
            rec.prevmth := Convert( slices, 124 );
            rec.prevyr := Convert( slices, 125 );
            rec.profdocs := Convert( slices, 126 );
            rec.profit1 := Convert( slices, 127 );
            rec.profit2 := Convert( slices, 128 );
            rec.profni := Convert( slices, 129 );
            rec.proftax := Convert( slices, 130 );
            rec.rspoth := Convert( slices, 131 );
            rec.salsac := Convert( slices, 132 );
            rec.sapamt := Convert( slices, 133 );
            rec.se1 := Convert( slices, 134 );
            rec.se2 := Convert( slices, 135 );
            rec.seend := Convert( slices, 136 );
            rec.seincamt := Convert( slices, 137 );
            rec.seincwm := Convert( slices, 138 );
            rec.selwks := Convert( slices, 139 );
            rec.seniiamt := Convert( slices, 140 );
            rec.seniinc := Convert( slices, 141 );
            rec.senilamt := Convert( slices, 142 );
            rec.senilump := Convert( slices, 143 );
            rec.seniramt := Convert( slices, 144 );
            rec.senireg := Convert( slices, 145 );
            rec.senirpd := Convert( slices, 146 );
            rec.setax := Convert( slices, 147 );
            rec.setaxamt := Convert( slices, 148 );
            rec.smpamt := Convert( slices, 149 );
            rec.smprate := Convert( slices, 150 );
            rec.sole := Convert( slices, 151 );
            rec.spnamt := Convert( slices, 152 );
            rec.spnpd := Convert( slices, 153 );
            rec.spnsac := Convert( slices, 154 );
            rec.spnuamt := Convert( slices, 155 );
            rec.spnupd := Convert( slices, 156 );
            rec.spnusu := Convert( slices, 157 );
            rec.sppamt := Convert( slices, 158 );
            rec.sspamt := Convert( slices, 159 );
            rec.taxamt := Convert( slices, 160 );
            rec.taxdamt := Convert( slices, 161 );
            rec.taxdpd := Convert( slices, 162 );
            rec.totus1 := Convert( slices, 163 );
            rec.ubonamt := Convert( slices, 164 );
            rec.uboninc := Convert( slices, 165 );
            rec.udeduc1 := Convert( slices, 166 );
            rec.udeduc2 := Convert( slices, 167 );
            rec.udeduc3 := Convert( slices, 168 );
            rec.udeduc4 := Convert( slices, 169 );
            rec.udeduc5 := Convert( slices, 170 );
            rec.udeduc6 := Convert( slices, 171 );
            rec.udeduc7 := Convert( slices, 172 );
            rec.udeduc8 := Convert( slices, 173 );
            rec.ugross := Convert( slices, 174 );
            rec.uincpay1 := Convert( slices, 175 );
            rec.uincpay2 := Convert( slices, 176 );
            rec.uincpay3 := Convert( slices, 177 );
            rec.uincpay4 := Convert( slices, 178 );
            rec.uincpay5 := Convert( slices, 179 );
            rec.uincpay6 := Convert( slices, 180 );
            rec.uincpay7 := Convert( slices, 181 );
            rec.umileamt := Convert( slices, 182 );
            rec.umotamt := Convert( slices, 183 );
            rec.unett := Convert( slices, 184 );
            rec.uothded1 := Convert( slices, 185 );
            rec.uothded2 := Convert( slices, 186 );
            rec.uothded3 := Convert( slices, 187 );
            rec.uothded4 := Convert( slices, 188 );
            rec.uothded5 := Convert( slices, 189 );
            rec.uothded6 := Convert( slices, 190 );
            rec.uothded7 := Convert( slices, 191 );
            rec.uothded8 := Convert( slices, 192 );
            rec.uothded9 := Convert( slices, 193 );
            rec.uothdtot := Convert( slices, 194 );
            rec.uothr := Convert( slices, 195 );
            rec.upd := Convert( slices, 196 );
            rec.usapamt := Convert( slices, 197 );
            rec.usmpamt := Convert( slices, 198 );
            rec.usmprate := Convert( slices, 199 );
            rec.usppamt := Convert( slices, 200 );
            rec.usspamt := Convert( slices, 201 );
            rec.usuhr := Convert( slices, 202 );
            rec.utaxamt := Convert( slices, 203 );
            rec.vchamt := Convert( slices, 204 );
            rec.vchpd := Convert( slices, 205 );
            rec.vchsac := Convert( slices, 206 );
            rec.vchuamt := Convert( slices, 207 );
            rec.vchupd := Convert( slices, 208 );
            rec.vchusu := Convert( slices, 209 );
            rec.watdid := Convert( slices, 210 );
            rec.watprev := Convert( slices, 211 );
            rec.where := Convert( slices, 212 );
            rec.whynopro := Convert( slices, 213 );
            rec.whynou01 := Convert( slices, 214 );
            rec.whynou02 := Convert( slices, 215 );
            rec.whynou03 := Convert( slices, 216 );
            rec.whynou04 := Convert( slices, 217 );
            rec.whynou05 := Convert( slices, 218 );
            rec.whynou06 := Convert( slices, 219 );
            rec.whynou07 := Convert( slices, 220 );
            rec.whynou08 := Convert( slices, 221 );
            rec.whynou09 := Convert( slices, 222 );
            rec.whynou10 := Convert( slices, 223 );
            rec.whynou11 := Convert( slices, 224 );
            rec.workacc := Convert( slices, 225 );
            rec.workmth := Convert( slices, 226 );
            rec.workyr := Convert( slices, 227 );
            rec.wrkprev := Convert( slices, 228 );
            rec.month := Convert( slices, 229 );
            rec.hdqhrs := Convert( slices, 230 );
            rec.jobhours := Convert( slices, 231 );
            rec.sspsmpfg := Convert( slices, 232 );
            rec.ugrspay := Convert( slices, 233 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_0910;


   procedure Create_Maint_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.m := Convert( slices, 6 );
            rec.mrage := Convert( slices, 7 );
            rec.mramt := Convert( slices, 8 );
            rec.mrchwhy1 := Convert( slices, 9 );
            rec.mrchwhy2 := Convert( slices, 10 );
            rec.mrchwhy3 := Convert( slices, 11 );
            rec.mrchwhy4 := Convert( slices, 12 );
            rec.mrchwhy5 := Convert( slices, 13 );
            rec.mrchwhy6 := Convert( slices, 14 );
            rec.mrchwhy7 := Convert( slices, 15 );
            rec.mrchwhy8 := Convert( slices, 16 );
            rec.mrchwhy9 := Convert( slices, 17 );
            rec.mrct := Convert( slices, 18 );
            rec.mrkid := Convert( slices, 19 );
            rec.mrpd := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_0910;


   procedure Create_MortCont_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.outsamt := Convert( slices, 5 );
            rec.outsincl := Convert( slices, 6 );
            rec.outspay := Convert( slices, 7 );
            rec.outspd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_0910;


   procedure Create_Mortgage_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.exrent := Convert( slices, 10 );
            rec.incminc1 := Convert( slices, 11 );
            rec.incminc2 := Convert( slices, 12 );
            rec.incminc3 := Convert( slices, 13 );
            rec.incmp1 := Convert( slices, 14 );
            rec.incmp2 := Convert( slices, 15 );
            rec.incmp3 := Convert( slices, 16 );
            rec.incmpam1 := Convert( slices, 17 );
            rec.incmpam2 := Convert( slices, 18 );
            rec.incmpam3 := Convert( slices, 19 );
            rec.incmppd1 := Convert( slices, 20 );
            rec.incmppd2 := Convert( slices, 21 );
            rec.incmppd3 := Convert( slices, 22 );
            rec.incmsty1 := Convert( slices, 23 );
            rec.incmsty2 := Convert( slices, 24 );
            rec.incmsty3 := Convert( slices, 25 );
            rec.intprpay := Convert( slices, 26 );
            rec.intprpd := Convert( slices, 27 );
            rec.intru := Convert( slices, 28 );
            rec.intrupd := Convert( slices, 29 );
            rec.intrus := Convert( slices, 30 );
            rec.issue := Convert( slices, 31 );
            rec.loan2y := Convert( slices, 32 );
            rec.loanyear := Convert( slices, 33 );
            rec.menpol := Convert( slices, 34 );
            rec.morall := Convert( slices, 35 );
            rec.morflc := Convert( slices, 36 );
            rec.morinpay := Convert( slices, 37 );
            rec.morinpd := Convert( slices, 38 );
            rec.morinus := Convert( slices, 39 );
            rec.mortend := Convert( slices, 40 );
            rec.mortleft := Convert( slices, 41 );
            rec.mortprot := Convert( slices, 42 );
            rec.morttype := Convert( slices, 43 );
            rec.morupd := Convert( slices, 44 );
            rec.morus := Convert( slices, 45 );
            rec.mpcover1 := Convert( slices, 46 );
            rec.mpcover2 := Convert( slices, 47 );
            rec.mpcover3 := Convert( slices, 48 );
            rec.mpolno := Convert( slices, 49 );
            rec.outsmort := Convert( slices, 50 );
            rec.rentfrom := Convert( slices, 51 );
            rec.rmamt := Convert( slices, 52 );
            rec.rmort := Convert( slices, 53 );
            rec.rmortyr := Convert( slices, 54 );
            rec.rmpur001 := Convert( slices, 55 );
            rec.rmpur002 := Convert( slices, 56 );
            rec.rmpur003 := Convert( slices, 57 );
            rec.rmpur004 := Convert( slices, 58 );
            rec.rmpur005 := Convert( slices, 59 );
            rec.rmpur006 := Convert( slices, 60 );
            rec.rmpur007 := Convert( slices, 61 );
            rec.rmpur008 := Convert( slices, 62 );
            rec.month := Convert( slices, 63 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_0910;


   procedure Create_Nimigr_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Nimigr_IO.File_Type;
      rec         : Nimigr_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Nimigr_IO.Create (bin_file, Nimigr_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.miper := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.miage := Convert( slices, 4 );
            rec.misex := Convert( slices, 5 );
            rec.mnthleft := Convert( slices, 6 );
            rec.more1yr := Convert( slices, 7 );
            rec.wherenow := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( NimigrRec ).startPos = 0 ) then
               index.pointers( NimigrRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( NimigrRec ).counter := index.pointers( NimigrRec ).counter + 1;
            Put_Index( index_map, index );
            Nimigr_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Nimigr_IO.Close( bin_file );
   end Create_Nimigr_0910;


   procedure Create_OddJob_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.ojamt := Convert( slices, 7 );
            rec.ojnow := Convert( slices, 8 );
            rec.ojreg := Convert( slices, 9 );
            rec.month := Convert( slices, 10 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_0910;


   procedure Create_Owner_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.othmort1 := Convert( slices, 4 );
            rec.othmort2 := Convert( slices, 5 );
            rec.othmort3 := Convert( slices, 6 );
            rec.othpur1 := Convert( slices, 7 );
            rec.othpur2 := Convert( slices, 8 );
            rec.othpur3 := Convert( slices, 9 );
            rec.othpur31 := Convert( slices, 10 );
            rec.othpur32 := Convert( slices, 11 );
            rec.othpur33 := Convert( slices, 12 );
            rec.othpur34 := Convert( slices, 13 );
            rec.othpur35 := Convert( slices, 14 );
            rec.othpur36 := Convert( slices, 15 );
            rec.othpur37 := Convert( slices, 16 );
            rec.othpur4 := Convert( slices, 17 );
            rec.othpur5 := Convert( slices, 18 );
            rec.othpur6 := Convert( slices, 19 );
            rec.othpur7 := Convert( slices, 20 );
            rec.purcamt := Convert( slices, 21 );
            rec.purcloan := Convert( slices, 22 );
            rec.month := Convert( slices, 23 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_0910;


   procedure Create_PenAmt_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenAmt_IO.File_Type;
      rec         : PenAmt_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenAmt_IO.Create (bin_file, PenAmt_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.amttype := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.penq := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenAmtRec ).startPos = 0 ) then
               index.pointers( PenAmtRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenAmtRec ).counter := index.pointers( PenAmtRec ).counter + 1;
            Put_Index( index_map, index );
            PenAmt_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenAmt_IO.Close( bin_file );
   end Create_PenAmt_0910;


   procedure Create_PenProv_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppen := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eptype := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.penamt := Convert( slices, 8 );
            rec.penamtdt := Convert( slices, 9 );
            rec.penamtpd := Convert( slices, 10 );
            rec.penchk := Convert( slices, 11 );
            rec.pencon := Convert( slices, 12 );
            rec.pendat := Convert( slices, 13 );
            rec.penhelp := Convert( slices, 14 );
            rec.penreb := Convert( slices, 15 );
            rec.rebgov := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_0910;


   procedure Create_Pension_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.penoth := Convert( slices, 7 );
            rec.penpay := Convert( slices, 8 );
            rec.penpd := Convert( slices, 9 );
            rec.pentax := Convert( slices, 10 );
            rec.pentype := Convert( slices, 11 );
            rec.poamt := Convert( slices, 12 );
            rec.poinc := Convert( slices, 13 );
            rec.posour := Convert( slices, 14 );
            rec.ptamt := Convert( slices, 15 );
            rec.ptinc := Convert( slices, 16 );
            rec.trights := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_0910;


   procedure Create_RentCont_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_0910;


   procedure Create_Renter_0910( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbmnth := Convert( slices, 28 );
            rec.hbrecp := Convert( slices, 29 );
            rec.hbweeks := Convert( slices, 30 );
            rec.hbyear := Convert( slices, 31 );
            rec.hbyears := Convert( slices, 32 );
            rec.issue := Convert( slices, 33 );
            rec.landlord := Convert( slices, 34 );
            rec.lhaexs := Convert( slices, 35 );
            rec.lhalss := Convert( slices, 36 );
            rec.lowshort := Convert( slices, 37 );
            rec.niystart := Convert( slices, 38 );
            rec.othtype := Convert( slices, 39 );
            rec.rebate := Convert( slices, 40 );
            rec.rent := Convert( slices, 41 );
            rec.rentdk := Convert( slices, 42 );
            rec.rentdoc := Convert( slices, 43 );
            rec.rentfull := Convert( slices, 44 );
            rec.renthol := Convert( slices, 45 );
            rec.rentpd := Convert( slices, 46 );
            rec.resll := Convert( slices, 47 );
            rec.resll2 := Convert( slices, 48 );
            rec.serinc1 := Convert( slices, 49 );
            rec.serinc2 := Convert( slices, 50 );
            rec.serinc3 := Convert( slices, 51 );
            rec.serinc4 := Convert( slices, 52 );
            rec.serinc5 := Convert( slices, 53 );
            rec.tentype := Convert( slices, 54 );
            rec.weekhol := Convert( slices, 55 );
            rec.wsinc := Convert( slices, 56 );
            rec.wsincamt := Convert( slices, 57 );
            rec.ystartr := Convert( slices, 58 );
            rec.month := Convert( slices, 59 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_0910;


   procedure Create_Account_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Account_IO.File_Type;
      rec         : Account_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Account_IO.Create (bin_file, Account_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.account := Convert( slices, 4 );
            rec.accint := Convert( slices, 5 );
            rec.acctax := Convert( slices, 6 );
            rec.gtwtot := Convert( slices, 7 );
            rec.invtax := Convert( slices, 8 );
            rec.issue := Convert( slices, 9 );
            rec.nsamt := Convert( slices, 10 );
            rec.month := Convert( slices, 11 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AccountRec ).startPos = 0 ) then
               index.pointers( AccountRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AccountRec ).counter := index.pointers( AccountRec ).counter + 1;
            Put_Index( index_map, index );
            Account_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Account_IO.Close( bin_file );
   end Create_Account_1011;


   procedure Create_Admin_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Admin_IO.File_Type;
      rec         : Admin_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Admin_IO.Create (bin_file, Admin_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.findhh := Convert( slices, 2 );
            rec.hhsel := Convert( slices, 3 );
            rec.hout := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.lngdf01 := Convert( slices, 6 );
            rec.lngdf02 := Convert( slices, 7 );
            rec.lngdf03 := Convert( slices, 8 );
            rec.lngdf04 := Convert( slices, 9 );
            rec.lngdf05 := Convert( slices, 10 );
            rec.lngdf06 := Convert( slices, 11 );
            rec.lngdf07 := Convert( slices, 12 );
            rec.lngdf08 := Convert( slices, 13 );
            rec.lngdf09 := Convert( slices, 14 );
            rec.lngdf10 := Convert( slices, 15 );
            rec.lngdf11 := Convert( slices, 16 );
            rec.ncr1 := Convert( slices, 17 );
            rec.ncr2 := Convert( slices, 18 );
            rec.ncr3 := Convert( slices, 19 );
            rec.ncr4 := Convert( slices, 20 );
            rec.ncr5 := Convert( slices, 21 );
            rec.ncr6 := Convert( slices, 22 );
            rec.ncr7 := Convert( slices, 23 );
            rec.nmtrans := Convert( slices, 24 );
            rec.noneng := Convert( slices, 25 );
            rec.refr01 := Convert( slices, 26 );
            rec.refr02 := Convert( slices, 27 );
            rec.refr03 := Convert( slices, 28 );
            rec.refr04 := Convert( slices, 29 );
            rec.refr05 := Convert( slices, 30 );
            rec.refr06 := Convert( slices, 31 );
            rec.refr07 := Convert( slices, 32 );
            rec.refr08 := Convert( slices, 33 );
            rec.refr09 := Convert( slices, 34 );
            rec.refr10 := Convert( slices, 35 );
            rec.refr11 := Convert( slices, 36 );
            rec.refr12 := Convert( slices, 37 );
            rec.refr13 := Convert( slices, 38 );
            rec.refr14 := Convert( slices, 39 );
            rec.refr15 := Convert( slices, 40 );
            rec.refr16 := Convert( slices, 41 );
            rec.refr17 := Convert( slices, 42 );
            rec.refr18 := Convert( slices, 43 );
            rec.tnc := Convert( slices, 44 );
            rec.version := Convert( slices, 45 );
            rec.whlang01 := Convert( slices, 46 );
            rec.whlang02 := Convert( slices, 47 );
            rec.whlang03 := Convert( slices, 48 );
            rec.whlang04 := Convert( slices, 49 );
            rec.whlang05 := Convert( slices, 50 );
            rec.whlang06 := Convert( slices, 51 );
            rec.whlang07 := Convert( slices, 52 );
            rec.whlang08 := Convert( slices, 53 );
            rec.whlang09 := Convert( slices, 54 );
            rec.whlang10 := Convert( slices, 55 );
            rec.whlang11 := Convert( slices, 56 );
            rec.whotran1 := Convert( slices, 57 );
            rec.whotran2 := Convert( slices, 58 );
            rec.whotran3 := Convert( slices, 59 );
            rec.whotran4 := Convert( slices, 60 );
            rec.whotran5 := Convert( slices, 61 );
            rec.month := Convert( slices, 62 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdminRec ).startPos = 0 ) then
               index.pointers( AdminRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdminRec ).counter := index.pointers( AdminRec ).counter + 1;
            Put_Index( index_map, index );
            Admin_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Admin_IO.Close( bin_file );
   end Create_Admin_1011;


   procedure Create_Adult_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Adult_IO.File_Type;
      rec         : Adult_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Adult_IO.Create (bin_file, Adult_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.abs1no := Convert( slices, 4 );
            rec.abs2no := Convert( slices, 5 );
            rec.abspar := Convert( slices, 6 );
            rec.abspay := Convert( slices, 7 );
            rec.abswhy := Convert( slices, 8 );
            rec.abswk := Convert( slices, 9 );
            rec.x_access := Convert( slices, 10 );
            rec.accftpt := Convert( slices, 11 );
            rec.accjb := Convert( slices, 12 );
            rec.accountq := Convert( slices, 13 );
            rec.accssamt := Convert( slices, 14 );
            rec.accsspd := Convert( slices, 15 );
            rec.adeduc := Convert( slices, 16 );
            rec.adema := Convert( slices, 17 );
            rec.ademaamt := Convert( slices, 18 );
            rec.ademapd := Convert( slices, 19 );
            rec.age := Convert( slices, 20 );
            rec.alg := Convert( slices, 21 );
            rec.algamt := Convert( slices, 22 );
            rec.algpd := Convert( slices, 23 );
            rec.aliamt := Convert( slices, 24 );
            rec.alimny := Convert( slices, 25 );
            rec.alipd := Convert( slices, 26 );
            rec.alius := Convert( slices, 27 );
            rec.allow1 := Convert( slices, 28 );
            rec.allow2 := Convert( slices, 29 );
            rec.allow3 := Convert( slices, 30 );
            rec.allow4 := Convert( slices, 31 );
            rec.allpay1 := Convert( slices, 32 );
            rec.allpay2 := Convert( slices, 33 );
            rec.allpay3 := Convert( slices, 34 );
            rec.allpay4 := Convert( slices, 35 );
            rec.allpd1 := Convert( slices, 36 );
            rec.allpd2 := Convert( slices, 37 );
            rec.allpd3 := Convert( slices, 38 );
            rec.allpd4 := Convert( slices, 39 );
            rec.aluamt := Convert( slices, 40 );
            rec.alupd := Convert( slices, 41 );
            rec.anyacc := Convert( slices, 42 );
            rec.anyed := Convert( slices, 43 );
            rec.anymon := Convert( slices, 44 );
            rec.anypen1 := Convert( slices, 45 );
            rec.anypen2 := Convert( slices, 46 );
            rec.anypen3 := Convert( slices, 47 );
            rec.anypen4 := Convert( slices, 48 );
            rec.anypen5 := Convert( slices, 49 );
            rec.anypen6 := Convert( slices, 50 );
            rec.anypen7 := Convert( slices, 51 );
            rec.apamt := Convert( slices, 52 );
            rec.apdamt := Convert( slices, 53 );
            rec.apdir := Convert( slices, 54 );
            rec.apdpd := Convert( slices, 55 );
            rec.appd := Convert( slices, 56 );
            rec.b2qfut1 := Convert( slices, 57 );
            rec.b2qfut2 := Convert( slices, 58 );
            rec.b2qfut3 := Convert( slices, 59 );
            rec.b3qfut1 := Convert( slices, 60 );
            rec.b3qfut2 := Convert( slices, 61 );
            rec.b3qfut3 := Convert( slices, 62 );
            rec.b3qfut4 := Convert( slices, 63 );
            rec.b3qfut5 := Convert( slices, 64 );
            rec.b3qfut6 := Convert( slices, 65 );
            rec.b3qfut7 := Convert( slices, 66 );
            rec.ben1q1 := Convert( slices, 67 );
            rec.ben1q2 := Convert( slices, 68 );
            rec.ben1q3 := Convert( slices, 69 );
            rec.ben1q4 := Convert( slices, 70 );
            rec.ben1q5 := Convert( slices, 71 );
            rec.ben1q6 := Convert( slices, 72 );
            rec.ben1q7 := Convert( slices, 73 );
            rec.ben2q1 := Convert( slices, 74 );
            rec.ben2q2 := Convert( slices, 75 );
            rec.ben2q3 := Convert( slices, 76 );
            rec.ben3q1 := Convert( slices, 77 );
            rec.ben3q2 := Convert( slices, 78 );
            rec.ben3q3 := Convert( slices, 79 );
            rec.ben3q4 := Convert( slices, 80 );
            rec.ben3q5 := Convert( slices, 81 );
            rec.ben3q6 := Convert( slices, 82 );
            rec.ben3q7 := Convert( slices, 83 );
            rec.ben4q1 := Convert( slices, 84 );
            rec.ben4q2 := Convert( slices, 85 );
            rec.ben4q3 := Convert( slices, 86 );
            rec.ben4q4 := Convert( slices, 87 );
            rec.ben5q1 := Convert( slices, 88 );
            rec.ben5q2 := Convert( slices, 89 );
            rec.ben5q3 := Convert( slices, 90 );
            rec.ben5q4 := Convert( slices, 91 );
            rec.ben5q5 := Convert( slices, 92 );
            rec.ben5q6 := Convert( slices, 93 );
            rec.ben5q7 := Convert( slices, 94 );
            rec.ben7q1 := Convert( slices, 95 );
            rec.ben7q2 := Convert( slices, 96 );
            rec.ben7q3 := Convert( slices, 97 );
            rec.ben7q4 := Convert( slices, 98 );
            rec.ben7q5 := Convert( slices, 99 );
            rec.ben7q6 := Convert( slices, 100 );
            rec.ben7q7 := Convert( slices, 101 );
            rec.ben7q8 := Convert( slices, 102 );
            rec.ben7q9 := Convert( slices, 103 );
            rec.camemt := Convert( slices, 104 );
            rec.cameyr := Convert( slices, 105 );
            rec.cameyr2 := Convert( slices, 106 );
            rec.cbaamt := Convert( slices, 107 );
            rec.chkctc := Convert( slices, 108 );
            rec.chkdpco1 := Convert( slices, 109 );
            rec.chkdpco2 := Convert( slices, 110 );
            rec.chkdpco3 := Convert( slices, 111 );
            rec.chkdpn := Convert( slices, 112 );
            rec.chkdsco1 := Convert( slices, 113 );
            rec.chkdsco2 := Convert( slices, 114 );
            rec.chkdsco3 := Convert( slices, 115 );
            rec.chknop := Convert( slices, 116 );
            rec.claimant := Convert( slices, 117 );
            rec.cohabit := Convert( slices, 118 );
            rec.combid := Convert( slices, 119 );
            rec.contuk := Convert( slices, 120 );
            rec.convbl := Convert( slices, 121 );
            rec.corign := Convert( slices, 122 );
            rec.ctclum1 := Convert( slices, 123 );
            rec.ctclum2 := Convert( slices, 124 );
            rec.cupchk := Convert( slices, 125 );
            rec.cvht := Convert( slices, 126 );
            rec.cvpay := Convert( slices, 127 );
            rec.cvpd := Convert( slices, 128 );
            rec.ddaprog := Convert( slices, 129 );
            rec.ddatre := Convert( slices, 130 );
            rec.ddatrep := Convert( slices, 131 );
            rec.defrpen := Convert( slices, 132 );
            rec.depend := Convert( slices, 133 );
            rec.disdif1 := Convert( slices, 134 );
            rec.disdif2 := Convert( slices, 135 );
            rec.disdif3 := Convert( slices, 136 );
            rec.disdif4 := Convert( slices, 137 );
            rec.disdif5 := Convert( slices, 138 );
            rec.disdif6 := Convert( slices, 139 );
            rec.disdif7 := Convert( slices, 140 );
            rec.disdif8 := Convert( slices, 141 );
            rec.disdif9 := Convert( slices, 142 );
            rec.disdifp := Convert( slices, 143 );
            rec.dob := Convert( slices, 144 );
            rec.dv09pens := Convert( slices, 145 );
            rec.dvil03a := Convert( slices, 146 );
            rec.dvil04a := Convert( slices, 147 );
            rec.dvjb12ml := Convert( slices, 148 );
            rec.dvmardf := Convert( slices, 149 );
            rec.ed1amt := Convert( slices, 150 );
            rec.ed1borr := Convert( slices, 151 );
            rec.ed1pd := Convert( slices, 152 );
            rec.ed1sum := Convert( slices, 153 );
            rec.ed2amt := Convert( slices, 154 );
            rec.ed2borr := Convert( slices, 155 );
            rec.ed2pd := Convert( slices, 156 );
            rec.ed2sum := Convert( slices, 157 );
            rec.edatt := Convert( slices, 158 );
            rec.edhr := Convert( slices, 159 );
            rec.edtyp := Convert( slices, 160 );
            rec.eligadlt := Convert( slices, 161 );
            rec.eligchld := Convert( slices, 162 );
            rec.eligschm := Convert( slices, 163 );
            rec.emparr := Convert( slices, 164 );
            rec.emppen := Convert( slices, 165 );
            rec.empschm := Convert( slices, 166 );
            rec.empstat := Convert( slices, 167 );
            rec.es2000 := Convert( slices, 168 );
            rec.ethgrp := Convert( slices, 169 );
            rec.everwrk := Convert( slices, 170 );
            rec.exthbct1 := Convert( slices, 171 );
            rec.exthbct2 := Convert( slices, 172 );
            rec.exthbct3 := Convert( slices, 173 );
            rec.followup := Convert( slices, 174 );
            rec.fted := Convert( slices, 175 );
            rec.ftwk := Convert( slices, 176 );
            rec.govpis := Convert( slices, 177 );
            rec.govpjsa := Convert( slices, 178 );
            rec.grant := Convert( slices, 179 );
            rec.grtamt1 := Convert( slices, 180 );
            rec.grtamt2 := Convert( slices, 181 );
            rec.grtdir1 := Convert( slices, 182 );
            rec.grtdir2 := Convert( slices, 183 );
            rec.grtnum := Convert( slices, 184 );
            rec.grtsce1 := Convert( slices, 185 );
            rec.grtsce2 := Convert( slices, 186 );
            rec.grtval1 := Convert( slices, 187 );
            rec.grtval2 := Convert( slices, 188 );
            rec.gta := Convert( slices, 189 );
            rec.health := Convert( slices, 190 );
            rec.hholder := Convert( slices, 191 );
            rec.hi1qual1 := Convert( slices, 192 );
            rec.hi1qual2 := Convert( slices, 193 );
            rec.hi1qual3 := Convert( slices, 194 );
            rec.hi1qual4 := Convert( slices, 195 );
            rec.hi1qual5 := Convert( slices, 196 );
            rec.hi1qual6 := Convert( slices, 197 );
            rec.hi2qual := Convert( slices, 198 );
            rec.hprob := Convert( slices, 199 );
            rec.hrpid := Convert( slices, 200 );
            rec.hsvper := Convert( slices, 201 );
            rec.incdur := Convert( slices, 202 );
            rec.injlong := Convert( slices, 203 );
            rec.injwk := Convert( slices, 204 );
            rec.invests := Convert( slices, 205 );
            rec.iout := Convert( slices, 206 );
            rec.isa1type := Convert( slices, 207 );
            rec.isa2type := Convert( slices, 208 );
            rec.issue := Convert( slices, 209 );
            rec.jobaway := Convert( slices, 210 );
            rec.lareg := Convert( slices, 211 );
            rec.likewk := Convert( slices, 212 );
            rec.lktime := Convert( slices, 213 );
            rec.lnkdwp := Convert( slices, 214 );
            rec.lnkref01 := Convert( slices, 215 );
            rec.lnkref02 := Convert( slices, 216 );
            rec.lnkref03 := Convert( slices, 217 );
            rec.lnkref04 := Convert( slices, 218 );
            rec.lnkref05 := Convert( slices, 219 );
            rec.lnkref06 := Convert( slices, 220 );
            rec.lnkref07 := Convert( slices, 221 );
            rec.lnkref08 := Convert( slices, 222 );
            rec.lnkref09 := Convert( slices, 223 );
            rec.lnkref10 := Convert( slices, 224 );
            rec.lnkref11 := Convert( slices, 225 );
            rec.loan := Convert( slices, 226 );
            rec.loannum := Convert( slices, 227 );
            rec.look := Convert( slices, 228 );
            rec.lookwk := Convert( slices, 229 );
            rec.lstwrk1 := Convert( slices, 230 );
            rec.lstwrk2 := Convert( slices, 231 );
            rec.lstyr := Convert( slices, 232 );
            rec.mednum := Convert( slices, 233 );
            rec.medprpd := Convert( slices, 234 );
            rec.medprpy := Convert( slices, 235 );
            rec.memschm := Convert( slices, 236 );
            rec.mntamt1 := Convert( slices, 237 );
            rec.mntamt2 := Convert( slices, 238 );
            rec.mntarr1 := Convert( slices, 239 );
            rec.mntarr2 := Convert( slices, 240 );
            rec.mntarr3 := Convert( slices, 241 );
            rec.mntarr4 := Convert( slices, 242 );
            rec.mntgov1 := Convert( slices, 243 );
            rec.mntgov2 := Convert( slices, 244 );
            rec.mntnrp := Convert( slices, 245 );
            rec.mntpay := Convert( slices, 246 );
            rec.mntpd1 := Convert( slices, 247 );
            rec.mntpd2 := Convert( slices, 248 );
            rec.mntrec := Convert( slices, 249 );
            rec.mntus1 := Convert( slices, 250 );
            rec.mntus2 := Convert( slices, 251 );
            rec.mntusam1 := Convert( slices, 252 );
            rec.mntusam2 := Convert( slices, 253 );
            rec.mntuspd1 := Convert( slices, 254 );
            rec.mntuspd2 := Convert( slices, 255 );
            rec.ms := Convert( slices, 256 );
            rec.natid1 := Convert( slices, 257 );
            rec.natid2 := Convert( slices, 258 );
            rec.natid3 := Convert( slices, 259 );
            rec.natid4 := Convert( slices, 260 );
            rec.natid5 := Convert( slices, 261 );
            rec.natid6 := Convert( slices, 262 );
            rec.ndeal := Convert( slices, 263 );
            rec.newdtype := Convert( slices, 264 );
            rec.niamt := Convert( slices, 265 );
            rec.niethgrp := Convert( slices, 266 );
            rec.niexthbb := Convert( slices, 267 );
            rec.ninatid1 := Convert( slices, 268 );
            rec.ninatid2 := Convert( slices, 269 );
            rec.ninatid3 := Convert( slices, 270 );
            rec.ninatid4 := Convert( slices, 271 );
            rec.ninatid5 := Convert( slices, 272 );
            rec.ninatid6 := Convert( slices, 273 );
            rec.ninatid7 := Convert( slices, 274 );
            rec.ninatid8 := Convert( slices, 275 );
            rec.nipd := Convert( slices, 276 );
            rec.nireg := Convert( slices, 277 );
            rec.nirel := Convert( slices, 278 );
            rec.nitrain := Convert( slices, 279 );
            rec.nlper := Convert( slices, 280 );
            rec.nolk1 := Convert( slices, 281 );
            rec.nolk2 := Convert( slices, 282 );
            rec.nolk3 := Convert( slices, 283 );
            rec.nolook := Convert( slices, 284 );
            rec.nowant := Convert( slices, 285 );
            rec.nssec := Convert( slices, 286 );
            rec.numjob := Convert( slices, 287 );
            rec.numjob2 := Convert( slices, 288 );
            rec.oddjob := Convert( slices, 289 );
            rec.oldstud := Convert( slices, 290 );
            rec.otabspar := Convert( slices, 291 );
            rec.otamt := Convert( slices, 292 );
            rec.otapamt := Convert( slices, 293 );
            rec.otappd := Convert( slices, 294 );
            rec.othqual1 := Convert( slices, 295 );
            rec.othqual2 := Convert( slices, 296 );
            rec.othqual3 := Convert( slices, 297 );
            rec.othtax := Convert( slices, 298 );
            rec.otinva := Convert( slices, 299 );
            rec.pareamt := Convert( slices, 300 );
            rec.parepd := Convert( slices, 301 );
            rec.penflag := Convert( slices, 302 );
            rec.penlump := Convert( slices, 303 );
            rec.perspen1 := Convert( slices, 304 );
            rec.perspen2 := Convert( slices, 305 );
            rec.ppchk1 := Convert( slices, 306 );
            rec.ppchk2 := Convert( slices, 307 );
            rec.ppchk3 := Convert( slices, 308 );
            rec.ppnumc := Convert( slices, 309 );
            rec.practice := Convert( slices, 310 );
            rec.privpen := Convert( slices, 311 );
            rec.ptwk := Convert( slices, 312 );
            rec.r01 := Convert( slices, 313 );
            rec.r02 := Convert( slices, 314 );
            rec.r03 := Convert( slices, 315 );
            rec.r04 := Convert( slices, 316 );
            rec.r05 := Convert( slices, 317 );
            rec.r06 := Convert( slices, 318 );
            rec.r07 := Convert( slices, 319 );
            rec.r08 := Convert( slices, 320 );
            rec.r09 := Convert( slices, 321 );
            rec.r10 := Convert( slices, 322 );
            rec.r11 := Convert( slices, 323 );
            rec.r12 := Convert( slices, 324 );
            rec.r13 := Convert( slices, 325 );
            rec.r14 := Convert( slices, 326 );
            rec.redamt := Convert( slices, 327 );
            rec.redany := Convert( slices, 328 );
            rec.rentprof := Convert( slices, 329 );
            rec.retire := Convert( slices, 330 );
            rec.retire1 := Convert( slices, 331 );
            rec.retreas := Convert( slices, 332 );
            rec.royal1 := Convert( slices, 333 );
            rec.royal2 := Convert( slices, 334 );
            rec.royal3 := Convert( slices, 335 );
            rec.royal4 := Convert( slices, 336 );
            rec.royyr1 := Convert( slices, 337 );
            rec.royyr2 := Convert( slices, 338 );
            rec.royyr3 := Convert( slices, 339 );
            rec.royyr4 := Convert( slices, 340 );
            rec.rstrct := Convert( slices, 341 );
            rec.schchk := Convert( slices, 342 );
            rec.sex := Convert( slices, 343 );
            rec.sflntyp1 := Convert( slices, 344 );
            rec.sflntyp2 := Convert( slices, 345 );
            rec.sfrpis := Convert( slices, 346 );
            rec.sfrpjsa := Convert( slices, 347 );
            rec.sftype1 := Convert( slices, 348 );
            rec.sftype2 := Convert( slices, 349 );
            rec.sic := Convert( slices, 350 );
            rec.slrepamt := Convert( slices, 351 );
            rec.slrepay := Convert( slices, 352 );
            rec.slreppd := Convert( slices, 353 );
            rec.soc2000 := Convert( slices, 354 );
            rec.spcreg1 := Convert( slices, 355 );
            rec.spcreg2 := Convert( slices, 356 );
            rec.spcreg3 := Convert( slices, 357 );
            rec.spnumc := Convert( slices, 358 );
            rec.spout := Convert( slices, 359 );
            rec.spyrot := Convert( slices, 360 );
            rec.srentamt := Convert( slices, 361 );
            rec.srentpd := Convert( slices, 362 );
            rec.stakep := Convert( slices, 363 );
            rec.start := Convert( slices, 364 );
            rec.taxcred1 := Convert( slices, 365 );
            rec.taxcred2 := Convert( slices, 366 );
            rec.taxfut := Convert( slices, 367 );
            rec.tcever1 := Convert( slices, 368 );
            rec.tcever2 := Convert( slices, 369 );
            rec.tcrepay1 := Convert( slices, 370 );
            rec.tcrepay2 := Convert( slices, 371 );
            rec.tcrepay3 := Convert( slices, 372 );
            rec.tcrepay4 := Convert( slices, 373 );
            rec.tcrepay5 := Convert( slices, 374 );
            rec.tcrepay6 := Convert( slices, 375 );
            rec.tcthsyr1 := Convert( slices, 376 );
            rec.tcthsyr2 := Convert( slices, 377 );
            rec.tdaywrk := Convert( slices, 378 );
            rec.tea := Convert( slices, 379 );
            rec.tea9697 := Convert( slices, 380 );
            rec.topupl := Convert( slices, 381 );
            rec.totint := Convert( slices, 382 );
            rec.train := Convert( slices, 383 );
            rec.trainee := Convert( slices, 384 );
            rec.ttbprx := Convert( slices, 385 );
            rec.tuborr := Convert( slices, 386 );
            rec.typeed := Convert( slices, 387 );
            rec.unpaid1 := Convert( slices, 388 );
            rec.unpaid2 := Convert( slices, 389 );
            rec.w1 := Convert( slices, 390 );
            rec.w2 := Convert( slices, 391 );
            rec.wait := Convert( slices, 392 );
            rec.war1 := Convert( slices, 393 );
            rec.war2 := Convert( slices, 394 );
            rec.whoresp := Convert( slices, 395 );
            rec.whosectb := Convert( slices, 396 );
            rec.wintfuel := Convert( slices, 397 );
            rec.working := Convert( slices, 398 );
            rec.wpa := Convert( slices, 399 );
            rec.wpba := Convert( slices, 400 );
            rec.wtclum1 := Convert( slices, 401 );
            rec.wtclum2 := Convert( slices, 402 );
            rec.ystrtwk := Convert( slices, 403 );
            rec.month := Convert( slices, 404 );
            rec.able := Convert( slices, 405 );
            rec.actacci := Convert( slices, 406 );
            rec.addda := Convert( slices, 407 );
            rec.age80 := Convert( slices, 408 );
            rec.basacti := Convert( slices, 409 );
            rec.careab := Convert( slices, 410 );
            rec.careah := Convert( slices, 411 );
            rec.carecb := Convert( slices, 412 );
            rec.carech := Convert( slices, 413 );
            rec.carecl := Convert( slices, 414 );
            rec.carefl := Convert( slices, 415 );
            rec.carefr := Convert( slices, 416 );
            rec.careot := Convert( slices, 417 );
            rec.carere := Convert( slices, 418 );
            rec.chbflg := Convert( slices, 419 );
            rec.curacti := Convert( slices, 420 );
            rec.currjobm := Convert( slices, 421 );
            rec.disdifad := Convert( slices, 422 );
            rec.empoccp := Convert( slices, 423 );
            rec.empstatb := Convert( slices, 424 );
            rec.empstatc := Convert( slices, 425 );
            rec.empstati := Convert( slices, 426 );
            rec.ethgr2 := Convert( slices, 427 );
            rec.gebacti := Convert( slices, 428 );
            rec.giltcti := Convert( slices, 429 );
            rec.gross3 := Convert( slices, 430 );
            rec.hdage := Convert( slices, 431 );
            rec.hdben := Convert( slices, 432 );
            rec.hdindinc := Convert( slices, 433 );
            rec.heartval := Convert( slices, 434 );
            rec.hourab := Convert( slices, 435 );
            rec.hourah := Convert( slices, 436 );
            rec.hourcare := Convert( slices, 437 );
            rec.hourcb := Convert( slices, 438 );
            rec.hourch := Convert( slices, 439 );
            rec.hourcl := Convert( slices, 440 );
            rec.hourfr := Convert( slices, 441 );
            rec.hourot := Convert( slices, 442 );
            rec.hourre := Convert( slices, 443 );
            rec.hourtot := Convert( slices, 444 );
            rec.hperson := Convert( slices, 445 );
            rec.iagegr2 := Convert( slices, 446 );
            rec.iagegr3 := Convert( slices, 447 );
            rec.iagegr4 := Convert( slices, 448 );
            rec.iagegrp := Convert( slices, 449 );
            rec.incseo2 := Convert( slices, 450 );
            rec.indinc := Convert( slices, 451 );
            rec.indisben := Convert( slices, 452 );
            rec.inearns := Convert( slices, 453 );
            rec.ininv := Convert( slices, 454 );
            rec.inirben := Convert( slices, 455 );
            rec.innirben := Convert( slices, 456 );
            rec.inothben := Convert( slices, 457 );
            rec.inpeninc := Convert( slices, 458 );
            rec.inrinc := Convert( slices, 459 );
            rec.inrpinc := Convert( slices, 460 );
            rec.intvlic := Convert( slices, 461 );
            rec.intxcred := Convert( slices, 462 );
            rec.isacti := Convert( slices, 463 );
            rec.marital := Convert( slices, 464 );
            rec.mjobsect := Convert( slices, 465 );
            rec.nincseo2 := Convert( slices, 466 );
            rec.nindinc := Convert( slices, 467 );
            rec.ninearns := Convert( slices, 468 );
            rec.nininv := Convert( slices, 469 );
            rec.ninpenin := Convert( slices, 470 );
            rec.ninsein2 := Convert( slices, 471 );
            rec.nirel2 := Convert( slices, 472 );
            rec.occupnum := Convert( slices, 473 );
            rec.pepscti := Convert( slices, 474 );
            rec.poaccti := Convert( slices, 475 );
            rec.pocardi := Convert( slices, 476 );
            rec.prevjobm := Convert( slices, 477 );
            rec.relhrp := Convert( slices, 478 );
            rec.sapadj := Convert( slices, 479 );
            rec.seincam2 := Convert( slices, 480 );
            rec.smpadj := Convert( slices, 481 );
            rec.sppadj := Convert( slices, 482 );
            rec.sspadj := Convert( slices, 483 );
            rec.stshcti := Convert( slices, 484 );
            rec.taxpayer := Convert( slices, 485 );
            rec.tesscti := Convert( slices, 486 );
            rec.totgrant := Convert( slices, 487 );
            rec.tothours := Convert( slices, 488 );
            rec.totoccp := Convert( slices, 489 );
            rec.untrcti := Convert( slices, 490 );
            rec.uperson := Convert( slices, 491 );
            rec.widoccp := Convert( slices, 492 );
            rec.xbonflag := Convert( slices, 493 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AdultRec ).startPos = 0 ) then
               index.pointers( AdultRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AdultRec ).counter := index.pointers( AdultRec ).counter + 1;
            Put_Index( index_map, index );
            Adult_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Adult_IO.Close( bin_file );
   end Create_Adult_1011;


   procedure Create_Asset_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Asset_IO.File_Type;
      rec         : Asset_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Asset_IO.Create (bin_file, Asset_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.assetype := Convert( slices, 4 );
            rec.seq := Convert( slices, 5 );
            rec.accname := Convert( slices, 6 );
            rec.amount := Convert( slices, 7 );
            rec.anymon := Convert( slices, 8 );
            rec.howmany := Convert( slices, 9 );
            rec.howmuch := Convert( slices, 10 );
            rec.howmuche := Convert( slices, 11 );
            rec.intro := Convert( slices, 12 );
            rec.issue := Convert( slices, 13 );
            rec.issval := Convert( slices, 14 );
            rec.pd := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( AssetRec ).startPos = 0 ) then
               index.pointers( AssetRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( AssetRec ).counter := index.pointers( AssetRec ).counter + 1;
            Put_Index( index_map, index );
            Asset_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Asset_IO.Close( bin_file );
   end Create_Asset_1011;


   procedure Create_Benefit_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benefit_IO.File_Type;
      rec         : Benefit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benefit_IO.Create (bin_file, Benefit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.bankstmt := Convert( slices, 5 );
            rec.benamt := Convert( slices, 6 );
            rec.benamtdk := Convert( slices, 7 );
            rec.benlettr := Convert( slices, 8 );
            rec.benpd := Convert( slices, 9 );
            rec.cctc := Convert( slices, 10 );
            rec.combamt := Convert( slices, 11 );
            rec.combpd := Convert( slices, 12 );
            rec.howben := Convert( slices, 13 );
            rec.issue := Convert( slices, 14 );
            rec.notusamt := Convert( slices, 15 );
            rec.notuspd := Convert( slices, 16 );
            rec.numweeks := Convert( slices, 17 );
            rec.numyears := Convert( slices, 18 );
            rec.pres := Convert( slices, 19 );
            rec.usual := Convert( slices, 20 );
            rec.var1 := Convert( slices, 21 );
            rec.var2 := Convert( slices, 22 );
            rec.var3 := Convert( slices, 23 );
            rec.whorec1 := Convert( slices, 24 );
            rec.whorec2 := Convert( slices, 25 );
            rec.whorec3 := Convert( slices, 26 );
            rec.whorec4 := Convert( slices, 27 );
            rec.whorec5 := Convert( slices, 28 );
            rec.month := Convert( slices, 29 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenefitRec ).startPos = 0 ) then
               index.pointers( BenefitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenefitRec ).counter := index.pointers( BenefitRec ).counter + 1;
            Put_Index( index_map, index );
            Benefit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benefit_IO.Close( bin_file );
   end Create_Benefit_1011;


   procedure Create_Benunit_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Benunit_IO.File_Type;
      rec         : Benunit_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Benunit_IO.Create (bin_file, Benunit_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.adbtbl := Convert( slices, 3 );
            rec.adddec := Convert( slices, 4 );
            rec.addeples := Convert( slices, 5 );
            rec.addhol := Convert( slices, 6 );
            rec.addins := Convert( slices, 7 );
            rec.addmel := Convert( slices, 8 );
            rec.addmon := Convert( slices, 9 );
            rec.addshoe := Convert( slices, 10 );
            rec.adepfur := Convert( slices, 11 );
            rec.af1 := Convert( slices, 12 );
            rec.afdep2 := Convert( slices, 13 );
            rec.billnt1 := Convert( slices, 14 );
            rec.billnt2 := Convert( slices, 15 );
            rec.billnt3 := Convert( slices, 16 );
            rec.billnt4 := Convert( slices, 17 );
            rec.billnt5 := Convert( slices, 18 );
            rec.billnt6 := Convert( slices, 19 );
            rec.billnt7 := Convert( slices, 20 );
            rec.billnt8 := Convert( slices, 21 );
            rec.billnt9 := Convert( slices, 22 );
            rec.cdelply := Convert( slices, 23 );
            rec.cdepact := Convert( slices, 24 );
            rec.cdepbed := Convert( slices, 25 );
            rec.cdepcel := Convert( slices, 26 );
            rec.cdepeqp := Convert( slices, 27 );
            rec.cdephol := Convert( slices, 28 );
            rec.cdeples := Convert( slices, 29 );
            rec.cdepsum := Convert( slices, 30 );
            rec.cdeptea := Convert( slices, 31 );
            rec.cdeptrp := Convert( slices, 32 );
            rec.cdepveg := Convert( slices, 33 );
            rec.cdpcoat := Convert( slices, 34 );
            rec.coatnt1 := Convert( slices, 35 );
            rec.coatnt2 := Convert( slices, 36 );
            rec.coatnt3 := Convert( slices, 37 );
            rec.coatnt4 := Convert( slices, 38 );
            rec.coatnt5 := Convert( slices, 39 );
            rec.coatnt6 := Convert( slices, 40 );
            rec.coatnt7 := Convert( slices, 41 );
            rec.coatnt8 := Convert( slices, 42 );
            rec.coatnt9 := Convert( slices, 43 );
            rec.cooknt1 := Convert( slices, 44 );
            rec.cooknt2 := Convert( slices, 45 );
            rec.cooknt3 := Convert( slices, 46 );
            rec.cooknt4 := Convert( slices, 47 );
            rec.cooknt5 := Convert( slices, 48 );
            rec.cooknt6 := Convert( slices, 49 );
            rec.cooknt7 := Convert( slices, 50 );
            rec.cooknt8 := Convert( slices, 51 );
            rec.cooknt9 := Convert( slices, 52 );
            rec.cplay := Convert( slices, 53 );
            rec.dampnt1 := Convert( slices, 54 );
            rec.dampnt2 := Convert( slices, 55 );
            rec.dampnt3 := Convert( slices, 56 );
            rec.dampnt4 := Convert( slices, 57 );
            rec.dampnt5 := Convert( slices, 58 );
            rec.dampnt6 := Convert( slices, 59 );
            rec.dampnt7 := Convert( slices, 60 );
            rec.dampnt8 := Convert( slices, 61 );
            rec.dampnt9 := Convert( slices, 62 );
            rec.debt1 := Convert( slices, 63 );
            rec.debt2 := Convert( slices, 64 );
            rec.debt3 := Convert( slices, 65 );
            rec.debt4 := Convert( slices, 66 );
            rec.debt5 := Convert( slices, 67 );
            rec.debt6 := Convert( slices, 68 );
            rec.debt7 := Convert( slices, 69 );
            rec.debt8 := Convert( slices, 70 );
            rec.debt9 := Convert( slices, 71 );
            rec.frndnt1 := Convert( slices, 72 );
            rec.frndnt2 := Convert( slices, 73 );
            rec.frndnt3 := Convert( slices, 74 );
            rec.frndnt4 := Convert( slices, 75 );
            rec.frndnt5 := Convert( slices, 76 );
            rec.frndnt6 := Convert( slices, 77 );
            rec.frndnt7 := Convert( slices, 78 );
            rec.frndnt8 := Convert( slices, 79 );
            rec.frndnt9 := Convert( slices, 80 );
            rec.hairnt1 := Convert( slices, 81 );
            rec.hairnt2 := Convert( slices, 82 );
            rec.hairnt3 := Convert( slices, 83 );
            rec.hairnt4 := Convert( slices, 84 );
            rec.hairnt5 := Convert( slices, 85 );
            rec.hairnt6 := Convert( slices, 86 );
            rec.hairnt7 := Convert( slices, 87 );
            rec.hairnt8 := Convert( slices, 88 );
            rec.hairnt9 := Convert( slices, 89 );
            rec.hbolng := Convert( slices, 90 );
            rec.hbothamt := Convert( slices, 91 );
            rec.hbothbu := Convert( slices, 92 );
            rec.hbothmn := Convert( slices, 93 );
            rec.hbothpd := Convert( slices, 94 );
            rec.hbothwk := Convert( slices, 95 );
            rec.hbothyr := Convert( slices, 96 );
            rec.hbotwait := Convert( slices, 97 );
            rec.heatnt1 := Convert( slices, 98 );
            rec.heatnt2 := Convert( slices, 99 );
            rec.heatnt3 := Convert( slices, 100 );
            rec.heatnt4 := Convert( slices, 101 );
            rec.heatnt5 := Convert( slices, 102 );
            rec.heatnt6 := Convert( slices, 103 );
            rec.heatnt7 := Convert( slices, 104 );
            rec.heatnt8 := Convert( slices, 105 );
            rec.heatnt9 := Convert( slices, 106 );
            rec.helpgv01 := Convert( slices, 107 );
            rec.helpgv02 := Convert( slices, 108 );
            rec.helpgv03 := Convert( slices, 109 );
            rec.helpgv04 := Convert( slices, 110 );
            rec.helpgv05 := Convert( slices, 111 );
            rec.helpgv06 := Convert( slices, 112 );
            rec.helpgv07 := Convert( slices, 113 );
            rec.helpgv08 := Convert( slices, 114 );
            rec.helpgv09 := Convert( slices, 115 );
            rec.helpgv10 := Convert( slices, 116 );
            rec.helpgv11 := Convert( slices, 117 );
            rec.helprc01 := Convert( slices, 118 );
            rec.helprc02 := Convert( slices, 119 );
            rec.helprc03 := Convert( slices, 120 );
            rec.helprc04 := Convert( slices, 121 );
            rec.helprc05 := Convert( slices, 122 );
            rec.helprc06 := Convert( slices, 123 );
            rec.helprc07 := Convert( slices, 124 );
            rec.helprc08 := Convert( slices, 125 );
            rec.helprc09 := Convert( slices, 126 );
            rec.helprc10 := Convert( slices, 127 );
            rec.helprc11 := Convert( slices, 128 );
            rec.holnt1 := Convert( slices, 129 );
            rec.holnt2 := Convert( slices, 130 );
            rec.holnt3 := Convert( slices, 131 );
            rec.holnt4 := Convert( slices, 132 );
            rec.holnt5 := Convert( slices, 133 );
            rec.holnt6 := Convert( slices, 134 );
            rec.holnt7 := Convert( slices, 135 );
            rec.holnt8 := Convert( slices, 136 );
            rec.holnt9 := Convert( slices, 137 );
            rec.homent1 := Convert( slices, 138 );
            rec.homent2 := Convert( slices, 139 );
            rec.homent3 := Convert( slices, 140 );
            rec.homent4 := Convert( slices, 141 );
            rec.homent5 := Convert( slices, 142 );
            rec.homent6 := Convert( slices, 143 );
            rec.homent7 := Convert( slices, 144 );
            rec.homent8 := Convert( slices, 145 );
            rec.homent9 := Convert( slices, 146 );
            rec.houshe1 := Convert( slices, 147 );
            rec.incchnge := Convert( slices, 148 );
            rec.inchilow := Convert( slices, 149 );
            rec.issue := Convert( slices, 150 );
            rec.kidinc := Convert( slices, 151 );
            rec.mealnt1 := Convert( slices, 152 );
            rec.mealnt2 := Convert( slices, 153 );
            rec.mealnt3 := Convert( slices, 154 );
            rec.mealnt4 := Convert( slices, 155 );
            rec.mealnt5 := Convert( slices, 156 );
            rec.mealnt6 := Convert( slices, 157 );
            rec.mealnt7 := Convert( slices, 158 );
            rec.mealnt8 := Convert( slices, 159 );
            rec.mealnt9 := Convert( slices, 160 );
            rec.nhhchild := Convert( slices, 161 );
            rec.oabill := Convert( slices, 162 );
            rec.oacoat := Convert( slices, 163 );
            rec.oacook := Convert( slices, 164 );
            rec.oadamp := Convert( slices, 165 );
            rec.oaexpns := Convert( slices, 166 );
            rec.oafrnd := Convert( slices, 167 );
            rec.oahair := Convert( slices, 168 );
            rec.oaheat := Convert( slices, 169 );
            rec.oahol := Convert( slices, 170 );
            rec.oahome := Convert( slices, 171 );
            rec.oahowpy1 := Convert( slices, 172 );
            rec.oahowpy2 := Convert( slices, 173 );
            rec.oahowpy3 := Convert( slices, 174 );
            rec.oahowpy4 := Convert( slices, 175 );
            rec.oahowpy5 := Convert( slices, 176 );
            rec.oahowpy6 := Convert( slices, 177 );
            rec.oameal := Convert( slices, 178 );
            rec.oaout := Convert( slices, 179 );
            rec.oaphon := Convert( slices, 180 );
            rec.oataxi := Convert( slices, 181 );
            rec.oawarm := Convert( slices, 182 );
            rec.outnt1 := Convert( slices, 183 );
            rec.outnt2 := Convert( slices, 184 );
            rec.outnt3 := Convert( slices, 185 );
            rec.outnt4 := Convert( slices, 186 );
            rec.outnt5 := Convert( slices, 187 );
            rec.outnt6 := Convert( slices, 188 );
            rec.outnt7 := Convert( slices, 189 );
            rec.outnt8 := Convert( slices, 190 );
            rec.outnt9 := Convert( slices, 191 );
            rec.phonnt1 := Convert( slices, 192 );
            rec.phonnt2 := Convert( slices, 193 );
            rec.phonnt3 := Convert( slices, 194 );
            rec.phonnt4 := Convert( slices, 195 );
            rec.phonnt5 := Convert( slices, 196 );
            rec.phonnt6 := Convert( slices, 197 );
            rec.phonnt7 := Convert( slices, 198 );
            rec.phonnt8 := Convert( slices, 199 );
            rec.phonnt9 := Convert( slices, 200 );
            rec.taxint1 := Convert( slices, 201 );
            rec.taxint2 := Convert( slices, 202 );
            rec.taxint3 := Convert( slices, 203 );
            rec.taxint4 := Convert( slices, 204 );
            rec.taxint5 := Convert( slices, 205 );
            rec.taxint6 := Convert( slices, 206 );
            rec.taxint7 := Convert( slices, 207 );
            rec.taxint8 := Convert( slices, 208 );
            rec.taxint9 := Convert( slices, 209 );
            rec.totsav := Convert( slices, 210 );
            rec.warmnt1 := Convert( slices, 211 );
            rec.warmnt2 := Convert( slices, 212 );
            rec.warmnt3 := Convert( slices, 213 );
            rec.warmnt4 := Convert( slices, 214 );
            rec.warmnt5 := Convert( slices, 215 );
            rec.warmnt6 := Convert( slices, 216 );
            rec.warmnt7 := Convert( slices, 217 );
            rec.warmnt8 := Convert( slices, 218 );
            rec.warmnt9 := Convert( slices, 219 );
            rec.month := Convert( slices, 220 );
            rec.adddabu := Convert( slices, 221 );
            rec.adultb := Convert( slices, 222 );
            rec.boarder := Convert( slices, 223 );
            rec.bpeninc := Convert( slices, 224 );
            rec.bseinc := Convert( slices, 225 );
            rec.buagegr2 := Convert( slices, 226 );
            rec.buagegr3 := Convert( slices, 227 );
            rec.buagegr4 := Convert( slices, 228 );
            rec.buagegrp := Convert( slices, 229 );
            rec.budisben := Convert( slices, 230 );
            rec.buearns := Convert( slices, 231 );
            rec.buethgr2 := Convert( slices, 232 );
            rec.buinc := Convert( slices, 233 );
            rec.buinv := Convert( slices, 234 );
            rec.buirben := Convert( slices, 235 );
            rec.bukids := Convert( slices, 236 );
            rec.bunirben := Convert( slices, 237 );
            rec.buothben := Convert( slices, 238 );
            rec.burent := Convert( slices, 239 );
            rec.burinc := Convert( slices, 240 );
            rec.burpinc := Convert( slices, 241 );
            rec.butvlic := Convert( slices, 242 );
            rec.butxcred := Convert( slices, 243 );
            rec.chddabu := Convert( slices, 244 );
            rec.depchldb := Convert( slices, 245 );
            rec.disindhb := Convert( slices, 246 );
            rec.ecostabu := Convert( slices, 247 );
            rec.ecstatbu := Convert( slices, 248 );
            rec.famtypb2 := Convert( slices, 249 );
            rec.famtypbs := Convert( slices, 250 );
            rec.famtypbu := Convert( slices, 251 );
            rec.fsmbu := Convert( slices, 252 );
            rec.fsmlkbu := Convert( slices, 253 );
            rec.gross3 := Convert( slices, 254 );
            rec.hbindbu := Convert( slices, 255 );
            rec.hbindbu2 := Convert( slices, 256 );
            rec.heartbu := Convert( slices, 257 );
            rec.kid04 := Convert( slices, 258 );
            rec.kid1115 := Convert( slices, 259 );
            rec.kid1619 := Convert( slices, 260 );
            rec.kid510 := Convert( slices, 261 );
            rec.lodger := Convert( slices, 262 );
            rec.newfamb2 := Convert( slices, 263 );
            rec.newfambu := Convert( slices, 264 );
            rec.oabilimp := Convert( slices, 265 );
            rec.oacoaimp := Convert( slices, 266 );
            rec.oacooimp := Convert( slices, 267 );
            rec.oadamimp := Convert( slices, 268 );
            rec.oaexpimp := Convert( slices, 269 );
            rec.oafrnimp := Convert( slices, 270 );
            rec.oahaiimp := Convert( slices, 271 );
            rec.oaheaimp := Convert( slices, 272 );
            rec.oaholimp := Convert( slices, 273 );
            rec.oahomimp := Convert( slices, 274 );
            rec.oameaimp := Convert( slices, 275 );
            rec.oaoutimp := Convert( slices, 276 );
            rec.oaphoimp := Convert( slices, 277 );
            rec.oataximp := Convert( slices, 278 );
            rec.oawarimp := Convert( slices, 279 );
            rec.subltamt := Convert( slices, 280 );
            rec.totcapb3 := Convert( slices, 282 );
            rec.totsavbu := Convert( slices, 283 );
            rec.tuburent := Convert( slices, 284 );
            rec.youngch := Convert( slices, 285 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( BenunitRec ).startPos = 0 ) then
               index.pointers( BenunitRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( BenunitRec ).counter := index.pointers( BenunitRec ).counter + 1;
            Put_Index( index_map, index );
            Benunit_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Benunit_IO.Close( bin_file );
   end Create_Benunit_1011;


   procedure Create_Care_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Care_IO.File_Type;
      rec         : Care_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Care_IO.Create (bin_file, Care_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.needper := Convert( slices, 3 );
            rec.daynight := Convert( slices, 4 );
            rec.freq := Convert( slices, 5 );
            rec.hour01 := Convert( slices, 6 );
            rec.hour02 := Convert( slices, 7 );
            rec.hour03 := Convert( slices, 8 );
            rec.hour04 := Convert( slices, 9 );
            rec.hour05 := Convert( slices, 10 );
            rec.hour06 := Convert( slices, 11 );
            rec.hour07 := Convert( slices, 12 );
            rec.hour08 := Convert( slices, 13 );
            rec.hour09 := Convert( slices, 14 );
            rec.hour10 := Convert( slices, 15 );
            rec.hour11 := Convert( slices, 16 );
            rec.hour12 := Convert( slices, 17 );
            rec.hour13 := Convert( slices, 18 );
            rec.hour14 := Convert( slices, 19 );
            rec.hour15 := Convert( slices, 20 );
            rec.hour16 := Convert( slices, 21 );
            rec.hour17 := Convert( slices, 22 );
            rec.hour18 := Convert( slices, 23 );
            rec.hour19 := Convert( slices, 24 );
            rec.hour20 := Convert( slices, 25 );
            rec.howlng01 := Convert( slices, 26 );
            rec.howlng02 := Convert( slices, 27 );
            rec.howlng03 := Convert( slices, 28 );
            rec.howlng04 := Convert( slices, 29 );
            rec.howlng05 := Convert( slices, 30 );
            rec.howlng06 := Convert( slices, 31 );
            rec.howlng07 := Convert( slices, 32 );
            rec.howlng08 := Convert( slices, 33 );
            rec.howlng09 := Convert( slices, 34 );
            rec.howlng10 := Convert( slices, 35 );
            rec.howlng11 := Convert( slices, 36 );
            rec.howlng12 := Convert( slices, 37 );
            rec.howlng13 := Convert( slices, 38 );
            rec.howlng14 := Convert( slices, 39 );
            rec.howlng15 := Convert( slices, 40 );
            rec.howlng16 := Convert( slices, 41 );
            rec.howlng17 := Convert( slices, 42 );
            rec.howlng18 := Convert( slices, 43 );
            rec.howlng19 := Convert( slices, 44 );
            rec.howlng20 := Convert( slices, 45 );
            rec.issue := Convert( slices, 46 );
            rec.wholoo01 := Convert( slices, 47 );
            rec.wholoo02 := Convert( slices, 48 );
            rec.wholoo03 := Convert( slices, 49 );
            rec.wholoo04 := Convert( slices, 50 );
            rec.wholoo05 := Convert( slices, 51 );
            rec.wholoo06 := Convert( slices, 52 );
            rec.wholoo07 := Convert( slices, 53 );
            rec.wholoo08 := Convert( slices, 54 );
            rec.wholoo09 := Convert( slices, 55 );
            rec.wholoo10 := Convert( slices, 56 );
            rec.wholoo11 := Convert( slices, 57 );
            rec.wholoo12 := Convert( slices, 58 );
            rec.wholoo13 := Convert( slices, 59 );
            rec.wholoo14 := Convert( slices, 60 );
            rec.wholoo15 := Convert( slices, 61 );
            rec.wholoo16 := Convert( slices, 62 );
            rec.wholoo17 := Convert( slices, 63 );
            rec.wholoo18 := Convert( slices, 64 );
            rec.wholoo19 := Convert( slices, 65 );
            rec.wholoo20 := Convert( slices, 66 );
            rec.month := Convert( slices, 67 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( CareRec ).startPos = 0 ) then
               index.pointers( CareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( CareRec ).counter := index.pointers( CareRec ).counter + 1;
            Put_Index( index_map, index );
            Care_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Care_IO.Close( bin_file );
   end Create_Care_1011;


   procedure Create_Child_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Child_IO.File_Type;
      rec         : Child_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Child_IO.Create (bin_file, Child_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.adeduc := Convert( slices, 4 );
            rec.age := Convert( slices, 5 );
            rec.care := Convert( slices, 6 );
            rec.cddaprg := Convert( slices, 7 );
            rec.cddatre := Convert( slices, 8 );
            rec.cddatrep := Convert( slices, 9 );
            rec.cdisdif1 := Convert( slices, 10 );
            rec.cdisdif2 := Convert( slices, 11 );
            rec.cdisdif3 := Convert( slices, 12 );
            rec.cdisdif4 := Convert( slices, 13 );
            rec.cdisdif5 := Convert( slices, 14 );
            rec.cdisdif6 := Convert( slices, 15 );
            rec.cdisdif7 := Convert( slices, 16 );
            rec.cdisdif8 := Convert( slices, 17 );
            rec.cdisdif9 := Convert( slices, 18 );
            rec.cdisdifp := Convert( slices, 19 );
            rec.cfund := Convert( slices, 20 );
            rec.cfundh := Convert( slices, 21 );
            rec.cfundtp := Convert( slices, 22 );
            rec.chamtern := Convert( slices, 23 );
            rec.chamttst := Convert( slices, 24 );
            rec.chca := Convert( slices, 25 );
            rec.chdla1 := Convert( slices, 26 );
            rec.chdla2 := Convert( slices, 27 );
            rec.chealth := Convert( slices, 28 );
            rec.chearns1 := Convert( slices, 29 );
            rec.chearns2 := Convert( slices, 30 );
            rec.chearns3 := Convert( slices, 31 );
            rec.chema := Convert( slices, 32 );
            rec.chemaamt := Convert( slices, 33 );
            rec.chemapd := Convert( slices, 34 );
            rec.chpdern := Convert( slices, 35 );
            rec.chpdtst := Convert( slices, 36 );
            rec.chprob := Convert( slices, 37 );
            rec.chsave := Convert( slices, 38 );
            rec.chtrnamt := Convert( slices, 39 );
            rec.chtrnpd := Convert( slices, 40 );
            rec.cohabit := Convert( slices, 41 );
            rec.convbl := Convert( slices, 42 );
            rec.cvht := Convert( slices, 43 );
            rec.cvpay := Convert( slices, 44 );
            rec.cvpd := Convert( slices, 45 );
            rec.depend := Convert( slices, 46 );
            rec.dob := Convert( slices, 47 );
            rec.eligadlt := Convert( slices, 48 );
            rec.eligchld := Convert( slices, 49 );
            rec.fted := Convert( slices, 50 );
            rec.fundamt1 := Convert( slices, 51 );
            rec.fundamt2 := Convert( slices, 52 );
            rec.fundamt3 := Convert( slices, 53 );
            rec.fundamt4 := Convert( slices, 54 );
            rec.fundamt5 := Convert( slices, 55 );
            rec.fundamt6 := Convert( slices, 56 );
            rec.givcfnd1 := Convert( slices, 57 );
            rec.givcfnd2 := Convert( slices, 58 );
            rec.givcfnd3 := Convert( slices, 59 );
            rec.givcfnd4 := Convert( slices, 60 );
            rec.givcfnd5 := Convert( slices, 61 );
            rec.givcfnd6 := Convert( slices, 62 );
            rec.grant := Convert( slices, 63 );
            rec.grtamt1 := Convert( slices, 64 );
            rec.grtamt2 := Convert( slices, 65 );
            rec.grtdir1 := Convert( slices, 66 );
            rec.grtdir2 := Convert( slices, 67 );
            rec.grtnum := Convert( slices, 68 );
            rec.grtsce1 := Convert( slices, 69 );
            rec.grtsce2 := Convert( slices, 70 );
            rec.grtval1 := Convert( slices, 71 );
            rec.grtval2 := Convert( slices, 72 );
            rec.hholder := Convert( slices, 73 );
            rec.hsvper := Convert( slices, 74 );
            rec.issue := Convert( slices, 75 );
            rec.lareg := Convert( slices, 76 );
            rec.mednum := Convert( slices, 77 );
            rec.medprpd := Convert( slices, 78 );
            rec.medprpy := Convert( slices, 79 );
            rec.ms := Convert( slices, 80 );
            rec.parent1 := Convert( slices, 81 );
            rec.parent2 := Convert( slices, 82 );
            rec.r01 := Convert( slices, 83 );
            rec.r02 := Convert( slices, 84 );
            rec.r03 := Convert( slices, 85 );
            rec.r04 := Convert( slices, 86 );
            rec.r05 := Convert( slices, 87 );
            rec.r06 := Convert( slices, 88 );
            rec.r07 := Convert( slices, 89 );
            rec.r08 := Convert( slices, 90 );
            rec.r09 := Convert( slices, 91 );
            rec.r10 := Convert( slices, 92 );
            rec.r11 := Convert( slices, 93 );
            rec.r12 := Convert( slices, 94 );
            rec.r13 := Convert( slices, 95 );
            rec.r14 := Convert( slices, 96 );
            rec.schchk := Convert( slices, 97 );
            rec.sex := Convert( slices, 98 );
            rec.smkit := Convert( slices, 99 );
            rec.smlit := Convert( slices, 100 );
            rec.spcreg1 := Convert( slices, 101 );
            rec.spcreg2 := Convert( slices, 102 );
            rec.spcreg3 := Convert( slices, 103 );
            rec.spout := Convert( slices, 104 );
            rec.srentamt := Convert( slices, 105 );
            rec.srentpd := Convert( slices, 106 );
            rec.totsave := Convert( slices, 107 );
            rec.trainee := Convert( slices, 108 );
            rec.typeed := Convert( slices, 109 );
            rec.month := Convert( slices, 110 );
            rec.careab := Convert( slices, 111 );
            rec.careah := Convert( slices, 112 );
            rec.carecb := Convert( slices, 113 );
            rec.carech := Convert( slices, 114 );
            rec.carecl := Convert( slices, 115 );
            rec.carefl := Convert( slices, 116 );
            rec.carefr := Convert( slices, 117 );
            rec.careot := Convert( slices, 118 );
            rec.carere := Convert( slices, 119 );
            rec.chdda := Convert( slices, 120 );
            rec.chearns := Convert( slices, 121 );
            rec.chincdv := Convert( slices, 122 );
            rec.chrinc := Convert( slices, 123 );
            rec.disdifch := Convert( slices, 124 );
            rec.fsmlkval := Convert( slices, 125 );
            rec.fsmval := Convert( slices, 126 );
            rec.hdagech := Convert( slices, 127 );
            rec.heartval := Convert( slices, 128 );
            rec.hourab := Convert( slices, 129 );
            rec.hourah := Convert( slices, 130 );
            rec.hourcb := Convert( slices, 131 );
            rec.hourch := Convert( slices, 132 );
            rec.hourcl := Convert( slices, 133 );
            rec.hourfr := Convert( slices, 134 );
            rec.hourot := Convert( slices, 135 );
            rec.hourre := Convert( slices, 136 );
            rec.hourtot := Convert( slices, 137 );
            rec.hperson := Convert( slices, 138 );
            rec.iagegr2 := Convert( slices, 139 );
            rec.iagegrp := Convert( slices, 140 );
            rec.relhrp := Convert( slices, 141 );
            rec.totgntch := Convert( slices, 142 );
            rec.tuacam := Convert( slices, 143 );
            rec.uperson := Convert( slices, 144 );
            rec.xbonflag := Convert( slices, 145 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildRec ).startPos = 0 ) then
               index.pointers( ChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildRec ).counter := index.pointers( ChildRec ).counter + 1;
            Put_Index( index_map, index );
            Child_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Child_IO.Close( bin_file );
   end Create_Child_1011;


   procedure Create_ChildCare_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ChildCare_IO.File_Type;
      rec         : ChildCare_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ChildCare_IO.Create (bin_file, ChildCare_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.chlook := Convert( slices, 4 );
            rec.chamt := Convert( slices, 5 );
            rec.chhr := Convert( slices, 6 );
            rec.chpd := Convert( slices, 7 );
            rec.cost := Convert( slices, 8 );
            rec.ctrm := Convert( slices, 9 );
            rec.emplprov := Convert( slices, 10 );
            rec.hourly := Convert( slices, 11 );
            rec.issue := Convert( slices, 12 );
            rec.pmchk := Convert( slices, 13 );
            rec.registrd := Convert( slices, 14 );
            rec.month := Convert( slices, 15 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ChildCareRec ).startPos = 0 ) then
               index.pointers( ChildCareRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ChildCareRec ).counter := index.pointers( ChildCareRec ).counter + 1;
            Put_Index( index_map, index );
            ChildCare_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ChildCare_IO.Close( bin_file );
   end Create_ChildCare_1011;


   procedure Create_Endowment_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Endowment_IO.File_Type;
      rec         : Endowment_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Endowment_IO.Create (bin_file, Endowment_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.endowseq := Convert( slices, 3 );
            rec.incinint := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.menpolam := Convert( slices, 6 );
            rec.menpolpd := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( EndowmentRec ).startPos = 0 ) then
               index.pointers( EndowmentRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( EndowmentRec ).counter := index.pointers( EndowmentRec ).counter + 1;
            Put_Index( index_map, index );
            Endowment_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Endowment_IO.Close( bin_file );
   end Create_Endowment_1011;


   procedure Create_ExtChild_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : ExtChild_IO.File_Type;
      rec         : ExtChild_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      ExtChild_IO.Create (bin_file, ExtChild_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.extseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.nhhamt := Convert( slices, 5 );
            rec.nhhfee := Convert( slices, 6 );
            rec.nhhintro := Convert( slices, 7 );
            rec.nhhpd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( ExtChildRec ).startPos = 0 ) then
               index.pointers( ExtChildRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( ExtChildRec ).counter := index.pointers( ExtChildRec ).counter + 1;
            Put_Index( index_map, index );
            ExtChild_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      ExtChild_IO.Close( bin_file );
   end Create_ExtChild_1011;


   procedure Create_GovPay_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : GovPay_IO.File_Type;
      rec         : GovPay_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      GovPay_IO.Create (bin_file, GovPay_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.benefit := Convert( slices, 4 );
            rec.govpay := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.month := Convert( slices, 7 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( GovPayRec ).startPos = 0 ) then
               index.pointers( GovPayRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( GovPayRec ).counter := index.pointers( GovPayRec ).counter + 1;
            Put_Index( index_map, index );
            GovPay_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      GovPay_IO.Close( bin_file );
   end Create_GovPay_1011;


   procedure Create_Hbai_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Hbai_IO.File_Type;
      rec         : Hbai_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Hbai_IO.Create (bin_file, Hbai_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.mnoeahcx := Convert( slices, 1 );
            rec.mdoeahcx := Convert( slices, 2 );
            rec.mnmcahcx := Convert( slices, 3 );
            rec.mdmcahcx := Convert( slices, 4 );
            rec.mnoebhcx := Convert( slices, 5 );
            rec.mdoebhcx := Convert( slices, 6 );
            rec.mnmcbhcx := Convert( slices, 7 );
            rec.mdmcbhcx := Convert( slices, 8 );
            rec.mnoeahc := Convert( slices, 9 );
            rec.mdoeahc := Convert( slices, 10 );
            rec.mnmcahc := Convert( slices, 11 );
            rec.mdmcahc := Convert( slices, 12 );
            rec.mnoebhc := Convert( slices, 13 );
            rec.mdoebhc := Convert( slices, 14 );
            rec.mnmcbhc := Convert( slices, 15 );
            rec.mdmcbhc := Convert( slices, 16 );
            rec.snphcost := Convert( slices, 17 );
            rec.sphcost := Convert( slices, 18 );
            rec.benunits := Convert( slices, 19 );
            rec.gvtregn := Convert( slices, 20 );
            rec.hhstat := Convert( slices, 21 );
            rec.tenure := Convert( slices, 22 );
            rec.adulth := Convert( slices, 23 );
            rec.depchldh := Convert( slices, 24 );
            rec.ptentyp2 := Convert( slices, 25 );
            rec.tentyp2 := Convert( slices, 26 );
            rec.watsewrt := Convert( slices, 27 );
            rec.sewerage := Convert( slices, 28 );
            rec.cwathh := Convert( slices, 29 );
            rec.totsthh := Convert( slices, 30 );
            rec.totstrhh := Convert( slices, 31 );
            rec.charghh := Convert( slices, 32 );
            rec.hbmort := Convert( slices, 33 );
            rec.hbxmort := Convert( slices, 34 );
            rec.hrenthh := Convert( slices, 35 );
            rec.erenthh := Convert( slices, 36 );
            rec.hbenhh := Convert( slices, 37 );
            rec.watsewhh := Convert( slices, 38 );
            rec.hhcost := Convert( slices, 39 );
            rec.ehcost := Convert( slices, 40 );
            rec.bhcdef := Convert( slices, 41 );
            rec.ahcdef := Convert( slices, 42 );
            rec.ctrebam1 := Convert( slices, 43 );
            rec.cwatadj := Convert( slices, 44 );
            rec.adultb := Convert( slices, 45 );
            rec.egrincbu := Convert( slices, 46 );
            rec.entincbu := Convert( slices, 47 );
            rec.hgrernhh := Convert( slices, 48 );
            rec.hnternhh := Convert( slices, 49 );
            rec.hgrinvhh := Convert( slices, 50 );
            rec.hntinvhh := Convert( slices, 51 );
            rec.hgrocchh := Convert( slices, 52 );
            rec.hntocchh := Convert( slices, 53 );
            rec.chbenhh := Convert( slices, 54 );
            rec.hbeninhh := Convert( slices, 55 );
            rec.hpribnhh := Convert( slices, 56 );
            rec.hmiscihh := Convert( slices, 57 );
            rec.sfrpahh := Convert( slices, 58 );
            rec.hgrinchh := Convert( slices, 59 );
            rec.hntinchh := Convert( slices, 60 );
            rec.inchilhh := Convert( slices, 61 );
            rec.egrernhh := Convert( slices, 62 );
            rec.enternhh := Convert( slices, 63 );
            rec.ebeninhh := Convert( slices, 64 );
            rec.epribnhh := Convert( slices, 65 );
            rec.emiscihh := Convert( slices, 66 );
            rec.eothdehh := Convert( slices, 67 );
            rec.egrinchh := Convert( slices, 68 );
            rec.entinchh := Convert( slices, 69 );
            rec.tvlichh := Convert( slices, 70 );
            rec.g_newhh := Convert( slices, 71 );
            rec.gnewhhp := Convert( slices, 72 );
            rec.esgjobhh := Convert( slices, 73 );
            rec.esgrsehh := Convert( slices, 74 );
            rec.esginvhh := Convert( slices, 75 );
            rec.esgocchh := Convert( slices, 76 );
            rec.esmischh := Convert( slices, 77 );
            rec.espribhh := Convert( slices, 78 );
            rec.esbenihh := Convert( slices, 79 );
            rec.esothdhh := Convert( slices, 80 );
            rec.esginchh := Convert( slices, 81 );
            rec.esninchh := Convert( slices, 82 );
            rec.ericphh := Convert( slices, 83 );
            rec.ericnphh := Convert( slices, 84 );
            rec.gs_newhh := Convert( slices, 85 );
            rec.gs_newpph := Convert( slices, 86 );
            rec.es_hcost := Convert( slices, 87 );
            rec.esahchh := Convert( slices, 88 );
            rec.eahchh := Convert( slices, 89 );
            rec.benunit := Convert( slices, 90 );
            rec.depchldb := Convert( slices, 91 );
            rec.eqmcoup := Convert( slices, 92 );
            rec.eqmbhckd := Convert( slices, 93 );
            rec.eqmahckd := Convert( slices, 94 );
            rec.eqmbhchh := Convert( slices, 95 );
            rec.eqmahchh := Convert( slices, 96 );
            rec.over14 := Convert( slices, 97 );
            rec.under14 := Convert( slices, 98 );
            rec.eqobhchh := Convert( slices, 99 );
            rec.eqoahchh := Convert( slices, 100 );
            rec.mc_bhc := Convert( slices, 101 );
            rec.oe_bhc := Convert( slices, 102 );
            rec.mc_gro := Convert( slices, 103 );
            rec.oe_gro := Convert( slices, 104 );
            rec.mc_ahc := Convert( slices, 105 );
            rec.oe_ahc := Convert( slices, 106 );
            rec.s_mc_bhc := Convert( slices, 107 );
            rec.s_oe_bhc := Convert( slices, 108 );
            rec.s_mc_gro := Convert( slices, 109 );
            rec.s_oe_gro := Convert( slices, 110 );
            rec.s_mc_ahc := Convert( slices, 111 );
            rec.s_oe_ahc := Convert( slices, 112 );
            rec.sehhflg := Convert( slices, 113 );
            rec.ethgrphh := Convert( slices, 114 );
            rec.oldsehhflg := Convert( slices, 115 );
            rec.fsmbu := Convert( slices, 116 );
            rec.fsmlkbu := Convert( slices, 117 );
            rec.hbenbu := Convert( slices, 118 );
            rec.ehbenbu := Convert( slices, 119 );
            rec.srentbu := Convert( slices, 120 );
            rec.rentbu := Convert( slices, 121 );
            rec.erentbu := Convert( slices, 122 );
            rec.insebu := Convert( slices, 123 );
            rec.ginsebu := Convert( slices, 124 );
            rec.chbenbu := Convert( slices, 125 );
            rec.hgrernbu := Convert( slices, 126 );
            rec.hnternbu := Convert( slices, 127 );
            rec.hgrinvbu := Convert( slices, 128 );
            rec.hntinvbu := Convert( slices, 129 );
            rec.hgroccbu := Convert( slices, 130 );
            rec.hntoccbu := Convert( slices, 131 );
            rec.hbeninbu := Convert( slices, 132 );
            rec.hpribnbu := Convert( slices, 133 );
            rec.hmiscibu := Convert( slices, 134 );
            rec.sfrpabu := Convert( slices, 135 );
            rec.hgrincbu := Convert( slices, 136 );
            rec.hntincbu := Convert( slices, 137 );
            rec.egrernbu := Convert( slices, 138 );
            rec.enternbu := Convert( slices, 139 );
            rec.ebeninbu := Convert( slices, 140 );
            rec.epribnbu := Convert( slices, 141 );
            rec.emiscibu := Convert( slices, 142 );
            rec.eothdebu := Convert( slices, 143 );
            rec.winpaybu := Convert( slices, 144 );
            rec.tvlicbu := Convert( slices, 145 );
            rec.ecobu := Convert( slices, 146 );
            rec.oldecobu := Convert( slices, 147 );
            rec.disabflg := Convert( slices, 148 );
            rec.fambu := Convert( slices, 149 );
            rec.newfambu := Convert( slices, 150 );
            rec.personhd := Convert( slices, 151 );
            rec.personsp := Convert( slices, 152 );
            rec.kidecobu := Convert( slices, 153 );
            rec.oldkidecobu := Convert( slices, 154 );
            rec.kid0_1 := Convert( slices, 155 );
            rec.kid2_4 := Convert( slices, 156 );
            rec.kid5_7 := Convert( slices, 157 );
            rec.kid8_10 := Convert( slices, 158 );
            rec.kid11_12 := Convert( slices, 159 );
            rec.kid13_15 := Convert( slices, 160 );
            rec.kid16_19 := Convert( slices, 161 );
            rec.boys := Convert( slices, 162 );
            rec.wtcbu := Convert( slices, 163 );
            rec.ctcbu := Convert( slices, 164 );
            rec.isbu := Convert( slices, 165 );
            rec.inchilbu := Convert( slices, 166 );
            rec.g_newbu := Convert( slices, 167 );
            rec.g_newpp := Convert( slices, 168 );
            rec.g_newch := Convert( slices, 169 );
            rec.g_newad := Convert( slices, 170 );
            rec.g_newpn := Convert( slices, 171 );
            rec.g_newwa := Convert( slices, 172 );
            rec.esgjobbu := Convert( slices, 173 );
            rec.esgrsebu := Convert( slices, 174 );
            rec.esginvbu := Convert( slices, 175 );
            rec.esgoccbu := Convert( slices, 176 );
            rec.esmiscbu := Convert( slices, 177 );
            rec.espribbu := Convert( slices, 178 );
            rec.esbenibu := Convert( slices, 179 );
            rec.esothdbu := Convert( slices, 180 );
            rec.esgincbu := Convert( slices, 181 );
            rec.esnincbu := Convert( slices, 182 );
            rec.ericpbu := Convert( slices, 183 );
            rec.ericnpbu := Convert( slices, 184 );
            rec.gs_newbu := Convert( slices, 185 );
            rec.gs_newpp := Convert( slices, 186 );
            rec.gs_newch := Convert( slices, 187 );
            rec.gs_newad := Convert( slices, 188 );
            rec.gs_newpn := Convert( slices, 189 );
            rec.gs_newwa := Convert( slices, 190 );
            rec.mbhcdec := Convert( slices, 191 );
            rec.mqinbhc := Convert( slices, 192 );
            rec.obhcdec := Convert( slices, 193 );
            rec.oqinbhc := Convert( slices, 194 );
            rec.mahcdec := Convert( slices, 195 );
            rec.mqinahc := Convert( slices, 196 );
            rec.oahcdec := Convert( slices, 197 );
            rec.oqinahc := Convert( slices, 198 );
            rec.mbhcdecx := Convert( slices, 199 );
            rec.mqinbhcx := Convert( slices, 200 );
            rec.obhcdecx := Convert( slices, 201 );
            rec.oqinbhcx := Convert( slices, 202 );
            rec.mahcdecx := Convert( slices, 203 );
            rec.mqinahcx := Convert( slices, 204 );
            rec.oahcdecx := Convert( slices, 205 );
            rec.oqinahcx := Convert( slices, 206 );
            rec.agehd := Convert( slices, 207 );
            rec.sexhd := Convert( slices, 208 );
            rec.esbenihd := Convert( slices, 209 );
            rec.esgjobhd := Convert( slices, 211 );
            rec.esgocchd := Convert( slices, 212 );
            rec.esgrsehd := Convert( slices, 213 );
            rec.esmischd := Convert( slices, 214 );
            rec.espribhd := Convert( slices, 215 );
            rec.winpayhd := Convert( slices, 216 );
            rec.agesp := Convert( slices, 217 );
            rec.sexsp := Convert( slices, 218 );
            rec.esbenisp := Convert( slices, 219 );
            rec.esginvsp := Convert( slices, 220 );
            rec.esgjobsp := Convert( slices, 221 );
            rec.esgoccsp := Convert( slices, 222 );
            rec.esgrsesp := Convert( slices, 223 );
            rec.esmiscsp := Convert( slices, 224 );
            rec.espribsp := Convert( slices, 225 );
            rec.winpaysp := Convert( slices, 226 );
            rec.mdscorechnew := Convert( slices, 227 );
            rec.mdscorech := Convert( slices, 228 );
            rec.mdch := Convert( slices, 229 );
            rec.mdscorepn := Convert( slices, 230 );
            rec.mdpn := Convert( slices, 231 );
            rec.low50bhc := Convert( slices, 232 );
            rec.low60bhc := Convert( slices, 233 );
            rec.low70bhc := Convert( slices, 234 );
            rec.low50ahc := Convert( slices, 235 );
            rec.low60ahc := Convert( slices, 236 );
            rec.low70ahc := Convert( slices, 237 );
            rec.lowincmdch := Convert( slices, 238 );
            rec.lowincmdchsev := Convert( slices, 239 );
            rec.lowmcbhc := Convert( slices, 240 );
            rec.lowmcahc := Convert( slices, 241 );
            rec.sernum := Convert( slices, 242 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HbaiRec ).startPos = 0 ) then
               index.pointers( HbaiRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HbaiRec ).counter := index.pointers( HbaiRec ).counter + 1;
            Put_Index( index_map, index );
            Hbai_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Hbai_IO.Close( bin_file );
   end Create_Hbai_1011;


   procedure Create_Household_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Household_IO.File_Type;
      rec         : Household_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Household_IO.Create (bin_file, Household_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.bedroom := Convert( slices, 2 );
            rec.benunits := Convert( slices, 3 );
            rec.billrate := Convert( slices, 4 );
            rec.brma := Convert( slices, 5 );
            rec.busroom := Convert( slices, 6 );
            rec.capval := Convert( slices, 7 );
            rec.charge1 := Convert( slices, 8 );
            rec.charge2 := Convert( slices, 9 );
            rec.charge3 := Convert( slices, 10 );
            rec.charge4 := Convert( slices, 11 );
            rec.charge5 := Convert( slices, 12 );
            rec.charge6 := Convert( slices, 13 );
            rec.charge7 := Convert( slices, 14 );
            rec.charge8 := Convert( slices, 15 );
            rec.charge9 := Convert( slices, 16 );
            rec.chins := Convert( slices, 17 );
            rec.chrgamt1 := Convert( slices, 18 );
            rec.chrgamt2 := Convert( slices, 19 );
            rec.chrgamt3 := Convert( slices, 20 );
            rec.chrgamt4 := Convert( slices, 21 );
            rec.chrgamt5 := Convert( slices, 22 );
            rec.chrgamt6 := Convert( slices, 23 );
            rec.chrgamt7 := Convert( slices, 24 );
            rec.chrgamt8 := Convert( slices, 25 );
            rec.chrgamt9 := Convert( slices, 26 );
            rec.chrgpd1 := Convert( slices, 27 );
            rec.chrgpd2 := Convert( slices, 28 );
            rec.chrgpd3 := Convert( slices, 29 );
            rec.chrgpd4 := Convert( slices, 30 );
            rec.chrgpd5 := Convert( slices, 31 );
            rec.chrgpd6 := Convert( slices, 32 );
            rec.chrgpd7 := Convert( slices, 33 );
            rec.chrgpd8 := Convert( slices, 34 );
            rec.chrgpd9 := Convert( slices, 35 );
            rec.covoths := Convert( slices, 36 );
            rec.csewamt := Convert( slices, 37 );
            rec.csewamt1 := Convert( slices, 38 );
            rec.ct25d50d := Convert( slices, 39 );
            rec.ctamt := Convert( slices, 40 );
            rec.ctannual := Convert( slices, 41 );
            rec.ctband := Convert( slices, 42 );
            rec.ctbwait := Convert( slices, 43 );
            rec.ctcondoc := Convert( slices, 44 );
            rec.ctdisc := Convert( slices, 45 );
            rec.ctinstal := Convert( slices, 46 );
            rec.ctlvband := Convert( slices, 47 );
            rec.ctlvchk := Convert( slices, 48 );
            rec.ctreb := Convert( slices, 49 );
            rec.ctrebamt := Convert( slices, 50 );
            rec.ctrebpd := Convert( slices, 51 );
            rec.cttime := Convert( slices, 52 );
            rec.cwatamt := Convert( slices, 53 );
            rec.cwatamt1 := Convert( slices, 54 );
            rec.datyrago := Convert( slices, 55 );
            rec.dvadulth := Convert( slices, 56 );
            rec.dvtotad := Convert( slices, 57 );
            rec.entry1 := Convert( slices, 58 );
            rec.entry2 := Convert( slices, 59 );
            rec.entry3 := Convert( slices, 60 );
            rec.entry4 := Convert( slices, 61 );
            rec.entry5 := Convert( slices, 62 );
            rec.entry6 := Convert( slices, 63 );
            rec.floor := Convert( slices, 64 );
            rec.givehelp := Convert( slices, 65 );
            rec.gvtregn := Convert( slices, 66 );
            rec.hhldr01 := Convert( slices, 67 );
            rec.hhldr02 := Convert( slices, 68 );
            rec.hhldr03 := Convert( slices, 69 );
            rec.hhldr04 := Convert( slices, 70 );
            rec.hhldr05 := Convert( slices, 71 );
            rec.hhldr06 := Convert( slices, 72 );
            rec.hhldr07 := Convert( slices, 73 );
            rec.hhldr08 := Convert( slices, 74 );
            rec.hhldr09 := Convert( slices, 75 );
            rec.hhldr10 := Convert( slices, 76 );
            rec.hhldr11 := Convert( slices, 77 );
            rec.hhldr12 := Convert( slices, 78 );
            rec.hhldr13 := Convert( slices, 79 );
            rec.hhldr14 := Convert( slices, 80 );
            rec.hhldr97 := Convert( slices, 81 );
            rec.hhstat := Convert( slices, 82 );
            rec.hlthst := Convert( slices, 83 );
            rec.hrpnum := Convert( slices, 84 );
            rec.imd_e := Convert( slices, 85 );
            rec.imd_s := Convert( slices, 86 );
            rec.imd_w := Convert( slices, 87 );
            rec.intdate := Convert( slices, 88 );
            rec.issue := Convert( slices, 89 );
            rec.lac := Convert( slices, 90 );
            rec.mainacc := Convert( slices, 91 );
            rec.medpay := Convert( slices, 92 );
            rec.medwho01 := Convert( slices, 93 );
            rec.medwho02 := Convert( slices, 94 );
            rec.medwho03 := Convert( slices, 95 );
            rec.medwho04 := Convert( slices, 96 );
            rec.medwho05 := Convert( slices, 97 );
            rec.medwho06 := Convert( slices, 98 );
            rec.medwho07 := Convert( slices, 99 );
            rec.medwho08 := Convert( slices, 100 );
            rec.medwho09 := Convert( slices, 101 );
            rec.medwho10 := Convert( slices, 102 );
            rec.medwho11 := Convert( slices, 103 );
            rec.medwho12 := Convert( slices, 104 );
            rec.medwho13 := Convert( slices, 105 );
            rec.medwho14 := Convert( slices, 106 );
            rec.migrq1 := Convert( slices, 107 );
            rec.migrq2 := Convert( slices, 108 );
            rec.mnthcode := Convert( slices, 109 );
            rec.monlive := Convert( slices, 110 );
            rec.needhelp := Convert( slices, 111 );
            rec.nicoun := Convert( slices, 112 );
            rec.nidpnd := Convert( slices, 113 );
            rec.nmrmshar := Convert( slices, 114 );
            rec.nochcr1 := Convert( slices, 115 );
            rec.nochcr2 := Convert( slices, 116 );
            rec.nochcr3 := Convert( slices, 117 );
            rec.nochcr4 := Convert( slices, 118 );
            rec.nochcr5 := Convert( slices, 119 );
            rec.norate := Convert( slices, 120 );
            rec.numtv1 := Convert( slices, 121 );
            rec.numtv2 := Convert( slices, 122 );
            rec.oac := Convert( slices, 123 );
            rec.onbsroom := Convert( slices, 124 );
            rec.payrate := Convert( slices, 125 );
            rec.ptbsroom := Convert( slices, 126 );
            rec.rooms := Convert( slices, 127 );
            rec.roomshr := Convert( slices, 128 );
            rec.rt2rebam := Convert( slices, 129 );
            rec.rt2rebpd := Convert( slices, 130 );
            rec.rtannual := Convert( slices, 131 );
            rec.rtcondoc := Convert( slices, 132 );
            rec.rtdpa := Convert( slices, 133 );
            rec.rtdpaamt := Convert( slices, 134 );
            rec.rtdpapd := Convert( slices, 135 );
            rec.rtinstal := Convert( slices, 136 );
            rec.rtlpa := Convert( slices, 137 );
            rec.rtlpaamt := Convert( slices, 138 );
            rec.rtlpapd := Convert( slices, 139 );
            rec.rtothamt := Convert( slices, 140 );
            rec.rtother := Convert( slices, 141 );
            rec.rtothpd := Convert( slices, 142 );
            rec.rtreb := Convert( slices, 143 );
            rec.rtrebamt := Convert( slices, 144 );
            rec.rtrebpd := Convert( slices, 145 );
            rec.rtrtr := Convert( slices, 146 );
            rec.rtrtramt := Convert( slices, 147 );
            rec.rtrtrpd := Convert( slices, 148 );
            rec.rttimepd := Convert( slices, 149 );
            rec.sampqtr := Convert( slices, 150 );
            rec.schmeal := Convert( slices, 151 );
            rec.schmilk := Convert( slices, 152 );
            rec.sewamt := Convert( slices, 153 );
            rec.sewanul := Convert( slices, 154 );
            rec.sewerpay := Convert( slices, 155 );
            rec.sewsep := Convert( slices, 156 );
            rec.sewtime := Convert( slices, 157 );
            rec.shelter := Convert( slices, 158 );
            rec.sobuy := Convert( slices, 159 );
            rec.sstrtreg := Convert( slices, 160 );
            rec.stramt1 := Convert( slices, 161 );
            rec.stramt2 := Convert( slices, 162 );
            rec.strcov := Convert( slices, 163 );
            rec.strmort := Convert( slices, 164 );
            rec.stroths := Convert( slices, 165 );
            rec.strpd1 := Convert( slices, 166 );
            rec.strpd2 := Convert( slices, 167 );
            rec.suballow := Convert( slices, 168 );
            rec.sublet := Convert( slices, 169 );
            rec.sublety := Convert( slices, 170 );
            rec.subrent := Convert( slices, 171 );
            rec.tenure := Convert( slices, 172 );
            rec.tvlic := Convert( slices, 173 );
            rec.typeacc := Convert( slices, 174 );
            rec.urindew := Convert( slices, 175 );
            rec.urinds := Convert( slices, 176 );
            rec.watamt := Convert( slices, 177 );
            rec.watanul := Convert( slices, 178 );
            rec.watermet := Convert( slices, 179 );
            rec.waterpay := Convert( slices, 180 );
            rec.watrb := Convert( slices, 181 );
            rec.wattime := Convert( slices, 182 );
            rec.whoctb01 := Convert( slices, 183 );
            rec.whoctb02 := Convert( slices, 184 );
            rec.whoctb03 := Convert( slices, 185 );
            rec.whoctb04 := Convert( slices, 186 );
            rec.whoctb05 := Convert( slices, 187 );
            rec.whoctb06 := Convert( slices, 188 );
            rec.whoctb07 := Convert( slices, 189 );
            rec.whoctb08 := Convert( slices, 190 );
            rec.whoctb09 := Convert( slices, 191 );
            rec.whoctb10 := Convert( slices, 192 );
            rec.whoctb11 := Convert( slices, 193 );
            rec.whoctb12 := Convert( slices, 194 );
            rec.whoctb13 := Convert( slices, 195 );
            rec.whoctb14 := Convert( slices, 196 );
            rec.whoctbot := Convert( slices, 197 );
            rec.whorsp01 := Convert( slices, 198 );
            rec.whorsp02 := Convert( slices, 199 );
            rec.whorsp03 := Convert( slices, 200 );
            rec.whorsp04 := Convert( slices, 201 );
            rec.whorsp05 := Convert( slices, 202 );
            rec.whorsp06 := Convert( slices, 203 );
            rec.whorsp07 := Convert( slices, 204 );
            rec.whorsp08 := Convert( slices, 205 );
            rec.whorsp09 := Convert( slices, 206 );
            rec.whorsp10 := Convert( slices, 207 );
            rec.whorsp11 := Convert( slices, 208 );
            rec.whorsp12 := Convert( slices, 209 );
            rec.whorsp13 := Convert( slices, 210 );
            rec.whorsp14 := Convert( slices, 211 );
            rec.whynoct := Convert( slices, 212 );
            rec.wsewamt := Convert( slices, 213 );
            rec.wsewanul := Convert( slices, 214 );
            rec.wsewtime := Convert( slices, 215 );
            rec.yearcode := Convert( slices, 216 );
            rec.yearlive := Convert( slices, 217 );
            rec.yrlvchk := Convert( slices, 218 );
            rec.month := Convert( slices, 219 );
            rec.adddahh := Convert( slices, 220 );
            rec.adulth := Convert( slices, 221 );
            rec.bedroom6 := Convert( slices, 222 );
            rec.chddahh := Convert( slices, 223 );
            rec.country := Convert( slices, 224 );
            rec.cwatamtd := Convert( slices, 225 );
            rec.depchldh := Convert( slices, 226 );
            rec.emp := Convert( slices, 227 );
            rec.emphrp := Convert( slices, 228 );
            rec.endowpay := Convert( slices, 229 );
            rec.gbhscost := Convert( slices, 230 );
            rec.gross3 := Convert( slices, 231 );
            rec.grossct := Convert( slices, 232 );
            rec.hbeninc := Convert( slices, 233 );
            rec.hbindhh := Convert( slices, 234 );
            rec.hbindhh2 := Convert( slices, 235 );
            rec.hdhhinc := Convert( slices, 236 );
            rec.hdtax := Convert( slices, 237 );
            rec.hearns := Convert( slices, 238 );
            rec.hhagegr2 := Convert( slices, 239 );
            rec.hhagegr3 := Convert( slices, 240 );
            rec.hhagegr4 := Convert( slices, 241 );
            rec.hhagegrp := Convert( slices, 242 );
            rec.hhcomps := Convert( slices, 243 );
            rec.hhdisben := Convert( slices, 244 );
            rec.hhinc := Convert( slices, 245 );
            rec.hhincbnd := Convert( slices, 246 );
            rec.hhinv := Convert( slices, 247 );
            rec.hhirben := Convert( slices, 248 );
            rec.hhnirben := Convert( slices, 249 );
            rec.hhothben := Convert( slices, 250 );
            rec.hhrent := Convert( slices, 251 );
            rec.hhrinc := Convert( slices, 252 );
            rec.hhrpinc := Convert( slices, 253 );
            rec.hhtvlic := Convert( slices, 254 );
            rec.hhtxcred := Convert( slices, 255 );
            rec.hothinc := Convert( slices, 256 );
            rec.hpeninc := Convert( slices, 257 );
            rec.hseinc := Convert( slices, 258 );
            rec.london := Convert( slices, 259 );
            rec.mortcost := Convert( slices, 260 );
            rec.mortint := Convert( slices, 261 );
            rec.mortpay := Convert( slices, 262 );
            rec.nihscost := Convert( slices, 263 );
            rec.penage := Convert( slices, 264 );
            rec.penhrp := Convert( slices, 265 );
            rec.ptentyp2 := Convert( slices, 266 );
            rec.rooms10 := Convert( slices, 267 );
            rec.servpay := Convert( slices, 268 );
            rec.struins := Convert( slices, 269 );
            rec.tentyp2 := Convert( slices, 270 );
            rec.tuhhrent := Convert( slices, 271 );
            rec.tuwatsew := Convert( slices, 272 );
            rec.watsewrt := Convert( slices, 273 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( HouseholdRec ).startPos = 0 ) then
               index.pointers( HouseholdRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( HouseholdRec ).counter := index.pointers( HouseholdRec ).counter + 1;
            Put_Index( index_map, index );
            Household_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Household_IO.Close( bin_file );
   end Create_Household_1011;


   procedure Create_Job_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Job_IO.File_Type;
      rec         : Job_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Job_IO.Create (bin_file, Job_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.jobtype := Convert( slices, 4 );
            rec.agreehrs := Convert( slices, 5 );
            rec.bonamt1 := Convert( slices, 6 );
            rec.bonamt2 := Convert( slices, 7 );
            rec.bonamt3 := Convert( slices, 8 );
            rec.bonamt4 := Convert( slices, 9 );
            rec.bonamt5 := Convert( slices, 10 );
            rec.bonamt6 := Convert( slices, 11 );
            rec.bontax1 := Convert( slices, 12 );
            rec.bontax2 := Convert( slices, 13 );
            rec.bontax3 := Convert( slices, 14 );
            rec.bontax4 := Convert( slices, 15 );
            rec.bontax5 := Convert( slices, 16 );
            rec.bontax6 := Convert( slices, 17 );
            rec.bonus := Convert( slices, 18 );
            rec.busaccts := Convert( slices, 19 );
            rec.caramt := Convert( slices, 20 );
            rec.carcon := Convert( slices, 21 );
            rec.carval := Convert( slices, 22 );
            rec.checktax := Convert( slices, 23 );
            rec.chkincom := Convert( slices, 24 );
            rec.chvamt := Convert( slices, 25 );
            rec.chvpd := Convert( slices, 26 );
            rec.chvsac := Convert( slices, 27 );
            rec.chvuamt := Convert( slices, 28 );
            rec.chvupd := Convert( slices, 29 );
            rec.chvusu := Convert( slices, 30 );
            rec.dedoth := Convert( slices, 31 );
            rec.deduc1 := Convert( slices, 32 );
            rec.deduc2 := Convert( slices, 33 );
            rec.deduc3 := Convert( slices, 34 );
            rec.deduc4 := Convert( slices, 35 );
            rec.deduc5 := Convert( slices, 36 );
            rec.deduc6 := Convert( slices, 37 );
            rec.deduc7 := Convert( slices, 38 );
            rec.deduc8 := Convert( slices, 39 );
            rec.dirctr := Convert( slices, 40 );
            rec.dirni := Convert( slices, 41 );
            rec.dvtothru := Convert( slices, 42 );
            rec.dvushr := Convert( slices, 43 );
            rec.empany := Convert( slices, 44 );
            rec.empown := Convert( slices, 45 );
            rec.etype := Convert( slices, 46 );
            rec.everot := Convert( slices, 47 );
            rec.expben01 := Convert( slices, 48 );
            rec.expben02 := Convert( slices, 49 );
            rec.expben03 := Convert( slices, 50 );
            rec.expben04 := Convert( slices, 51 );
            rec.expben05 := Convert( slices, 52 );
            rec.expben06 := Convert( slices, 53 );
            rec.expben07 := Convert( slices, 54 );
            rec.expben08 := Convert( slices, 55 );
            rec.expben09 := Convert( slices, 56 );
            rec.expben10 := Convert( slices, 57 );
            rec.expben11 := Convert( slices, 58 );
            rec.expben12 := Convert( slices, 59 );
            rec.ftpt := Convert( slices, 60 );
            rec.fuelamt := Convert( slices, 61 );
            rec.fuelbn := Convert( slices, 62 );
            rec.fuelpd := Convert( slices, 63 );
            rec.fueltyp := Convert( slices, 64 );
            rec.fueluamt := Convert( slices, 65 );
            rec.fuelupd := Convert( slices, 66 );
            rec.fuelusu := Convert( slices, 67 );
            rec.grwage := Convert( slices, 68 );
            rec.grwagpd := Convert( slices, 69 );
            rec.hha1 := Convert( slices, 70 );
            rec.hha2 := Convert( slices, 71 );
            rec.hha3 := Convert( slices, 72 );
            rec.hhc1 := Convert( slices, 73 );
            rec.hhc2 := Convert( slices, 74 );
            rec.hhc3 := Convert( slices, 75 );
            rec.hohinc := Convert( slices, 76 );
            rec.inclpay1 := Convert( slices, 77 );
            rec.inclpay2 := Convert( slices, 78 );
            rec.inclpay3 := Convert( slices, 79 );
            rec.inclpay4 := Convert( slices, 80 );
            rec.inclpay5 := Convert( slices, 81 );
            rec.inclpay6 := Convert( slices, 82 );
            rec.inclpay7 := Convert( slices, 83 );
            rec.issue := Convert( slices, 84 );
            rec.jobbus := Convert( slices, 85 );
            rec.likehr := Convert( slices, 86 );
            rec.mademp := Convert( slices, 87 );
            rec.matemp := Convert( slices, 88 );
            rec.matstp := Convert( slices, 89 );
            rec.mileamt := Convert( slices, 90 );
            rec.motamt := Convert( slices, 91 );
            rec.natins := Convert( slices, 92 );
            rec.nature := Convert( slices, 93 );
            rec.nidamt := Convert( slices, 94 );
            rec.nidpd := Convert( slices, 95 );
            rec.nmper := Convert( slices, 96 );
            rec.nomor1 := Convert( slices, 97 );
            rec.nomor2 := Convert( slices, 98 );
            rec.nomor3 := Convert( slices, 99 );
            rec.numemp := Convert( slices, 100 );
            rec.orgemp := Convert( slices, 101 );
            rec.othded1 := Convert( slices, 102 );
            rec.othded2 := Convert( slices, 103 );
            rec.othded3 := Convert( slices, 104 );
            rec.othded4 := Convert( slices, 105 );
            rec.othded5 := Convert( slices, 106 );
            rec.othded6 := Convert( slices, 107 );
            rec.othded7 := Convert( slices, 108 );
            rec.othded8 := Convert( slices, 109 );
            rec.othded9 := Convert( slices, 110 );
            rec.ownamt := Convert( slices, 111 );
            rec.ownotamt := Convert( slices, 112 );
            rec.ownother := Convert( slices, 113 );
            rec.ownsum := Convert( slices, 114 );
            rec.paperiod := Convert( slices, 115 );
            rec.payamt := Convert( slices, 116 );
            rec.paydat := Convert( slices, 117 );
            rec.paye := Convert( slices, 118 );
            rec.paypd := Convert( slices, 119 );
            rec.payslip := Convert( slices, 120 );
            rec.payusl := Convert( slices, 121 );
            rec.pothr := Convert( slices, 122 );
            rec.ppperiod := Convert( slices, 123 );
            rec.prbefore := Convert( slices, 124 );
            rec.prevmth := Convert( slices, 125 );
            rec.prevyr := Convert( slices, 126 );
            rec.profdocs := Convert( slices, 127 );
            rec.profit1 := Convert( slices, 128 );
            rec.profit2 := Convert( slices, 129 );
            rec.profni := Convert( slices, 130 );
            rec.proftax := Convert( slices, 131 );
            rec.rspoth := Convert( slices, 132 );
            rec.salsac := Convert( slices, 133 );
            rec.sapamt := Convert( slices, 134 );
            rec.se1 := Convert( slices, 135 );
            rec.se2 := Convert( slices, 136 );
            rec.sector := Convert( slices, 137 );
            rec.sectrnp := Convert( slices, 138 );
            rec.seend := Convert( slices, 139 );
            rec.seincamt := Convert( slices, 140 );
            rec.seincwm := Convert( slices, 141 );
            rec.selwks := Convert( slices, 142 );
            rec.seniiamt := Convert( slices, 143 );
            rec.seniinc := Convert( slices, 144 );
            rec.senilamt := Convert( slices, 145 );
            rec.senilump := Convert( slices, 146 );
            rec.seniramt := Convert( slices, 147 );
            rec.senireg := Convert( slices, 148 );
            rec.senirpd := Convert( slices, 149 );
            rec.setax := Convert( slices, 150 );
            rec.setaxamt := Convert( slices, 151 );
            rec.smpamt := Convert( slices, 152 );
            rec.smprate := Convert( slices, 153 );
            rec.sole := Convert( slices, 154 );
            rec.spnamt := Convert( slices, 155 );
            rec.spnpd := Convert( slices, 156 );
            rec.spnsac := Convert( slices, 157 );
            rec.spnuamt := Convert( slices, 158 );
            rec.spnupd := Convert( slices, 159 );
            rec.spnusu := Convert( slices, 160 );
            rec.sppamt := Convert( slices, 161 );
            rec.sspamt := Convert( slices, 162 );
            rec.taxamt := Convert( slices, 163 );
            rec.taxdamt := Convert( slices, 164 );
            rec.taxdpd := Convert( slices, 165 );
            rec.totus1 := Convert( slices, 166 );
            rec.ubonamt := Convert( slices, 167 );
            rec.uboninc := Convert( slices, 168 );
            rec.udeduc1 := Convert( slices, 169 );
            rec.udeduc2 := Convert( slices, 170 );
            rec.udeduc3 := Convert( slices, 171 );
            rec.udeduc4 := Convert( slices, 172 );
            rec.udeduc5 := Convert( slices, 173 );
            rec.udeduc6 := Convert( slices, 174 );
            rec.udeduc7 := Convert( slices, 175 );
            rec.udeduc8 := Convert( slices, 176 );
            rec.ugross := Convert( slices, 177 );
            rec.uincpay1 := Convert( slices, 178 );
            rec.uincpay2 := Convert( slices, 179 );
            rec.uincpay3 := Convert( slices, 180 );
            rec.uincpay4 := Convert( slices, 181 );
            rec.uincpay5 := Convert( slices, 182 );
            rec.uincpay6 := Convert( slices, 183 );
            rec.uincpay7 := Convert( slices, 184 );
            rec.umileamt := Convert( slices, 185 );
            rec.umotamt := Convert( slices, 186 );
            rec.unett := Convert( slices, 187 );
            rec.uothded1 := Convert( slices, 188 );
            rec.uothded2 := Convert( slices, 189 );
            rec.uothded3 := Convert( slices, 190 );
            rec.uothded4 := Convert( slices, 191 );
            rec.uothded5 := Convert( slices, 192 );
            rec.uothded6 := Convert( slices, 193 );
            rec.uothded7 := Convert( slices, 194 );
            rec.uothded8 := Convert( slices, 195 );
            rec.uothded9 := Convert( slices, 196 );
            rec.uothdtot := Convert( slices, 197 );
            rec.uothr := Convert( slices, 198 );
            rec.upd := Convert( slices, 199 );
            rec.usapamt := Convert( slices, 200 );
            rec.usmpamt := Convert( slices, 201 );
            rec.usmprate := Convert( slices, 202 );
            rec.usppamt := Convert( slices, 203 );
            rec.usspamt := Convert( slices, 204 );
            rec.usuhr := Convert( slices, 205 );
            rec.utaxamt := Convert( slices, 206 );
            rec.vchamt := Convert( slices, 207 );
            rec.vchpd := Convert( slices, 208 );
            rec.vchsac := Convert( slices, 209 );
            rec.vchuamt := Convert( slices, 210 );
            rec.vchupd := Convert( slices, 211 );
            rec.vchusu := Convert( slices, 212 );
            rec.whynou01 := Convert( slices, 213 );
            rec.whynou02 := Convert( slices, 214 );
            rec.whynou03 := Convert( slices, 215 );
            rec.whynou04 := Convert( slices, 216 );
            rec.whynou05 := Convert( slices, 217 );
            rec.whynou06 := Convert( slices, 218 );
            rec.whynou07 := Convert( slices, 219 );
            rec.whynou08 := Convert( slices, 220 );
            rec.whynou09 := Convert( slices, 221 );
            rec.whynou10 := Convert( slices, 222 );
            rec.whynou11 := Convert( slices, 223 );
            rec.whynou12 := Convert( slices, 224 );
            rec.whynou13 := Convert( slices, 225 );
            rec.whynou14 := Convert( slices, 226 );
            rec.workacc := Convert( slices, 227 );
            rec.workmth := Convert( slices, 228 );
            rec.workyr := Convert( slices, 229 );
            rec.wrkprev := Convert( slices, 230 );
            rec.month := Convert( slices, 231 );
            rec.hdqhrs := Convert( slices, 232 );
            rec.jobhours := Convert( slices, 233 );
            rec.jobsect := Convert( slices, 234 );
            rec.sspsmpfg := Convert( slices, 235 );
            rec.ugrspay := Convert( slices, 236 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( JobRec ).startPos = 0 ) then
               index.pointers( JobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( JobRec ).counter := index.pointers( JobRec ).counter + 1;
            Put_Index( index_map, index );
            Job_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Job_IO.Close( bin_file );
   end Create_Job_1011;


   procedure Create_Maint_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Maint_IO.File_Type;
      rec         : Maint_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Maint_IO.Create (bin_file, Maint_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.maintseq := Convert( slices, 4 );
            rec.issue := Convert( slices, 5 );
            rec.m := Convert( slices, 6 );
            rec.mrage := Convert( slices, 7 );
            rec.mramt := Convert( slices, 8 );
            rec.mrchwhy1 := Convert( slices, 9 );
            rec.mrchwhy2 := Convert( slices, 10 );
            rec.mrchwhy3 := Convert( slices, 11 );
            rec.mrchwhy4 := Convert( slices, 12 );
            rec.mrchwhy5 := Convert( slices, 13 );
            rec.mrchwhy6 := Convert( slices, 14 );
            rec.mrchwhy7 := Convert( slices, 15 );
            rec.mrchwhy8 := Convert( slices, 16 );
            rec.mrchwhy9 := Convert( slices, 17 );
            rec.mrct := Convert( slices, 18 );
            rec.mrkid := Convert( slices, 19 );
            rec.mrpd := Convert( slices, 20 );
            rec.mruamt := Convert( slices, 21 );
            rec.mrupd := Convert( slices, 22 );
            rec.mrus := Convert( slices, 23 );
            rec.mrv := Convert( slices, 24 );
            rec.month := Convert( slices, 25 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MaintRec ).startPos = 0 ) then
               index.pointers( MaintRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MaintRec ).counter := index.pointers( MaintRec ).counter + 1;
            Put_Index( index_map, index );
            Maint_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Maint_IO.Close( bin_file );
   end Create_Maint_1011;


   procedure Create_MortCont_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : MortCont_IO.File_Type;
      rec         : MortCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      MortCont_IO.Create (bin_file, MortCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.contseq := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.outsamt := Convert( slices, 5 );
            rec.outsincl := Convert( slices, 6 );
            rec.outspay := Convert( slices, 7 );
            rec.outspd := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortContRec ).startPos = 0 ) then
               index.pointers( MortContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortContRec ).counter := index.pointers( MortContRec ).counter + 1;
            Put_Index( index_map, index );
            MortCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      MortCont_IO.Close( bin_file );
   end Create_MortCont_1011;


   procedure Create_Mortgage_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Mortgage_IO.File_Type;
      rec         : Mortgage_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Mortgage_IO.Create (bin_file, Mortgage_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.mortseq := Convert( slices, 2 );
            rec.boramtdk := Convert( slices, 3 );
            rec.borramt := Convert( slices, 4 );
            rec.endwpri1 := Convert( slices, 5 );
            rec.endwpri2 := Convert( slices, 6 );
            rec.endwpri3 := Convert( slices, 7 );
            rec.endwpri4 := Convert( slices, 8 );
            rec.endwpri5 := Convert( slices, 9 );
            rec.incminc1 := Convert( slices, 10 );
            rec.incminc2 := Convert( slices, 11 );
            rec.incminc3 := Convert( slices, 12 );
            rec.incmp1 := Convert( slices, 13 );
            rec.incmp2 := Convert( slices, 14 );
            rec.incmp3 := Convert( slices, 15 );
            rec.incmpam1 := Convert( slices, 16 );
            rec.incmpam2 := Convert( slices, 17 );
            rec.incmpam3 := Convert( slices, 18 );
            rec.incmppd1 := Convert( slices, 19 );
            rec.incmppd2 := Convert( slices, 20 );
            rec.incmppd3 := Convert( slices, 21 );
            rec.intprpay := Convert( slices, 22 );
            rec.intprpd := Convert( slices, 23 );
            rec.issue := Convert( slices, 24 );
            rec.loan2y := Convert( slices, 25 );
            rec.loanyear := Convert( slices, 26 );
            rec.menpol := Convert( slices, 27 );
            rec.morall := Convert( slices, 28 );
            rec.morflc := Convert( slices, 29 );
            rec.morinpay := Convert( slices, 30 );
            rec.morinpd := Convert( slices, 31 );
            rec.morinus := Convert( slices, 32 );
            rec.mortend := Convert( slices, 33 );
            rec.mortleft := Convert( slices, 34 );
            rec.mortprot := Convert( slices, 35 );
            rec.morttype := Convert( slices, 36 );
            rec.morupd := Convert( slices, 37 );
            rec.morus := Convert( slices, 38 );
            rec.mpcover1 := Convert( slices, 39 );
            rec.mpcover2 := Convert( slices, 40 );
            rec.mpcover3 := Convert( slices, 41 );
            rec.mpolno := Convert( slices, 42 );
            rec.outsmort := Convert( slices, 43 );
            rec.rmamt := Convert( slices, 44 );
            rec.rmort := Convert( slices, 45 );
            rec.rmortyr := Convert( slices, 46 );
            rec.rmpur001 := Convert( slices, 47 );
            rec.rmpur002 := Convert( slices, 48 );
            rec.rmpur003 := Convert( slices, 49 );
            rec.rmpur004 := Convert( slices, 50 );
            rec.rmpur005 := Convert( slices, 51 );
            rec.rmpur006 := Convert( slices, 52 );
            rec.rmpur007 := Convert( slices, 53 );
            rec.rmpur008 := Convert( slices, 54 );
            rec.month := Convert( slices, 55 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( MortgageRec ).startPos = 0 ) then
               index.pointers( MortgageRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( MortgageRec ).counter := index.pointers( MortgageRec ).counter + 1;
            Put_Index( index_map, index );
            Mortgage_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Mortgage_IO.Close( bin_file );
   end Create_Mortgage_1011;


   procedure Create_Nimigr_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Nimigr_IO.File_Type;
      rec         : Nimigr_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Nimigr_IO.Create (bin_file, Nimigr_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.miper := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.miage := Convert( slices, 4 );
            rec.misex := Convert( slices, 5 );
            rec.mnthleft := Convert( slices, 6 );
            rec.more1yr := Convert( slices, 7 );
            rec.wherenow := Convert( slices, 8 );
            rec.month := Convert( slices, 9 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( NimigrRec ).startPos = 0 ) then
               index.pointers( NimigrRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( NimigrRec ).counter := index.pointers( NimigrRec ).counter + 1;
            Put_Index( index_map, index );
            Nimigr_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Nimigr_IO.Close( bin_file );
   end Create_Nimigr_1011;


   procedure Create_OddJob_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : OddJob_IO.File_Type;
      rec         : OddJob_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      OddJob_IO.Create (bin_file, OddJob_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.oddtype := Convert( slices, 4 );
            rec.oddseq := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.ojamt := Convert( slices, 7 );
            rec.ojnow := Convert( slices, 8 );
            rec.ojreg := Convert( slices, 9 );
            rec.month := Convert( slices, 10 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OddJobRec ).startPos = 0 ) then
               index.pointers( OddJobRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OddJobRec ).counter := index.pointers( OddJobRec ).counter + 1;
            Put_Index( index_map, index );
            OddJob_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      OddJob_IO.Close( bin_file );
   end Create_OddJob_1011;


   procedure Create_Owner_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Owner_IO.File_Type;
      rec         : Owner_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Owner_IO.Create (bin_file, Owner_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.buyyear := Convert( slices, 2 );
            rec.issue := Convert( slices, 3 );
            rec.othmort1 := Convert( slices, 4 );
            rec.othmort2 := Convert( slices, 5 );
            rec.othmort3 := Convert( slices, 6 );
            rec.othpur1 := Convert( slices, 7 );
            rec.othpur2 := Convert( slices, 8 );
            rec.othpur3 := Convert( slices, 9 );
            rec.othpur4 := Convert( slices, 10 );
            rec.othpur5 := Convert( slices, 11 );
            rec.othpur6 := Convert( slices, 12 );
            rec.othpur7 := Convert( slices, 13 );
            rec.purcamt := Convert( slices, 14 );
            rec.purcloan := Convert( slices, 15 );
            rec.month := Convert( slices, 16 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( OwnerRec ).startPos = 0 ) then
               index.pointers( OwnerRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( OwnerRec ).counter := index.pointers( OwnerRec ).counter + 1;
            Put_Index( index_map, index );
            Owner_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Owner_IO.Close( bin_file );
   end Create_Owner_1011;


   procedure Create_PenProv_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : PenProv_IO.File_Type;
      rec         : PenProv_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      PenProv_IO.Create (bin_file, PenProv_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.stemppen := Convert( slices, 4 );
            rec.provseq := Convert( slices, 5 );
            rec.eptype := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.penamt := Convert( slices, 8 );
            rec.penamtdt := Convert( slices, 9 );
            rec.penamtpd := Convert( slices, 10 );
            rec.penchk := Convert( slices, 11 );
            rec.pencon := Convert( slices, 12 );
            rec.pendat := Convert( slices, 13 );
            rec.penhelp := Convert( slices, 14 );
            rec.penreb := Convert( slices, 15 );
            rec.rebgov := Convert( slices, 16 );
            rec.spwho := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PenProvRec ).startPos = 0 ) then
               index.pointers( PenProvRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PenProvRec ).counter := index.pointers( PenProvRec ).counter + 1;
            Put_Index( index_map, index );
            PenProv_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      PenProv_IO.Close( bin_file );
   end Create_PenProv_1011;


   procedure Create_Pension_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Pension_IO.File_Type;
      rec         : Pension_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Pension_IO.Create (bin_file, Pension_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.penseq := Convert( slices, 4 );
            rec.another := Convert( slices, 5 );
            rec.issue := Convert( slices, 6 );
            rec.penoth := Convert( slices, 7 );
            rec.penpay := Convert( slices, 8 );
            rec.penpd := Convert( slices, 9 );
            rec.penpd1 := Convert( slices, 10 );
            rec.penpd2 := Convert( slices, 11 );
            rec.pentax := Convert( slices, 12 );
            rec.pentype := Convert( slices, 13 );
            rec.poamt := Convert( slices, 14 );
            rec.poinc := Convert( slices, 15 );
            rec.ptamt := Convert( slices, 16 );
            rec.ptinc := Convert( slices, 17 );
            rec.month := Convert( slices, 18 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PensionRec ).startPos = 0 ) then
               index.pointers( PensionRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PensionRec ).counter := index.pointers( PensionRec ).counter + 1;
            Put_Index( index_map, index );
            Pension_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Pension_IO.Close( bin_file );
   end Create_Pension_1011;


   procedure Create_Prscrptn_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Prscrptn_IO.File_Type;
      rec         : Prscrptn_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Prscrptn_IO.Create (bin_file, Prscrptn_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.benunit := Convert( slices, 2 );
            rec.person := Convert( slices, 3 );
            rec.issue := Convert( slices, 4 );
            rec.med12m01 := Convert( slices, 5 );
            rec.med12m02 := Convert( slices, 6 );
            rec.med12m03 := Convert( slices, 7 );
            rec.med12m04 := Convert( slices, 8 );
            rec.med12m05 := Convert( slices, 9 );
            rec.med12m06 := Convert( slices, 10 );
            rec.med12m07 := Convert( slices, 11 );
            rec.med12m08 := Convert( slices, 12 );
            rec.med12m09 := Convert( slices, 13 );
            rec.med12m10 := Convert( slices, 14 );
            rec.med12m11 := Convert( slices, 15 );
            rec.med12m12 := Convert( slices, 16 );
            rec.med12m13 := Convert( slices, 17 );
            rec.medrep := Convert( slices, 18 );
            rec.medrpnm := Convert( slices, 19 );
            rec.month := Convert( slices, 20 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( PrscrptnRec ).startPos = 0 ) then
               index.pointers( PrscrptnRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( PrscrptnRec ).counter := index.pointers( PrscrptnRec ).counter + 1;
            Put_Index( index_map, index );
            Prscrptn_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Prscrptn_IO.Close( bin_file );
   end Create_Prscrptn_1011;


   procedure Create_RentCont_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : RentCont_IO.File_Type;
      rec         : RentCont_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      RentCont_IO.Create (bin_file, RentCont_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.rentseq := Convert( slices, 2 );
            rec.accamt := Convert( slices, 3 );
            rec.accchk := Convert( slices, 4 );
            rec.accpay := Convert( slices, 5 );
            rec.accpd := Convert( slices, 6 );
            rec.issue := Convert( slices, 7 );
            rec.month := Convert( slices, 8 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RentContRec ).startPos = 0 ) then
               index.pointers( RentContRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RentContRec ).counter := index.pointers( RentContRec ).counter + 1;
            Put_Index( index_map, index );
            RentCont_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      RentCont_IO.Close( bin_file );
   end Create_RentCont_1011;


   procedure Create_Renter_1011( 
      tab_file_name   : String; 
      out_file_name   : String; 
      index_file_name : String ) is
      
      use GNAT.String_Split;
      use Conversions.FRS;
      use FRS_Binary_Reads;
      use Raw_FRS;
      use Ada.Strings.Unbounded;
      package usut renames Ada.Strings.Unbounded.Text_IO;
     
      line        : Unbounded_String;
      tab_file    : Text_IO.File_Type;
      slices      : Slice_Set;
      index       : Index_Rec;      
      index_map   : FRS_Index;
      bin_file    : Renter_IO.File_Type;
      rec         : Renter_Rec;      
      line_number : Natural := 0; -- count 1st line (the header) as 0 and data lines from 1
   begin
      Restore_Complete_Index( index_file_name, index_map ); 
      Text_IO.Open( tab_file, Text_IO.In_File, tab_file_name );
      Renter_IO.Create (bin_file, Renter_IO.Out_File, out_file_name );
      while not( Text_IO.End_Of_File( tab_file ) ) loop
         usut.Get_Line( tab_file, line );
         if( line_number > 0 ) then
            slices := TDA_Tokenize( line );
            rec.sernum := Convert( slices, 1 );
            rec.accjbp01 := Convert( slices, 2 );
            rec.accjbp02 := Convert( slices, 3 );
            rec.accjbp03 := Convert( slices, 4 );
            rec.accjbp04 := Convert( slices, 5 );
            rec.accjbp05 := Convert( slices, 6 );
            rec.accjbp06 := Convert( slices, 7 );
            rec.accjbp07 := Convert( slices, 8 );
            rec.accjbp08 := Convert( slices, 9 );
            rec.accjbp09 := Convert( slices, 10 );
            rec.accjbp10 := Convert( slices, 11 );
            rec.accjbp11 := Convert( slices, 12 );
            rec.accjbp12 := Convert( slices, 13 );
            rec.accjbp13 := Convert( slices, 14 );
            rec.accjbp14 := Convert( slices, 15 );
            rec.accjob := Convert( slices, 16 );
            rec.accnonhh := Convert( slices, 17 );
            rec.ctract := Convert( slices, 18 );
            rec.eligamt := Convert( slices, 19 );
            rec.eligpd := Convert( slices, 20 );
            rec.fairrent := Convert( slices, 21 );
            rec.furnish := Convert( slices, 22 );
            rec.hbenamt := Convert( slices, 23 );
            rec.hbenchk := Convert( slices, 24 );
            rec.hbenefit := Convert( slices, 25 );
            rec.hbenpd := Convert( slices, 26 );
            rec.hbenwait := Convert( slices, 27 );
            rec.hbmnth := Convert( slices, 28 );
            rec.hbrecp := Convert( slices, 29 );
            rec.hbweeks := Convert( slices, 30 );
            rec.hbyear := Convert( slices, 31 );
            rec.hbyears := Convert( slices, 32 );
            rec.issue := Convert( slices, 33 );
            rec.landlord := Convert( slices, 34 );
            rec.niystart := Convert( slices, 35 );
            rec.othtype := Convert( slices, 36 );
            rec.rebate := Convert( slices, 37 );
            rec.rent := Convert( slices, 38 );
            rec.rentdk := Convert( slices, 39 );
            rec.rentdoc := Convert( slices, 40 );
            rec.rentfull := Convert( slices, 41 );
            rec.renthol := Convert( slices, 42 );
            rec.rentpd := Convert( slices, 43 );
            rec.rentpd1 := Convert( slices, 44 );
            rec.rentpd2 := Convert( slices, 45 );
            rec.resll := Convert( slices, 46 );
            rec.resll2 := Convert( slices, 47 );
            rec.serinc1 := Convert( slices, 48 );
            rec.serinc2 := Convert( slices, 49 );
            rec.serinc3 := Convert( slices, 50 );
            rec.serinc4 := Convert( slices, 51 );
            rec.serinc5 := Convert( slices, 52 );
            rec.tentype := Convert( slices, 53 );
            rec.weekhol := Convert( slices, 54 );
            rec.wsinc := Convert( slices, 55 );
            rec.wsincamt := Convert( slices, 56 );
            rec.ystartr := Convert( slices, 57 );
            rec.month := Convert( slices, 58 );
            index := Get_Index( index_map, rec.SERNUM );
            if( index.pointers( RenterRec ).startPos = 0 ) then
               index.pointers( RenterRec ).startPos := line_number;
               index.SERNUM := rec.SERNUM;
            end if;
            index.pointers( RenterRec ).counter := index.pointers( RenterRec ).counter + 1;
            Put_Index( index_map, index );
            Renter_IO.Write( bin_file, rec );
         end if;
         line_number := line_number + 1;
      end loop;
      Text_IO.Close( tab_file );
      Store_Complete_Index( index_file_name, index_map );
      Renter_IO.Close( bin_file );
   end Create_Renter_1011;

